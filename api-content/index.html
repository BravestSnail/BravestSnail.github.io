{"posts":[{"title":"关于Kotlin构造函数、init函数和变量初始化的顺序探究","content":"Kotlin既有主构函数，又有次构函数，还有一个init函数，甚至还有属性的初始化，这些执行的顺序是怎么样的，一起来看看。 测试开始 测试类 怎么在主构函数，和属性初始化执行时，打印一个结果呢？毕竟这二者是没有函数体的。我的答案是Kotlin的also函数，这样就可以在执行的同时打印一个log了。 class ClassTest constructor( value: Int = 1.also { Log.d(&quot;test&quot;, &quot;主构函数&quot;) } ) { constructor(value: String): this(3) { Log.d(&quot;test&quot;, &quot;次构函数&quot;) } val value2 = 2.also { Log.d(&quot;test&quot;, &quot;初始化变量&quot;) } init { Log.d(&quot;test&quot;, &quot;init函数,value = $value&quot;) } } 从主构函数开始 我们在代码中使用主构函数构造ClassTest类。 ClassTest() 看看测试结果 D/test: 主构函数 D/test: 初始化变量 D/test: init函数,value = 1 可以看到顺序是：主构函数-&gt;初始化变量-&gt;init函数。 从次构函数开始 我们再看看次构函数，通过次构函数开始构造ClassTest类。 ClassTest(&quot;&quot;) 看看测试结果 D/test: 初始化变量 D/test: init函数,value = 3 D/test: 次构函数 没有打印出主构函数，这个结果很正常，因为这次我们是通过次构函数去构造的类，虽然它在仍然调用了主构函数，但是没有去调用我们的1.also { Log.d(&quot;test&quot;, &quot;主构函数&quot;) } ，这个默认值被覆盖掉了。 虽然没有主构函数的打印，但是根据前面的测试，我们可以猜测顺序应该是：主构函数-&gt;初始化变量-&gt;init函数-&gt;次构函数。 反编译 将ClassTest反编译成java代码可以看的跟清楚。 public final class ClassTest { private final int value2; public final int getValue2() { return this.value2; } public ClassTest(int value) { byte var2 = 2; int var4 = false; Log.d(&quot;test&quot;, &quot;初始化变量&quot;); Unit var6 = Unit.INSTANCE; this.value2 = var2; Log.d(&quot;test&quot;, &quot;init函数,value = &quot; + value); } // $FF: synthetic method // 主构函数 public ClassTest(int var1, int var2, DefaultConstructorMarker var3) { if ((var2 &amp; 1) != 0) { byte var4 = 1; int var6 = false; Log.d(&quot;test&quot;, &quot;主构函数&quot;); var1 = var4; } this(var1); } public ClassTest() { this(0, 1, (DefaultConstructorMarker)null); } //次构函数 public ClassTest(@NotNull String value) { Intrinsics.checkNotNullParameter(value, &quot;value&quot;); this(3); Log.d(&quot;test&quot;, &quot;次构函数&quot;); } } 从上面反编译的java代码可以清晰的看到各个过程的执行顺序，与我们猜测的结论是符合的。 结论 Kotlin构造函数、init函数和属性初始化的顺序是以下顺序： 主构函数-&gt;初始化变量-&gt;init函数-&gt;次构函数 ","link":"https://BravestSnail.github.io/post/关于Kotlin构造函数、init函数和属性初始化的顺序探究/"},{"title":"Java的继承和组合","content":"前言 继承破坏封装 Java有个三原则：封装、继承、多态。封装就是对外隐藏实现细节，提供简化接口。使用者不需要关心内部是怎么实现的，而且内部的实现细节是可以随时修改的，而不影响使用者。 继承可能破坏封装是因为子类和父类可能存在着实现细节的依赖。导致子类在继承父类的时候，往往不得不关心父类的实现细节，而父类在修改其实现细节的时候，如果不考虑子类，也往往会影响子类。 封装是如何被破坏的 考虑以下基类Base： public class Base { private static final int MAX_NUM = 1000; private int[] arr = new int[MAX_NUM]; private int count; public void add(int number){ if(count&lt;MAX_NUM){ arr[count++] = number; } } public void addAll(int[] numbers){ for(int num : numbers){ add(num);//addAll的实现依赖公开方法add } } } 子类继承Base类，并在添加数字的时候汇总数字。 public class Child extends Base { private long sum; @Override public void add(int number) { super.add(number); sum+=number; } @Override public void addAll(int[] numbers) { super.addAll(numbers);//问题1 for(int i=0;i&lt;numbers.length;i++){//问题2 sum+=numbers[i]; } } public long getSum() { return sum; } } 已上子类存在个大问题，addAll在实现的时候，是通过先调用基类的addAll方法，再对数字进行汇总，殊不知基类的addAll方法的实现是通过调用add方法来实现的，由于Java对象的多态性，本次调用的add方法实际是调用Child类的，因此在问题1处已经对数字进行过汇总了，而问题2处的汇总是重复的。 以上问题是继承破坏了封装的典型例子，子类本来在实现的时候，原则上是不需要关心父类的实现细节的，但是由于父类add和addAll的依赖关系，破坏了封装，需要程序设计者去阅读父类文档和源码。 解决问题 方法一：使用final避免继承 给方法加上final关键字，父类就保留了随意修改这个方法内部实现的自由，不用担心方法引用指向一个非预期的子类方法。 给类加上final关键字，父类就 保留了随意修改这个类实现的自由，使用者也不用担心，一个父类引用的变量，实际指向的却是一个完全不符合预期行为的子类对象。 方法二：优先使用组合而非继承 使用组合可以抵挡父类变化对子类的影响，从而包含子类。示例如下： public class Child { private Base base; private long sum; public Child(){ base = new Base(); } public void add(int number) { base.add(number); sum+=number; } public void addAll(int[] numbers) { base.addAll(numbers); for(int i=0;i&lt;numbers.length;i++){ sum+=numbers[i]; } } public long getSum() { return sum; } } 这样子类就不需要关心父类的实现细节了，父类修改实现也不会影响到子类了。但是这样存在一个问题，这样的子类，不能当做基类统一处理了。解决办法是使用接口，二者共同实现同一个接口。 方法三：正确使用继承 如果要使用继承，怎么正确使用呢？使用继承大概主要有三种场景： 基类是别人写的，我们写子类； 我们写基类，别人可能写子类； 基类、子类都是我们写的。 第1种场景中，基类主要是Java API、其他框架或类库中的类，在这 种情况下，我们主要通过扩展基类，实现自定义行为，这种情况下需要注意的是： 重写方法不要改变预期的行为； 阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的 依赖关系； 在基类修改的情况下，阅读其修改说明，相应修改子类。 第2种场景中，我们写基类给别人用，在这种情况下，需要注意的是： 使用继承反映真正的is-a关系，只将真正公共的部分放到基类； 对不希望被重写的公开方法添加final修饰符； 写文档，说明可重写方法的实现机制，为子类提供指导，告诉子类应该如何重写； 在基类修改可能影响子类时，写修改说明。 第3种场景，我们既写基类也写子类，关于基类，注意事项和第2种场景类似，关于子类，注意事项和第1种场景类似，不过程序都由我们控制，要求可以适当放松一些。 ","link":"https://BravestSnail.github.io/post/Java的继承和组合/"},{"title":"LiveData原理","content":"LiveData的使用 val livedata = LiveData&lt;Int&gt;() //发送数据 livedata.setValue()//立即生效，只能在主线程调用 livedata.postValue()//通过Handler转到主线程，有丢失数据的风险，可以用来在子线程调用 //观察数据 void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) livedata.observe(this) {} //第一个参数是一个`LifecycleOwner`对象，这个让LiveData具有与生命周期绑定的能力。 //第二个参数是一个`Observer`，是一个回调 LiveData的使用是十分的简单的，其原理也并不复杂。 observe方法 @MainThread //@MainThread 意味着必须在主线程调用它（我想这个与LiveData的使用场景有很深的联系，LiveData常常是用传递UI数据的，而UI必须在主线程更新） public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) { assertMainThread(&quot;observe&quot;); //若生命周期已经走到DESTROYED就不需要再继续了 if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore return; } //包装一下 LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); //observer与lifecycle一一对应，同一个observer不允许重复添加，通过lamba表达式添加的不是同一个observer ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(&quot;Cannot add the same observer&quot; + &quot; with different lifecycles&quot;); } if (existing != null) { return; } owner.getLifecycle().addObserver(wrapper); //将包装类添加为lifecycle的观察者 } 接下来看看是怎么与生命周期绑定的。 class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver { @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;? super T&gt; observer) { super(observer); mOwner = owner; } //判断当前生命周期是否大于STARTED，是就是活跃的 @Override boolean shouldBeActive() { return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); } //这个是生命周期变化的回调方法 @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState(); // DESTROYED状态移除observer if (currentState == DESTROYED) { removeObserver(mObserver); return; } Lifecycle.State prevState = null; // 当生命周期发生变化更新LiveData的活跃状态 while (prevState != currentState) { prevState = currentState; activeStateChanged(shouldBeActive()); currentState = mOwner.getLifecycle().getCurrentState(); } } @Override boolean isAttachedTo(LifecycleOwner owner) { return mOwner == owner; } @Override void detachObserver() { mOwner.getLifecycle().removeObserver(this); } } ---LiveData--- //将observer从LiveData的列表移除的同时，移除lifecycle的observer，且将活跃状态变为false @MainThread public void removeObserver(@NonNull final Observer&lt;? super T&gt; observer) { assertMainThread(&quot;removeObserver&quot;); ObserverWrapper removed = mObservers.remove(observer); if (removed == null) { return; } removed.detachObserver(); removed.activeStateChanged(false); } void activeStateChanged(boolean newActive) { if (newActive == mActive) { return; } // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; //记录LiveData活跃观察者的数量 changeActiveCounter(mActive ? 1 : -1); //在LiveData活跃状态下立刻分发值 if (mActive) { dispatchingValue(this); } } void dispatchingValue(@Nullable ObserverWrapper initiator) { if (mDispatchingValue) { mDispatchInvalidated = true; return; } mDispatchingValue = true; do { mDispatchInvalidated = false; if (initiator != null) { // observer转成活跃状态立刻分发一次值 considerNotify(initiator); initiator = null; } else { //遍历observer分发值 for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) { considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) { break; } } } } while (mDispatchInvalidated); mDispatchingValue = false; } //回调observer的onChanged方法 private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion &gt;= mVersion) { return; } //比较LiveData与Observer对象维护的版本号，一致就不在分发新值 //若不一致，回调onChanged分发新值(对于初始化的observer，其版本号为-1，只要LiveData中更 //新过版本号，那新的observer总是会在初始化后收到最新的值) observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData); } 在执行了observer()方法后，会将observer与lifecycle关联起来，当observer处于活跃状态才会给其分发值，而当observer由非活跃状态转为活跃状态，会立刻为其分发一次值。这一机制保证了Activity销毁重建后立刻会受到最新的值（粘性事件）。 setValue方法 @MainThread protected void setValue(T value) { assertMainThread(&quot;setValue&quot;); //维护的版本号 mVersion++; mData = value; //通知所有的观察者 dispatchingValue(null); } postValue方法 protected void postValue(T value) { //代表是否有post任务正在执行 boolean postTask; synchronized (mDataLock) { //设置postTask=true，在这条post真正执行之前，后续的post都会直接return被丢弃 postTask = mPendingData == NOT_SET; mPendingData = value; } if (!postTask) { //执行任务中，丢弃后续的post return; } ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); } private final Runnable mPostValueRunnable = new Runnable() { @SuppressWarnings(&quot;unchecked&quot;) @Override public void run() { Object newValue; synchronized (mDataLock) { //post任务执行完毕，将mPendingData = NOT_SET，可继续新的post任务 newValue = mPendingData; mPendingData = NOT_SET; } setValue((T) newValue); } }; @Override public void postToMainThread(Runnable runnable) { mDelegate.postToMainThread(runnable); } public class DefaultTaskExecutor extends TaskExecutor { //最终执行mPostValueRunnable的地方 @Override public void postToMainThread(Runnable runnable) { if (mMainHandler == null) { synchronized (mLock) { if (mMainHandler == null) { //创建了一个主线程Handler mMainHandler = createAsync(Looper.getMainLooper()); } } } //noinspection ConstantConditions mMainHandler.post(runnable); } } 从上面我们不难看出，postValue()是可能会在连续post的时候丢弃值，从LiveData使用场景来看，UI数据的变化往往只有收到最新的就OK了，这个并不影响LiveData传递UI数据。但是若是在需要密集连续传递数据的地方，需要避免使用postValue()，采用setValue方法或者选用其他的组件。 粘性事件 粘性事件的优势是毋庸置疑的，在注册新的observer就会收到最新数据，避免了开始新的Activity还需要手动获取一次数据。 但是有优点就有缺点，在一些场景下并不适用粘性事件，那要怎样解决这个问题呢。 方案一：粘性事件的原理核心就是LiveData和observer所维护的版本号，因此可以初始化observer的时候使两者相等即可。因为LiveData维护的版本号是私有的，因此若想实现这个的效果，得使用反射。 方案二：SingleLiveEvent，这个原理也十分简单，SingleLiveEvent维护了一个信号量，AtomicBoolean mPending = new AtomicBoolean(false) 当setValue置为true，意为有新值，在observer.onChanged时消耗掉。这样就实现了当添加一个新observer时，信号量为false，无法发送最新的值，也就失去了粘性。 ","link":"https://BravestSnail.github.io/post/LiveData原理/"},{"title":"ViewModel的研究","content":"ViewModel的使用场景 Activity or Fragment为Controller 场景一、Controller配置变化导致其重建 若需要保证Controller转屏前后的数据一致性，传统的方法需要我们在onSaveInstance保存数据，复杂类型的数据还必须实现Parcelable接口。使用ViewModel去维护数据则可以解决这个问题，ViewModel为我们在重建的时候保存了数据。 场景二、多Controler共享数据 若要实现Activity和Fragment之间的做法，我们常用的方法有：SharedPreference、Database、全局变量、两者之间回调。这些实现会随着业务规模的扩大，变得难以维护，且不易独立进行测试。ViewModel独立于两者之间，只有两者共同维护一个ViewModel实例，就能轻松实现共享数据，而且ViewModel是与生命周期绑定的，不用去手动销毁。 ViewModel的原理 如图所示： 所有已经实例化的ViewModel缓存在ViewModelStore中，其实质就是一个HashMap； ViewModerStore与具体的Controller绑定，并与宿主 Controller 俱生俱灭，所以这就解释了为何 ViewModel 与宿主 Controller 的生命周期是一样长了，因为缓存它的 ViewModelStore 与宿主 Controller 寿命相等； 获取ViewModel实例的方法委托给了ViewModerProvider, 若缓存中有则直接得到，若没有才创建并缓存； 源码分析 获取ViewModel的过程 public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) { //构造ViewModel工厂 mFactory = factory; //FragmentActivity或者Fragment持有的ViewModelStore mViewModelStore = store; } public class ViewModelStore { //key其实就是ViewModel的类名 private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); } 可以看到ViewModelProvider持有了ViewModelStore，而在ViewModelStore内部通过一个HashMap去维护ViewModel缓存。 @NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) { //获取ViewModel类名 String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); } return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass); } @NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { //尝试从缓存中获取ViewModel ViewModel viewModel = mViewModelStore.get(key); //获取的viewModel不为null if (modelClass.isInstance(viewModel)) { if (mFactory instanceof OnRequeryFactory) { //重新绑定生命周期 ((OnRequeryFactory) mFactory).onRequery(viewModel); } return (T) viewModel; } else { //noinspection StatementWithEmptyBody if (viewModel != null) { // TODO: log a warning. } } //为空通过工厂创建一个ViewModel if (mFactory instanceof KeyedFactory) { viewModel = ((KeyedFactory) mFactory).create(key, modelClass); } else { viewModel = mFactory.create(modelClass); } mViewModelStore.put(key, viewModel); return (T) viewModel; } 接下来看看工厂具体创建ViewModel的过程, 默认的工厂是SavedStateViewModelFactory。 public final class SavedStateViewModelFactory extends ViewModelProvider.KeyedFactory { public &lt;T extends ViewModel&gt; T create(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass); Constructor&lt;T&gt; constructor; //寻找合适的ViewModel构造方法 if (isAndroidViewModel &amp;&amp; mApplication != null) { constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE); } else { constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE); } // doesn't need SavedStateHandle //不需要SavedStateHandle直接通过工厂构建 if (constructor == null) { return mFactory.create(modelClass); } SavedStateHandleController controller = SavedStateHandleController.create( mSavedStateRegistry, mLifecycle, key, mDefaultArgs); //通过寻找的构造器构造 try { T viewmodel; if (isAndroidViewModel &amp;&amp; mApplication != null) { viewmodel = constructor.newInstance(mApplication, controller.getHandle()); } else { viewmodel = constructor.newInstance(controller.getHandle()); } viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller); return viewmodel; } } } ViewModel与宿主生命周期保持一致的原理 前面我们说ViewModel与ViewModel与宿主生命周期保持一致，其中原理是什么。 ViewModelStore树 ","link":"https://BravestSnail.github.io/post/ViewModel的研究/"},{"title":"横向粘性标题的研究","content":"最近因为项目需求，需要实现一个类似于粘性标题的功能，具体效果见封面。 思考了很久，也迭代了三个版本。 版本一 这个版本使用了两个ViewPager2嵌套的方式，通过一个ViewGroup去协调两个ViewPager2的滑动事件。看代码： class NestedViewPager @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : FrameLayout(context, attrs, defStyleAttr) { private val mViewPager2: ViewPager2 = ViewPager2(context, attrs, defStyleAttr).apply { layoutParams = ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT ) } private val count: Int get() = mViewPager2.adapter?.itemCount ?: 0 private var position = 0 private var lastX = 0f init { addView(mViewPager2) mViewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() { override fun onPageScrolled( position: Int, positionOffset: Float, positionOffsetPixels: Int ) { this@NestedViewPager.position = position } }) } var adapter: RecyclerView.Adapter&lt;*&gt;? get() = mViewPager2.adapter set(value) { mViewPager2.adapter = value } override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { val delta = ev.x - lastX when (ev.action) { MotionEvent.ACTION_MOVE -&gt; { Log.d(&quot;test&quot;, &quot;onInterceptTouchEvent: &quot;) val isDisallowIntercept = count &gt; 1 &amp;&amp; (position == 0 &amp;&amp; delta &lt; 0 || position == count - 1 &amp;&amp; delta &gt; 0 || position &gt; 0 &amp;&amp; position &lt; count - 1) parent.requestDisallowInterceptTouchEvent(isDisallowIntercept) } } lastX = ev.x return super.onInterceptTouchEvent(ev) } } 这个是内层的ViewPager2，由于ViewPager2是final的，不支持继承，因此只能采用在外面再套一层FrameLayout的方式去截取滑动事件，并且分发事件。 可以看到在37行，我重写了onInterceptTouchEvent方法，这个方法会在dispatchTouchEvent 方法中被调用，详细请看。在这里，我根据ViewPager当前显示的Item的，确定当是首尾两个Item并判断此时的滑动方向，决定是否要调用父View的requestDisallowInterceptTouchEvent，这个方法的作用是，当参数值为true的时候，请求父View不拦截这一次触摸事件序列，使得事件能够正确后续的事件能够正确的传递到子View。 值得注意的是：requestDisallowInterceptTouchEvent，需要将将父View设置为不拦截任何ACTION_DOWN事件，因 为 ACTION_DOWN 事 件 并 不 受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了 效果 版本二 效果太差，代码没有保存。大致思想是使用两个RecyclerView，然后通过一个父容器去协调两者的滑动事件。 版本三 这个应该是最终版，思想是每一组数据生成一个View，作为RecyclerView的子项，然后再根据RecyclerView的滑动去控制子View标题的协同滑动。 难点一 每一组的数据的数量是不同的且最大值无法确定，难道要为不同数量的数据各自编写layout，这是不现实的，最佳的方法是代码动态去生成。 class AuthorAdapter(val authors: List&lt;Pair&lt;String, List&lt;Celebrity&gt;&gt;&gt;) : RecyclerView.Adapter&lt;AuthorViewHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AuthorViewHolder { return AuthorViewHolder( ItemAuthorInfoLayout(parent.context,viewType).apply { LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT ) } ) } override fun onBindViewHolder(holder: AuthorViewHolder, position: Int) { holder.bind(authors[position]) } override fun getItemCount(): Int { return authors.size } override fun getItemViewType(position: Int): Int { return authors[position].second.size } } Adapter有一个getItemViewType，可以将数据的数量作为一个ViewType,再在onCreateViewHolder中拿到这个ViewType，然后在代码中去动态的调整View中子布局的数量。 class ItemAuthorInfoLayout @JvmOverloads constructor( context: Context, val viewType: Int = 0, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : LinearLayout(context, attrs, defStyleAttr) { private val defaultWidth = Res.getDimension(R.dimen.item_author_layout_width).toInt() private val mLayoutParamsOne = LayoutParams(defaultWidth * viewType, LayoutParams.WRAP_CONTENT) private val mLayoutParamsTwo = LayoutParams(defaultWidth, LayoutParams.WRAP_CONTENT) private val padding = Res.getDimension(R.dimen.subject_common_padding).toInt[[[[[[()]]]]]] private val titlePosition = 0 val authorItems: ArrayList&lt;ItemAuthorLayout&gt; = ArrayList[[()]] val title = TextView(context, attrs, defStyleAttr, R.style.SubjectInfo_Title).apply { layoutParams = mLayoutParamsTwo setPadding(padding, padding, padding, padding) } val titleContainer = LinearLayout(context).apply { orientation = HORIZONTAL layoutParams = mLayoutParamsOne addView(title) } val authorContainer = LinearLayout(context).apply { orientation = HORIZONTAL layoutParams = mLayoutParamsOne val inflater = LayoutInflater.from(context) (0 until viewType).forEach { _ -&gt; inflater.inflate(R.layout.item_author_layout, this, false).also { authorItems.add(it as ItemAuthorLayout) this.addView(it) } } } init { orientation = VERTICAL addView(titleContainer) addView(authorContainer) } } 难点二 该怎么去具体实现标题定住的效果呢，按照我现有的逻辑，标题是会随着RecyclerView的滑动而划走的。那我们来想想，是不是只要我们再滑动的时候，让标题往反方向上去滑动相同的距离，是不是就做到不动的效果了，看代码： class ItemAuthorInfoLayout @JvmOverloads constructor( context: Context, val viewType: Int = 0, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : LinearLayout(context, attrs, defStyleAttr) { fun scrollTitle(dx: Int){ val start = 0 val end = (viewType - 1) * defaultWidth val newX = dx + title.x if (newX &gt;= start &amp;&amp; newX &lt;= end) { title.x = newX invalidate() } else if (newX &lt; start &amp;&amp; title.x &gt; start) { title.x = start.toFloat() invalidate() } else if (newX &gt; end &amp;&amp; title.x &lt; end) { title.x = end.toFloat() invalidate() } } } 上面，我通过改变标题在容器内的相对位置并且调用invalidate重绘界面，来实现滑动的效果，上面大部分的判断是限制滑动的位置，读者可以不必关注。 最后，我们需要在RecyclerView滑动的时候调用我们的滑动方法。来看 private val container = itemView as RecyclerView container.addOnScrollListener(object : RecyclerView.OnScrollListener() { override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) { val position = layoutManager.findFirstVisibleItemPosition() if (position &gt; -1){ val view = layoutManager.findViewByPosition(position) as ItemAuthorInfoLayout view.scrollTitle(dx) } } }) 通过监听RecyclerView的滑动，然后去不断调用ItemAuthorInfoLayout的滑动方法，往相反的方向滑就可以实现这个需求了。 效果 ","link":"https://BravestSnail.github.io/post/横向粘性标题的研究/"},{"title":"自定义可以嵌套滑动的ListView","content":"继承ViewGroup ListView需要往里面添加子View，因此需要继承ViewGroup class MyListView @JvmOverloads constructor( context:Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ):ViewGroup(context, attrs, defStyleAttr) kotlin的函数默认值虽然可以做到函数重载的效果，但是要兼容java的函数重载还是需要一个@JvmOverload注解。 重写OnMeasure方法 这次我们只需要简单调用一下measureChildren想详细了解一下的可以，按住Ctrl+单击方法，可以进入方法内部，查看它的实现。 override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { super.onMeasure(widthMeasureSpec, heightMeasureSpec) measureChildren(widthMeasureSpec,heightMeasureSpec) }``` ## 重写OnLayout方法 为了实现竖直和水平方向的滑动，定义一个Orientation类。 ```kotlin enum class Orientation{ VERTICAL,HORIZONTAL } 看看onLayout方法 override fun onLayout(p0: Boolean, p1: Int, p2: Int, p3: Int, p4: Int) { when(orientation){ Orientation.VERTICAL -&gt;{ var height = 0 for (i in 0 until childCount){ val child = getChildAt(i) child.layout(0,height,child.measuredWidth,height + child.measuredHeight) height += child.measuredHeight } } Orientation.HORIZONTAL -&gt;{ var width = 0 for (i in 0 until childCount){ val child = getChildAt(i) child.layout(width,0,width + child.measuredWidth,child.measuredHeight) width += child.measuredWidth } } } } 从上面的代码来看，onLayout做的事就是遍历调用子view的layout方法，将子view在不同的方向上放置。 让ListView动起来 要让ListView动起来，我们要重写onTouchEvent方法，在用户在滑动屏幕的时候ListView跟着动起来。 在写之前我们要搞清楚几个问题 点击事件的传递规则 点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、 onInterceptTouchEvent和onTouchEvent，下面我们先介绍一下这几个方法。 public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前 View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event) 在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事 件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 public boolean onTouchEvent(MotionEvent event) 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 上述三个方法到底有什么区别呢？它们是什么关系呢？其实它们的关系可以用如下伪代码表示： public boolean dispatchTouchEvent(MotionEvent ev) { boolean consume = false; if (onInterceptTouchEvent(ev)) { consume = onTouchEvent(ev); } else { consume = child.dispatchTouchEvent(ev); } return consume; } 上述伪代码已经将三者的关系表现得淋漓尽致。通过上面的伪代码，我们也可以大致了解点击事件的 传递规则：对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件 就 会 交 给 这 个 ViewGroup 处 理 ， 即 它 的 onTouchEvent 方 法 就 会 被 调 用 ； 如 果 这 个 ViewGroup 的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。 View的滑动 见《Android开发艺术探索》3.3节 重写onTouchEvent方法 override fun onTouchEvent(event: MotionEvent): Boolean { val intercepted = when (event.action){ MotionEvent.ACTION_DOWN -&gt; { lastX = event.x lastY = event.y true } MotionEvent.ACTION_MOVE -&gt; { val deltaX = lastX - event.x val deltaY = lastY - event.y lastX = event.x lastY = event.y when(orientation){ Orientation.VERTICAL -&gt;{ if (isMove(deltaY,Orientation.VERTICAL)){ scrollBy(0,deltaY.toInt()) } } Orientation.HORIZONTAL -&gt;{ if (isMove(deltaX,Orientation.HORIZONTAL)){ scrollBy(deltaX.toInt(),0) } } } true } MotionEvent.ACTION_UP -&gt; { lastX = 0f lastY = 0f true } else -&gt; { super.onTouchEvent(event) } } return intercepted } 从上述代码可以看到，我们使用了lastX/Y去记录ACTION_DOWN发生或者之前ACTION_MOVE发生的坐标，在ACTION_MOVE事件发生后，计算出deltaX /Y也就是两个坐标之间的距离，在根据ListView的Orientation，调用scrollBy方法，在相应的方向做出滑动。 我们可以看到在滑动之前有一个isMove判断，该方法的作用是判断当前方向是否能够做出滑动动作。 private fun isMove(delta: Float,orientation: Orientation): Boolean = when(orientation){ Orientation.VERTICAL -&gt;{ val bottomY = (childCount - 1) * height delta &lt; 0 &amp;&amp; ((delta + scrollY &gt; 0).also { if (!it) scrollTo(0,0) }) || delta &gt; 0 &amp;&amp; ((scrollY + delta &lt; bottomY).also{ if (!it) scrollTo(0, bottomY) }) || delta == 0f } Orientation.HORIZONTAL -&gt;{ val endX = (childCount - 1) * width delta &lt; 0 &amp;&amp; ((delta + scrollX &gt; 0).also { if (!it) scrollTo(0,0) }) || delta &gt; 0 &amp;&amp; ((scrollX + delta &lt; endX).also{ if (!it) scrollTo(endX,0) }) || delta == 0f } } 以VERTICAL方向为例，当delta&lt;0时，滑动方向时自上而下，此时如果内容边界距离View边界的距离（scrollY）不够滑动，则我们不能够做出完整的滑动动作，只能够滑动到View的上边界scrollTo(0,0)；对于下边界同理。 嵌套滑动 如果在ListView中套一个ListView会如何呢? &lt;com.example.listdemo.MyListView android:id=&quot;@+id/list1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.example.listdemo.MyListView android:id=&quot;@+id/list2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/text1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/black&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/purple_500&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/purple_700&quot;/&gt; &lt;/com.example.listdemo.MyListView&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/teal_700&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/purple_200&quot;/&gt; &lt;/com.example.listdemo.MyListView&gt; 我们来分析一下：ViewGroup默认是不拦截任何事件的，也就是说只有在子View不处理点击事件的时候，事件才会传递到父ViewGroup处理；子View如果消费了该事件也就不会有点击事件交给父ViewGroup处理了。 综上，我们可以在事件经过ListView的时候，拦截下需要处理的事件，余下的再传递个子View。 重写onInterceptTouchEvent方法 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { val intercepted = when(ev.action){ MotionEvent.ACTION_DOWN -&gt;{ onTouchEvent(ev) false } MotionEvent.ACTION_MOVE -&gt;{ val deltaX = lastInterceptX - ev.x val deltaY = lastInterceptY - ev.y when (orientation){ Orientation.VERTICAL -&gt; { abs(deltaY) &gt; abs(deltaX) } Orientation.HORIZONTAL -&gt; { abs(deltaY) &lt; abs(deltaX) } } } MotionEvent.ACTION_UP -&gt;{ false } else -&gt; { false } } lastInterceptX = ev.x lastInterceptY = ev.y return intercepted } 重写onInterceptTouchEvent要注意的是，不能拦截ACTION_DOWN ,不然其之后的一系列事件都会拦截下来，不会传递到子View；拦截ACTION_UP 要慎重考虑，一旦拦截下来，子View的点击事件将不能被触发。 在ACTION_MOVE分支中，我们通过deltaX/Y在X轴和Y轴滑动的距离来判断是否拦截该事件。 值得注意的是：因为我们在没有拦截ACTION_DOWN事件，因此，在子View消耗了该事件之后，我们的父布局将收不到ACTION_DOWN引起的onTouchEvent的调用，会在嵌套滑动的时候产生意料之外的Bug，我的做法是在ACTION_DOWN事件主动调用onTouchEvent方法，将ACTION_DOWN事件传递过去。以上做法经供参考，还有其他的做法。 处理嵌套不只有上述做法，还内部拦截法等方法，详细参见《Android开发艺术探索》3.5节。 效果 参考文章 《Android开发艺术探索》3-4章 简单的ViewPager了解Scroller类 - byhieg - 博客园 ","link":"https://BravestSnail.github.io/post/自定义可以嵌套滑动的ListView/"},{"title":"通过自定义HsvEvaluator来学习自定义Evaluator原理","content":"前言 我们知道，Android系统为我们提供了一个计算颜色的Evaluator---ArgbEvaluator，为什么还要去实现一个HsvEvaluator。这当然是有其道理的，HSV的变换更符合人眼的直觉，可以看看下面HSV的详细解析。 先看看HSV颜色格式 HSV颜色空间中不同颜色对应的灰度范围 在机器视觉领域，我们除了对物体的外形，纹理特征进行检测识别，也可以利用颜色来识别不同物体。 比如水果的成熟程度。HSV指的是Hue色调分量，Saturation饱和度，Intensity明亮度。 以下摘自百度百科： 色调H 用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°； 饱和度S 饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。 亮度V（I：明度） 明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。 在HSV颜色空间中颜色分量Hue对应不同颜色的灰度范围如下： 0&lt;=h&lt;20， 红色 30&lt;=h&lt;45， 黄色 45&lt;=h&lt;90， 绿色 90&lt;=h&lt;125， 青色 125&lt;=h&lt;150， 蓝色 150&lt;=h&lt;175， 紫色 175&lt;=h&lt;200， 粉红色 200&lt;=h&lt;220， 砖红色 220&lt;=h&lt;255， 品红色 自定义Evaluator 实现Evaluator需要继承TypeEvaluator并重写evaluate()。 在下面的代码中，HsvEvaluator继承TypeEvaluator并重写evaluate()。evaluate()中的代码虽然多，但是并不复杂，核心是先将ARGB格式的颜色转换为HSV格式的颜色，并根据公式out=begin+(end−begin)∗fractionout=begin+(end−begin)∗fractionout = begin + (end - begin) * fractionout=begin+(end−begin)∗fractionout=begin+(end−begin)∗fractionout=begin+(end−begin)∗fraction来计算出当前动画对应的值，最后将HSV格式的颜色转换会ARGB格式，返回。 class HsvEvaluator() : TypeEvaluator&lt;Int&gt; { val startHsv = FloatArray(3) val endHsv = FloatArray(3) val outHsv = FloatArray(3) override fun evaluate(fraction: Float, startValue: Int?, endValue: Int?): Int { //转换ARGB为HSV //计算当前动画所对应的透明度 val outAlpha = if (startValue != null &amp;&amp; endValue != null){ Color.colorToHSV(startValue, startHsv) Color.colorToHSV(endValue, endHsv) startValue shr 24 + ((endValue shr 24 - startValue shr 24) * fraction).toInt() }else{ 0 } //计算动画完成度 if (endHsv[0] - startHsv[0] &gt; 180f) { endHsv[0] -= 360f } else if (endHsv[0] - startHsv[0] &lt; -180f) { endHsv[0] += 360f } outHsv[0] = startHsv[0] + (endHsv[0] - startHsv[0]) * fraction outHsv[0] = (outHsv[0] + 360f) % 360 outHsv[1] = startHsv[1] + (endHsv[1] - startHsv[1]) * fraction outHsv[2] = startHsv[2] + (endHsv[2] - startHsv[2]) * fraction //将HSV转换为ARGB return Color.HSVToColor(outAlpha,outHsv) } } 看看效果 代码： val animatorSet = AnimatorSet().apply { playTogether( ObjectAnimator.ofInt( findViewById(R.id.textView),&quot;backgroundColor&quot;, Color.RED,Color.GREEN ).apply { setEvaluator(ArgbEvaluator()) }, ObjectAnimator.ofInt( findViewById(R.id.textView1),&quot;backgroundColor&quot;, Color.RED,Color.GREEN ).apply { setEvaluator(HsvEvaluator()) } ) } animatorSet.setDuration(5000).start() 无论是HsvEvalutator，还是ArgbEvaluator都能完成颜色的平滑过度，但是仔细观察，就会觉得HsvEvalutator处理的颜色看得更顺眼一些，而ArgbEvaluator完成的颜色过度，会在一些时候显得更暗。这是自然的，HSV是为人类设计的颜色格式，而ARGB是为机器设计的格式。 总结 因此，在以后用到颜色的过度动画，我更推荐使用HsvEvalutator去计算颜色动画完成度。 ","link":"https://BravestSnail.github.io/post/通过自定义HsvEvaluator来学习自定义Evaluator原理/"},{"title":"自定义View遇到的问题","content":"问题描述 最近在写一个自定义天气折线图的时候遇到一个问题。 在定义一个View的itemCount属性的时候需要用到View的width，我思路是在onLayout()中通过width初始化它的值，因为此时View已经确定了它的宽高了。 private var itemCount = 1 set(value) { field = value itemWidth = width / value } private var itemWidth = width / itemCount set(value) { field = value beginX = value / 2 } private var beginX = itemWidth / 2 override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) { super.onLayout(changed, left, top, right, bottom) itemCount = 5 } 但是这段代码出现了一个意料之外的错误，我在为View应用属性动画的时候出现了问题，itemWidth和beginX等属性在动画一开始的时候属性值都为0，在运行了很短的时间后，它们的值才变成我预期的值。 //Log信息 D/test: drawPath: itemWidth=0,beginX=0 D/test: drawPath: itemWidth=0,beginX=0 D/test: drawPath: itemWidth=216,beginX=108 D/test: drawPath: itemWidth=216,beginX=108 D/test: drawPath: itemWidth=216,beginX=108 D/test: drawPath: itemWidth=216,beginX=108 D/test: drawPath: itemWidth=216,beginX=108 原因探究 我认为是在动画开始之前，View的onLayout()方法未得到调用，此时View.width属性的值还是0，导致我定义的属性值计算出来也是0。在动画运行了一段时间才对onLayout()进行调用，此时我定义的属性值才恢复正常。 解决办法 我的思路是将使用View.width的代码块暂时阻塞，等到onLayout()方法被调用，View.width的值不为0的时候，再唤醒前面的代码块，这样使得，在使用到View.width时，其必然值不等于0，因此，也能正确计算出itemWidth和beginX等属性的值。 最终，我采用Kotlin的协程async()将代码块暂时阻塞，在isReady=true(代码onLayout()已经被调用)时，唤醒代码块。代码如下： //标记width等属性是否已经准备好了 private var isReady = false override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) { super.onLayout(changed, left, top, right, bottom) itemCount = 5 isReady = false } private fun drawPath(posX: Float, maxPosY: Float, minPosY: Float) { MainScope().launch { val defferd = async { //使用width属性的代码块 } if (isReady) defferd.await() } } 近段时间发现这个解决办法存在问题 async在调用之时就会立刻执行它内部的代码块，而不是等到调用await方法后。 因此需要思考其他解决办法了。 ","link":"https://BravestSnail.github.io/post/自定义View遇到的问题/"}]}