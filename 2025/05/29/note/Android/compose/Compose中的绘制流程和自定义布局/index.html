<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose中的绘制流程和自定义布局 | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="与大多数其他界面工具包一样，Compose 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 Android View 系统，就会发现它有 3 个主要阶段：测量、布局和绘制。Compose 和它非常相似，但开头多了一个叫做“组合”的重要阶段。 Compose 有 3 个主要的阶段：  组合：要显示什么样的界面。Compose 运行Composable可组合函数并创建LayoutNode视图树">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose中的绘制流程和自定义布局">
<meta property="og:url" content="https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="与大多数其他界面工具包一样，Compose 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 Android View 系统，就会发现它有 3 个主要阶段：测量、布局和绘制。Compose 和它非常相似，但开头多了一个叫做“组合”的重要阶段。 Compose 有 3 个主要的阶段：  组合：要显示什么样的界面。Compose 运行Composable可组合函数并创建LayoutNode视图树">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-05-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.123Z">
<meta property="article:author" content="BravestSnail">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Compose">
<meta property="article:tag" content="绘制流程">
<meta property="article:tag" content="自定义布局">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose中的绘制流程和自定义布局",
  "url": "https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-05-29T16:00:00.000Z",
  "dateModified": "2025-06-04T12:46:35.123Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose中的绘制流程和自定义布局',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose中的绘制流程和自定义布局</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose中的绘制流程和自定义布局</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-29T16:00:00.000Z" title="发表于 2025-05-30 00:00:00">2025-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.123Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/note/">note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><!-- filepath: /Users/lijiapei/Project/Blog/source/_posts/note/compose/Compose中的绘制流程和自定义布局.md -->

<p>与大多数其他界面工具包一样，<code>Compose</code> 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 Android <code>View</code> 系统，就会发现它有 3 个主要阶段：<strong>测量、布局和绘制</strong>。<code>Compose</code> 和它非常相似，但开头多了一个叫做“<strong>组合</strong>”的重要阶段。</p>
<p>Compose 有 3 个主要的阶段：</p>
<ul>
<li><strong>组合</strong>：要显示什么样的界面。Compose 运行Composable可组合函数并创建LayoutNode视图树。</li>
<li><strong>布局</strong>：要放置界面的位置。该阶段包含两个步骤：<strong>测量</strong>和<strong>放置</strong>。对于视图树中的每个LayoutNode节点进行宽高尺寸测量并完成位置摆放，布局元素都会根据 2D 坐标来测量并放置自己及其所有子元素。</li>
<li><strong>绘制</strong>：渲染的方式。将所有LayoutNode界面元素会绘制到画布（通常是设备屏幕）之上。</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/924e17a22c959235c7ce1f7ed32e6c2b.png" alt="在这里插入图片描述"></p>
<p>这些阶段的顺序通常是相同的，从而让数据能够沿一个方向（从组合到布局，再到绘制）生成帧（也称为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81&spm=1001.2101.3001.7020">单向数据流</a>）。</p>
<p>您可以放心地假设每个帧都会以虚拟方式经历这 3 个阶段，但为了保障性能，Compose 会避免在所有这些阶段中重复执行根据相同输入计算出相同结果的工作。<strong>如果可以重复使用前面计算出的结果，Compose 会跳过对应的可组合函数；如果没有必要，Compose 界面不会对整个树进行重新布局或重新绘制。Compose 只会执行更新界面所需的最低限度的工作</strong>。之所以能够实现这种优化，是因为 Compose 会跟踪不同阶段中的<strong>状态读取</strong>。</p>
<p>所谓<strong>状态读取</strong>就是通常使用 <code>mutableStateOf()</code> 创建的，然后通过以下两种方式之一进行访问：</p>
<ul>
<li><strong>val state &#x3D; remember { mutableStateOf() }, 然后访问 <code>state.value</code> 属性值</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State read without property delegate.</span></span><br><span class="line"><span class="keyword">val</span> paddingState: MutableState&lt;Dp&gt; = remember &#123; mutableStateOf(<span class="number">8.</span>dp) &#125;</span><br><span class="line">Text(</span><br><span class="line">    text = <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    modifier = Modifier.padding(paddingState.value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>val state by remember { mutableStateOf() } 使用 Kotlin 属性委托 <code>by</code> 语法, 直接使用<code>state</code>值</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State read with property delegate.</span></span><br><span class="line"><span class="keyword">var</span> padding: Dp <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">8.</span>dp) &#125;</span><br><span class="line">Text(</span><br><span class="line">    text = <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    modifier = Modifier.padding(padding)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当您在上述任一阶段中读取快照状态值时，Compose 会自动跟踪在系统读取该值时正在执行的操作。通过这项跟踪，Compose 能够在状态值发生更改时重新执行读取程序；Compose 以这项跟踪为基础实现了对状态的观察。</p>
<h4 id="第-1-阶段：组合"><a href="#第-1-阶段：组合" class="headerlink" title="第 1 阶段：组合"></a><strong>第 1 阶段：组合</strong></h4><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/708926376968dba7f95898bcad16f69a.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9420a6e34d82e47d4349e877547de8ec.png" alt="在这里插入图片描述"></p>
<p>组合阶段的主要目标是生成并维护LayoutNode视图树，在Activity中执行setContent时，会开始首次组合，这会执行所有的Composable函数生成与之对应的LayoutNode视图树。而后当Composable依赖的状态值发生更改时，<code>Recomposer</code> 会安排重新运行所有要读取相应状态值的可组合函数，即所谓的重组。</p>
<ul>
<li>当前组件发生重组时，子Composable被依次重新调用，被调用的子Composable 会将当前传入的参数和之前重组中的参数进行比较，若参数变化，则Composable发生重组，更新LayoutNode视图树上的节点，UI发生更新。若参数无变化，则跳过本次执行，即所谓的智能重组，LayoutNode视图树中对应的节点不变，UI无变化。</li>
<li>当前组件发生重组时，如果子Composable在重组中没有被调用到，其对应节点及其子节点会从LayoutNode视图树中被删除，UI会从屏幕移除。</li>
</ul>
<p>根据组合结果，Compose 界面会运行布局和绘制阶段。请注意，<strong>如果输入未更改，运行时可能会决定跳过部分或全部可组合函数</strong>。如果<strong>内容保持不变，并且大小和布局也未更改</strong>，界面<strong>可能会跳过这些阶段</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> padding <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">8.</span>dp) &#125;</span><br><span class="line">Text(</span><br><span class="line">    text = <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    <span class="comment">// The `padding` state is read in the composition phase</span></span><br><span class="line">    <span class="comment">// when the modifier is constructed.</span></span><br><span class="line">    <span class="comment">// Changes in `padding` will invoke recomposition.</span></span><br><span class="line">    modifier = Modifier.padding(padding)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="第-2-阶段：布局"><a href="#第-2-阶段：布局" class="headerlink" title="第 2 阶段：布局"></a><strong>第 2 阶段：布局</strong></h4><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/45316c69cd79588ee34329236433b6b2.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a20725b1ffaecb48525f6268963788ac.png" alt="在这里插入图片描述"></p>
<p>布局阶段的主要目的是为了对视图树中的每个 LayoutNode 节点进行测量和摆放。</p>
<p>布局阶段包含两个步骤：<strong>测量</strong>和<strong>放置</strong>。<strong>测量步骤</strong>会运行传递给 <strong>Layout</strong> 可组合项的<strong>测量 lambda</strong>、<strong><code>LayoutModifier</code> 接口的 <code>MeasureScope.measure</code> 方法</strong>，等等。<strong>放置步骤</strong>会运行 <strong><code>layout</code></strong> 函数的放置位置块、<code>Modifier.offset &#123; … &#125;</code> 的 <code>lambda</code> 块，等等。</p>
<p>每个步骤的状态读取都会影响布局阶段，并且可能会影响绘制阶段。当<strong>状态值</strong>发生更改时，Compose 界面会安排<strong>布局阶段</strong>。如果<strong>大小</strong>或<strong>位置</strong>发生更改，界面还会运行<strong>绘制阶段</strong>。</p>
<p>更确切地说，<strong>测量步骤和放置步骤分别具有单独的重启作用域</strong>，这意味着，<strong>放置步骤中的状态读取不会在此之前重新调用测量步骤</strong>。不过，这两个步骤通常是<strong>交织</strong>在一起的，因此<strong>在放置步骤中读取的状态可能会影响属于测量步骤的其他重启作用域</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offsetX <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">8.</span>dp) &#125;</span><br><span class="line">Text(</span><br><span class="line">    text = <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    modifier = Modifier.offset &#123;</span><br><span class="line">        <span class="comment">// The `offsetX` state is read in the placement step</span></span><br><span class="line">        <span class="comment">// of the layout phase when the offset is calculated.</span></span><br><span class="line">        <span class="comment">// Changes in `offsetX` restart the layout.</span></span><br><span class="line">        IntOffset(offsetX.roundToPx(), <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>布局阶段用来对视图树中每个LayoutNode节点进行宽高尺寸测量并完成位置摆放。在Compose中，父节点会向子节点传递布局约束，布局约束中包含了父节点允许子节点的 最大宽高 和 最小宽高，当父节点希望子节点测量的宽高为某个具体的值时，约束中的最大宽高和最小宽高就是相同的。子节点根据父节点传给自己的布局约束进行自我测量。</p>
<p>在<code>Compose</code>框架中，<strong>LayoutNode不允许被多次测量</strong>，换句话说就是<strong>每个子元素只允许被测量一次</strong>。这意味着，你不能为了尝试不同的测量配置而多次测量任何子元素。在 Compose 的世界中，这个规则是强制性的，如果你不小心对某个子元素进行了多次测量，那么Compose会<strong>直接抛出异常</strong>导致应用崩溃。但在传统<code>View</code>中，每个父<code>View</code>可以对子<code>View</code>进行一次或多次测量，因此很容易导致测量次数发生指数级爆炸。所以传统<code>View</code>的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96&spm=1001.2101.3001.7020">性能优化</a>点之一就是减少<code>xml</code>中布局的嵌套层级，而在<code>Compose</code>中组件的多级嵌套也不会导致此问题。这也是为什么<code>Compose</code>比传统<code>View</code>性能高的原因之一。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1546930cc5a06ebe62bae0e2c136faaf.png" alt="在这里插入图片描述"><br>在 Compose 中，每个界面元素都有一个父元素，还可能有多个子元素。每个元素在其父元素中都有一个位置，指定为 <code>(x, y)</code> 位置；也都有一个尺寸，指定为 <code>width</code> 和 <code>height</code>。</p>
<p>在界面树中每个节点的布局过程分为三个步骤：</p>
<ol>
<li>测量所有子项</li>
<li>确定自己的尺寸</li>
<li>放置其子项</li>
</ol>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/09731f1ef1dc64ad202bd3a1da500985.png" alt="在这里插入图片描述"></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/974880b1c8ebd779f6c393f57a349068.gif" alt="在这里插入图片描述"></p>
<p>在测量完所有子元素的尺寸后，父元素才会对子元素进行摆放。在摆放时，系统会遍历视图树，执行所有的<code>place</code>命令。</p>
<h4 id="第-3-阶段：绘制"><a href="#第-3-阶段：绘制" class="headerlink" title="第 3 阶段：绘制"></a><strong>第 3 阶段：绘制</strong></h4><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/11cf61204358aa5b72e448275d7b2eae.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2fc86086d5eff107c0f69470d7d722a5.png" alt="在这里插入图片描述"></p>
<p>绘制代码期间的状态读取会影响绘制阶段。常见示例包括 <code>Canvas()</code>、<code>Modifier.drawBehind</code> 和 <code>Modifier.drawWithContent</code>。当<strong>状态值</strong>发生更改时，<code>Compose</code> 界面只会运行<strong>绘制阶段</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="keyword">by</span> remember &#123; mutableStateOf(Color.Red) &#125;</span><br><span class="line">Canvas(modifier = modifier) &#123;</span><br><span class="line">    <span class="comment">// The `color` state is read in the drawing phase</span></span><br><span class="line">    <span class="comment">// when the canvas is rendered.</span></span><br><span class="line">    <span class="comment">// Changes in `color` restart the drawing.</span></span><br><span class="line">    drawRect(color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d1ab1af182e70b83af37597a2c602835.png" alt="在这里插入图片描述"></p>
<h3 id="使用-Modifier-layout-自定义布局"><a href="#使用-Modifier-layout-自定义布局" class="headerlink" title="使用 Modifier.layout() 自定义布局"></a>使用 Modifier.layout() 自定义布局</h3><p>当我们需要进行自定义布局时，首选推荐的就是<code>Modifier.layout()</code>修饰符，通过使用 <code>Modifier.layout()</code> 可以手动控制元素的测量和布局。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.layout &#123; measurable, constraints -&gt;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>Modifier.layout()</code> 修饰符时，传入的回调 lambda 需要包含两个参数：<code>measurable</code>、<code>constraints</code></p>
<ul>
<li><strong><code>measurable</code></strong>：子元素LayoutNode的测量句柄，通过调用其提供的 <code>measure()</code> 方法完成LayoutNode的测量。</li>
<li><strong><code>constraints</code></strong>: 来自父LayoutNode的布局约束，包括最大宽高值与最小宽高值。</li>
</ul>
<h4 id="Modifier-layout-使用示例"><a href="#Modifier-layout-使用示例" class="headerlink" title="Modifier.layout() 使用示例"></a>Modifier.layout() 使用示例</h4><p>使用 Compose 的 <strong>Text</strong> 组件时，有时希望指定 <strong>Text</strong> 顶部到文本基线的高度，让文本看的更自然一些，使用内置的 <code>padding</code> 修饰符是无法满足需求的，因为<code>padding</code> 修饰符只能指定 <strong>Text</strong> 顶部到文本顶部的高度。虽然 Compose 已经提供了 <code>paddingFromBaseline</code> 修饰符来解决这个问题，不妨用 <code>layout</code> 修饰符来自己实现一个试试。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/42d4f9996eec69325968c381f370dc8b.png" alt="在这里插入图片描述"><br>我们创建一个 <code>paddingBaselineToTop</code> 的自定义修饰符，实现代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">paddingBaselineToTop</span><span class="params">(padding : <span class="type">Dp</span> = <span class="number">0.</span>dp)</span></span> = layout &#123; measurable, constraints -&gt;</span><br><span class="line">    <span class="keyword">val</span> placeable = measurable.measure(constraints) <span class="comment">// 使用父节点约束进行自我测量</span></span><br><span class="line">    check(placeable[FirstBaseline] != AlignmentLine.Unspecified) <span class="comment">// 保证组件存在内容基线</span></span><br><span class="line">    <span class="keyword">val</span> firstBaseline = placeable[FirstBaseline] <span class="comment">// 基线高度</span></span><br><span class="line">    <span class="keyword">val</span> paddingTop = padding.roundToPx() - firstBaseline <span class="comment">// [设置的基线到顶部的距离] - [基线的高度]</span></span><br><span class="line">    <span class="comment">// 仅改变高度为：高度 + paddingTop</span></span><br><span class="line">    layout(placeable.width, placeable.height + paddingTop) &#123;</span><br><span class="line">        placeable.placeRelative(<span class="number">0</span>, paddingTop) <span class="comment">// y坐标向下偏移paddingTop距离</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来说明一下在上面代码中发生了什么：</p>
<ul>
<li>正如前面布局阶段中所提到的，<strong>每个LayoutNode只允许被测量一次</strong>，这里使用了<code>measurable.measure(constraints)</code> 方法来完成子元素的测量，这里将父节点的 <code>constraints</code> 约束参数直接传入了子节点的 <code>measure</code> 方法中进行测量，这意味着：你将父节点的布局约束限制直接提供给了当前的子元素，自身没有增加任何额外的限制。</li>
<li>子元素测量的结果被包装在一个 <code>Placeable</code> 实例中，稍后即可通过该<code>Placeable</code> 实例来获取到刚刚子元素测量结果。</li>
<li>完成测量流程后，接下来就是布局过程，这需要调用 <code>layout(width, height)</code> 方法对当前元素的宽度与高度进行指定，这里将高度增加了<code>paddingTop</code>距离。</li>
<li>最后在 <code>layout()&#123; &#125;</code> 的 lambda 中调用 <code>placeable.place(x, y)</code> 或 <code>placeable.placeRelative(x, y)</code> （支持RTL）进行位置摆放。</li>
</ul>
<p>另外需要说明的一点是：作用域的使用决定了您可以衡量和放置子项的时机。即<strong>只能在测量和布局传递期间（即 MeasureScope 作用域中）测量布局</strong>，并且<strong>只能在布局传递期间（即 PlacementScope 作用域中）才能放置子项（且要在已进行测量之后）</strong>。此操作在编译时强制执行，所以不用担心你的代码放错了地方，编译器会提醒你。</p>
<p>接下来预览一下效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LayoutModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.background(Color.Green))&#123;</span><br><span class="line">        <span class="comment">// 设置和Modifier.paddingFromBaseline相同的效果</span></span><br><span class="line">        Text(text = <span class="string">&quot;paddingFromBaseline&quot;</span>, Modifier.paddingBaselineToTop(<span class="number">25.</span>dp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9b0d9e8e89725297f72f3f527fe91c0b.png" alt="在这里插入图片描述"></p>
<p>在熟悉了layout修饰符的使用流程之后，就可以根据业务需求自己定义更多的自定义修饰符来使用。</p>
<p>例如，下面是实现自定义类似系统内置的<code>offset</code>修饰符的功能：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LayoutModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.background(Color.Red)) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;Offset&quot;</span>, Modifier.myOffset(<span class="number">5.</span>dp)) <span class="comment">// 设置和 Modifier.offset(5.dp) 相同的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myOffset</span><span class="params">(x : <span class="type">Dp</span> = <span class="number">0.</span>dp, y : <span class="type">Dp</span> = <span class="number">0.</span>dp)</span></span> = layout &#123; measurable, constraints -&gt;</span><br><span class="line">    <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">    layout(placeable.width, placeable.height) &#123;</span><br><span class="line">        placeable.placeRelative(x.roundToPx(), y.roundToPx())  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面的例子实现了一个聊天对话框中消息气泡的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BubbleBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier : <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    text: <span class="type">String</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    fontSize : <span class="type">TextUnit</span> = <span class="number">18.</span>sp,</span></span></span><br><span class="line"><span class="params"><span class="function">    textColor : <span class="type">Color</span> = Color.Black,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowWidth: <span class="type">Dp</span> = <span class="number">16.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowHeight: <span class="type">Dp</span> = <span class="number">16.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowOffset: <span class="type">Dp</span> = <span class="number">8.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowDirection: <span class="type">ArrowDirection</span> = ArrowDirection.Left,</span></span></span><br><span class="line"><span class="params"><span class="function">    elevation: <span class="type">Dp</span> = <span class="number">2.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    backgroundColor: <span class="type">Color</span> = Color(<span class="number">0xffE7FFDB</span>)</span></span>,</span><br><span class="line">    padding: Dp = <span class="number">8.</span>dp</span><br><span class="line">) &#123;</span><br><span class="line">    Box(</span><br><span class="line">        modifier.drawBubble(</span><br><span class="line">            arrowWidth = arrowWidth,</span><br><span class="line">            arrowHeight = arrowHeight,</span><br><span class="line">            arrowOffset = arrowOffset,</span><br><span class="line">            arrowDirection = arrowDirection,</span><br><span class="line">            elevation = elevation,</span><br><span class="line">            color = backgroundColor</span><br><span class="line">        )</span><br><span class="line">        .padding(padding)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(text = text, fontSize = fontSize, color = textColor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">drawBubble</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowWidth: <span class="type">Dp</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowHeight: <span class="type">Dp</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowOffset: <span class="type">Dp</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowDirection: <span class="type">ArrowDirection</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    elevation: <span class="type">Dp</span> = <span class="number">0.</span>dp,</span></span></span><br><span class="line"><span class="params"><span class="function">    color: <span class="type">Color</span> = Color.Unspecified</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = composed &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> arrowWidthPx: <span class="built_in">Float</span> = arrowWidth.toPx()</span><br><span class="line">    <span class="keyword">val</span> arrowHeightPx: <span class="built_in">Float</span> = arrowHeight.toPx()</span><br><span class="line">    <span class="keyword">val</span> arrowOffsetPx: <span class="built_in">Float</span> = arrowOffset.toPx()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> shape = remember(arrowWidth, arrowHeight, arrowOffset, arrowDirection) &#123;</span><br><span class="line">        createBubbleShape(arrowWidthPx, arrowHeightPx, arrowOffsetPx, arrowDirection)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阴影和形状</span></span><br><span class="line">    <span class="keyword">val</span> shadowShapeModifier = Modifier.shadow(elevation, shape, spotColor = Color.Red, ambientColor = Color.Black)</span><br><span class="line">    <span class="keyword">val</span> shapeModifier = <span class="keyword">if</span> (elevation &gt; <span class="number">0.</span>dp) shadowShapeModifier <span class="keyword">else</span> Modifier.clip(shape)</span><br><span class="line"></span><br><span class="line">    Modifier.then(shapeModifier)</span><br><span class="line">        .background(color, shape)</span><br><span class="line">        .layout &#123; measurable, constraints -&gt;</span><br><span class="line">            <span class="keyword">val</span> isHorizontalArrow =</span><br><span class="line">                arrowDirection == ArrowDirection.Left || arrowDirection == ArrowDirection.Right</span><br><span class="line">            <span class="keyword">val</span> isVerticalArrow =</span><br><span class="line">                arrowDirection == ArrowDirection.Top || arrowDirection == ArrowDirection.Bottom</span><br><span class="line">            <span class="comment">// 箭头偏移量</span></span><br><span class="line">            <span class="keyword">val</span> offsetX = <span class="keyword">if</span> (isHorizontalArrow) arrowWidthPx.toInt() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> offsetY = <span class="keyword">if</span> (isVerticalArrow) arrowHeightPx.toInt() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 测量文本 根据箭头偏移量来设置文本的约束偏移信息</span></span><br><span class="line">            <span class="keyword">val</span> placeable = measurable.measure(</span><br><span class="line">                constraints.offset(horizontal = -offsetX, vertical = -offsetY)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// val placeable = measurable.measure(constraints)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 总宽度为文本宽度+箭头宽度</span></span><br><span class="line">            <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + offsetX)</span><br><span class="line">            <span class="comment">// 总高度为文本高度+箭头高度</span></span><br><span class="line">            <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + offsetY)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> posX = <span class="keyword">when</span> (arrowDirection) &#123;</span><br><span class="line">                ArrowDirection.Left -&gt; arrowWidthPx.toInt()</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> posY = <span class="keyword">when</span> (arrowDirection) &#123;</span><br><span class="line">                ArrowDirection.Top -&gt; arrowHeightPx.toInt()</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            layout(width, height) &#123;</span><br><span class="line">                placeable.placeRelative(posX, posY) <span class="comment">// 摆放文本</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">ArrowDirection</span> &#123; Left, Right, Top, Bottom &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createBubbleShape</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowWidth: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowHeight: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowOffset: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    arrowDirection: <span class="type">ArrowDirection</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: GenericShape &#123;</span><br><span class="line">    <span class="keyword">return</span> GenericShape &#123; size: Size, layoutDirection: LayoutDirection -&gt;</span><br><span class="line">        <span class="keyword">val</span> width = size.width</span><br><span class="line">        <span class="keyword">val</span> height = size.height</span><br><span class="line">        <span class="keyword">val</span> rect = RoundRect(</span><br><span class="line">            rect = Rect(<span class="number">0f</span>, <span class="number">0f</span>, width, height),</span><br><span class="line">            cornerRadius = CornerRadius(x = <span class="number">20f</span>, y = <span class="number">20f</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">when</span> (arrowDirection) &#123;</span><br><span class="line">            ArrowDirection.Left -&gt; &#123;</span><br><span class="line">                moveTo(arrowWidth, arrowOffset)</span><br><span class="line">                lineTo(<span class="number">0f</span>, arrowOffset)</span><br><span class="line">                lineTo(arrowWidth, arrowHeight + arrowOffset)</span><br><span class="line">                addRoundRect(rect.copy(left = arrowWidth))</span><br><span class="line">            &#125;</span><br><span class="line">            ArrowDirection.Right -&gt; &#123;</span><br><span class="line">                moveTo(width - arrowWidth, arrowOffset)</span><br><span class="line">                lineTo(width, arrowOffset)</span><br><span class="line">                lineTo(width - arrowWidth, arrowHeight + arrowOffset)</span><br><span class="line">                addRoundRect(rect.copy(right = width - arrowWidth))</span><br><span class="line">            &#125;</span><br><span class="line">            ArrowDirection.Top -&gt; &#123;</span><br><span class="line">                moveTo(arrowOffset, arrowHeight)</span><br><span class="line">                lineTo(arrowOffset + arrowWidth / <span class="number">2</span>, <span class="number">0f</span>)</span><br><span class="line">                lineTo(arrowOffset + arrowWidth, arrowHeight)</span><br><span class="line">                addRoundRect(rect.copy(top = arrowHeight))</span><br><span class="line">            &#125;</span><br><span class="line">            ArrowDirection.Bottom -&gt; &#123;</span><br><span class="line">                moveTo(arrowOffset, height - arrowHeight)</span><br><span class="line">                lineTo(arrowOffset + arrowWidth / <span class="number">2</span>, height)</span><br><span class="line">                lineTo(arrowOffset + arrowWidth, height - arrowHeight)</span><br><span class="line">                addRoundRect(rect.copy(bottom = height - arrowHeight))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BubbleBoxExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.background(Color(<span class="number">0xffFBE9E7</span>)).padding(<span class="number">8.</span>dp).fillMaxWidth()</span><br><span class="line">    ) &#123; </span><br><span class="line">        <span class="keyword">val</span> message1 = <span class="string">&quot;脱水！&quot;</span>.repeat(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">val</span> message2 = <span class="string">&quot;浸泡！&quot;</span>.repeat(<span class="number">10</span>) </span><br><span class="line">        BubbleBox(</span><br><span class="line">            text = message1,</span><br><span class="line">            arrowWidth = <span class="number">16.</span>dp,</span><br><span class="line">            arrowHeight = <span class="number">16.</span>dp,</span><br><span class="line">            arrowOffset = <span class="number">8.</span>dp,</span><br><span class="line">            arrowDirection = ArrowDirection.Left,</span><br><span class="line">            backgroundColor = Color(<span class="number">0xFFDEF3D4</span>),</span><br><span class="line">        ) </span><br><span class="line">        Spacer(Modifier.height(<span class="number">10.</span>dp)) </span><br><span class="line">        Box(modifier = Modifier.fillMaxWidth()) &#123;</span><br><span class="line">            BubbleBox(</span><br><span class="line">                text = message2,</span><br><span class="line">                modifier = Modifier.align(Alignment.CenterEnd),</span><br><span class="line">                arrowWidth = <span class="number">16.</span>dp,</span><br><span class="line">                arrowHeight = <span class="number">16.</span>dp,</span><br><span class="line">                arrowOffset = <span class="number">8.</span>dp,</span><br><span class="line">                arrowDirection = ArrowDirection.Right,</span><br><span class="line">                backgroundColor = Color(<span class="number">0xFF7EBAE2</span>),</span><br><span class="line">            )</span><br><span class="line">        &#125; </span><br><span class="line">        Spacer(Modifier.height(<span class="number">10.</span>dp)) </span><br><span class="line">        BubbleBox(</span><br><span class="line">            text = message1,</span><br><span class="line">            fontSize = <span class="number">16.</span>sp,</span><br><span class="line">            arrowWidth = <span class="number">24.</span>dp,</span><br><span class="line">            arrowHeight = <span class="number">16.</span>dp,</span><br><span class="line">            arrowOffset = <span class="number">10.</span>dp,</span><br><span class="line">            arrowDirection = ArrowDirection.Top,</span><br><span class="line">            backgroundColor = Color.Magenta,</span><br><span class="line">        ) </span><br><span class="line">        Spacer(Modifier.height(<span class="number">10.</span>dp)) </span><br><span class="line">        BubbleBox(</span><br><span class="line">            text = message2,</span><br><span class="line">            fontSize = <span class="number">16.</span>sp,</span><br><span class="line">            arrowWidth = <span class="number">24.</span>dp,</span><br><span class="line">            arrowHeight = <span class="number">16.</span>dp,</span><br><span class="line">            arrowOffset = <span class="number">10.</span>dp,</span><br><span class="line">            arrowDirection = ArrowDirection.Bottom,</span><br><span class="line">            backgroundColor = Color.Cyan,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/06949d921cd9a13e3bee670d9826b8ea.png" alt="在这里插入图片描述"></p>
<h3 id="使用-Layout-组件自定义布局"><a href="#使用-Layout-组件自定义布局" class="headerlink" title="使用 Layout 组件自定义布局"></a>使用 Layout 组件自定义布局</h3><p>除了<code>Modifier.layout()</code>修饰符，Compose 还提供了一个叫 <strong>Layout</strong> 的 Composable 组件，可以直接在 Composable 函数中调用，方便自定义布局。</p>
<p>前面的 Layout Modifier 似于传统 View 系统的 View 单元定制，而对于 “ViewGroup” 场景的定制，就需要使用 <strong>Layout</strong> 组件了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// custom layout attributes </span></span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content</span><br><span class="line">    ) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="comment">// measure and position children given constraints logic here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>Layout</strong> 需要填写三个参数：<code>modifier</code>，<code>content</code>，<code>measurePolicy</code></p>
<ul>
<li><strong><code>modifier</code></strong>：由外部传入的修饰符，会决定该 UI 元素的 constraints</li>
<li><strong><code>content</code></strong>：content是一个槽位，注意它的类型是一个Composable函数类型，在 content 中可以放置所有子元素</li>
<li><strong><code>measurePolicy</code></strong>：测量策略，默认场景下只实现 <code>measure</code> 方法即可，上面示例中最后传入的 lambda 就是 <code>measure</code> 方法的实现。</li>
</ul>
<h4 id="Layout-组件使用示例"><a href="#Layout-组件使用示例" class="headerlink" title="Layout 组件使用示例"></a>Layout 组件使用示例</h4><p>下面通过 <strong>Layout</strong> 组件定制一个自己专属的 <strong>Column</strong>，下面是实现代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyColumn</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(content = content, modifier = modifier) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.measure(constraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> yOffset = <span class="number">0</span></span><br><span class="line">        layout(constraints.maxWidth, constraints.maxHeight) &#123;</span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(x = <span class="number">0</span>, y = yOffset)</span><br><span class="line">                yOffset += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>Modifier.layout()</code>修饰符一样，我们需要对所有子组件进行一次测量。切记，<strong>每个子元素只允许被测量一次</strong>。</p>
<p>与<code>Modifier.layout()</code>修饰符不同的是，这里 <strong>Layout</strong> 组件的 <code>measurePolicy</code>提供的 <code>measure</code> 方法反回的 <code>measurables</code> 是一个 <code>List</code>，而在<code>layout</code>修饰符中则只是一个 <code>measurable</code>，因为它将所有子元素看作了一个整体。</p>
<p>在上面的示例中仍然不对子元素进行额外限制，最终将测量的结果保存到一个 <code>placeables</code> 的 <code>List</code> 中。 出于简单考虑，在调用 <code>layout(width, height)</code> 方法时，选择将宽度与高度设置为其父元素所允许的最大高度与宽度。 在调用<code>placeable.placeRelative(x, y)</code>摆放子元素的时候，由于 Column 是需要将子元素进行垂直排列的，所以仅需简单的将y坐标堆叠起来即可。</p>
<p>使用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomLayoutExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyColumn(Modifier.padding(<span class="number">10.</span>dp)) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;MyColumn&quot;</span>)</span><br><span class="line">        Text(text = <span class="string">&quot;AAAAAAAAAAAAAA&quot;</span>)</span><br><span class="line">        Text(text = <span class="string">&quot;BBBBBBBBBBBBB&quot;</span>)</span><br><span class="line">        Text(text = <span class="string">&quot;DDDDD&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预览一下效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomLayoutExamplePreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.height(<span class="number">200.</span>dp)) &#123;</span><br><span class="line">        CustomLayoutExample()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/739f9cf56a145c572f350184ec951075.png" alt="在这里插入图片描述"></p>
<p>前面提到 <strong>Layout</strong> 组件得到的 <code>measurables</code> 是一个 <code>List</code>，如果想从这个列表中查找某个子元素进行测量，可以通过为每个元素指定一个<code>layoutId</code>来查找，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyLayout(Modifier.fillMaxWidth().border(<span class="number">1.</span>dp, Color.Cyan)) &#123;</span><br><span class="line">    Image(</span><br><span class="line">        modifier = Modifier.size(<span class="number">150.</span>dp).layoutId(<span class="string">&quot;image&quot;</span>), <span class="comment">// 指定 layoutId</span></span><br><span class="line">        ...</span><br><span class="line">    )</span><br><span class="line">    Text(</span><br><span class="line">        modifier = Modifier.border(<span class="number">2.</span>dp, Color.Red).layoutId(<span class="string">&quot;text&quot;</span>), <span class="comment">// 指定 layoutId</span></span><br><span class="line">        text = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">MyLayout</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> imagePlaceable = measurables.firstOrNull &#123; it.layoutId == <span class="string">&quot;image&quot;</span> &#125;?.measure( <span class="comment">// 根据 layoutId 查找</span></span><br><span class="line">            constraints.copy(minWidth = <span class="number">0</span>, minHeight = <span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> textPlaceable = measurables.firstOrNull &#123; it.layoutId == <span class="string">&quot;text&quot;</span> &#125;?.measure(  <span class="comment">// 根据 layoutId 查找</span></span><br><span class="line">            constraints.copy(</span><br><span class="line">                minWidth = imagePlaceable?.width ?: constraints.minWidth,</span><br><span class="line">                maxWidth = imagePlaceable?.width ?: constraints.maxWidth</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> width = imagePlaceable?.width ?: constraints.minWidth</span><br><span class="line">        <span class="keyword">val</span> imagePlaceableHeight = imagePlaceable?.height ?: <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> height = imagePlaceableHeight  + (textPlaceable?.height ?: <span class="number">0</span>)</span><br><span class="line">        layout(width, height) &#123;</span><br><span class="line">            imagePlaceable?.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            textPlaceable?.placeRelative(<span class="number">0</span>, imagePlaceableHeight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个例子，下面代码使用 <strong>Layout</strong> 组件实现了一个 <strong>StaggeredGrid</strong> 瀑布流布局，它根据上一行组件的最大高度来对齐下一行的组件，并且自动换行显示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StaggeredGrid</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(content = content, modifier = modifier) &#123; measurables, constraints  -&gt;</span><br><span class="line">        <span class="keyword">val</span> constraintMaxWidth = constraints.maxWidth</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxRowWidth = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> currentWidthOfRow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> totalHeightOfRows = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> placeableMap = linkedMapOf&lt;<span class="built_in">Int</span>, Point&gt;()</span><br><span class="line">        <span class="keyword">val</span> rowHeights = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> maxPlaceableHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> lastRowHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.mapIndexed &#123; index, measurable -&gt;</span><br><span class="line">            <span class="comment">// 测量每个Child</span></span><br><span class="line">            <span class="keyword">val</span> placeable = measurable.measure(</span><br><span class="line">                <span class="comment">// 不限制每个Child的宽度，让child决定自己有多宽</span></span><br><span class="line">                constraints.copy(minWidth = <span class="number">0</span>, maxWidth = Constraints.Infinity)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 测量完成后，每个Child的宽高</span></span><br><span class="line">            <span class="keyword">val</span> placeableWidth = placeable.width</span><br><span class="line">            <span class="keyword">val</span> placeableHeight = placeable.height</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果【当前行的宽度总和】+【当前placeable的宽度】&lt;= 父布局的最大宽度</span></span><br><span class="line">            <span class="comment">// 那么说明当前placeable应该归属到当前行中，作为同一行展示</span></span><br><span class="line">            <span class="keyword">val</span> isSameRow = (currentWidthOfRow + placeableWidth &lt;= constraintMaxWidth)</span><br><span class="line">            <span class="keyword">val</span> xPos = <span class="keyword">if</span> (isSameRow) currentWidthOfRow <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> yPos: <span class="built_in">Int</span></span><br><span class="line">            <span class="keyword">if</span> (isSameRow) &#123;</span><br><span class="line">                <span class="comment">// 更新当前行的宽度总和：将当前placeable的宽度累加到当前行的宽度总和中</span></span><br><span class="line">                currentWidthOfRow += placeableWidth</span><br><span class="line">                <span class="comment">// 记录当前行中的最大高度</span></span><br><span class="line">                maxPlaceableHeight = maxPlaceableHeight.coerceAtLeast(placeableHeight)</span><br><span class="line">                <span class="comment">// 记录最长的那一行的最大宽度</span></span><br><span class="line">                maxRowWidth = maxRowWidth.coerceAtLeast(currentWidthOfRow)</span><br><span class="line">                lastRowHeight = maxPlaceableHeight <span class="comment">// 最后一行的最大高度</span></span><br><span class="line">                yPos = totalHeightOfRows <span class="comment">// 当前行的y坐标是到上一行为止的所有行的最大高度之和</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前placeable不在同一行，另起一行的逻辑</span></span><br><span class="line">                currentWidthOfRow = placeableWidth</span><br><span class="line">                totalHeightOfRows += maxPlaceableHeight <span class="comment">// 每次换行时累加总高度，把上一行的最大高度加进去</span></span><br><span class="line">                yPos = totalHeightOfRows <span class="comment">// 当前行的y坐标是到上一行为止的所有行的最大高度之和</span></span><br><span class="line">                rowHeights.add(maxPlaceableHeight) <span class="comment">// 收集每一行的最大高度</span></span><br><span class="line">                maxPlaceableHeight = placeableHeight <span class="comment">// 新的一行中开始比较的最大高度的初始值</span></span><br><span class="line">                lastRowHeight = maxPlaceableHeight <span class="comment">// 最后一行的最大高度</span></span><br><span class="line">            &#125;</span><br><span class="line">            placeableMap[index] = Point(xPos, yPos)</span><br><span class="line">            placeable</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算总高度</span></span><br><span class="line">        <span class="keyword">val</span> totalHeight = (rowHeights.sumOf &#123; it &#125; + lastRowHeight) <span class="comment">// 换到下一行时才会收集上一行的，因此最后缺少一行</span></span><br><span class="line">        <span class="keyword">val</span> finalHeight = constraints.constrainHeight(totalHeight) <span class="comment">// 高度限制在父约束[minHeight, maxHeight]之间</span></span><br><span class="line">        maxRowWidth = constraints.constrainWidth(maxRowWidth) <span class="comment">// 宽度限制在父约束[minWidth, maxWidth]之间 </span></span><br><span class="line">        <span class="comment">// 设置布局的大小尽可能大</span></span><br><span class="line">        layout(maxRowWidth, finalHeight) &#123;</span><br><span class="line">            placeables.forEachIndexed &#123; index, placeable -&gt;</span><br><span class="line">                <span class="keyword">val</span> point = placeableMap[index]</span><br><span class="line">                point?.let &#123; placeable.placeRelative(x = it.x, y = it.y) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StaggeredGridExample</span><span class="params">(tips: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> screenWidth = Resources.getSystem().displayMetrics.widthPixels.toFloat()</span><br><span class="line">    <span class="keyword">var</span> width <span class="keyword">by</span> remember &#123; mutableStateOf(screenWidth*<span class="number">0.8f</span>) &#125;</span><br><span class="line">    Column(Modifier.padding(<span class="number">5.</span>dp).fillMaxSize().verticalScroll(rememberScrollState())) &#123;</span><br><span class="line">        Slider(value = width, onValueChange = &#123;width = it&#125;, valueRange = <span class="number">0f</span>..screenWidth)</span><br><span class="line">        Text(<span class="string">&quot;StaggeredGrid width: <span class="subst">$&#123;width.toDp()&#125;</span>&quot;</span>)</span><br><span class="line">        Spacer(modifier = Modifier.height(<span class="number">10.</span>dp))</span><br><span class="line">        StaggeredGrid(</span><br><span class="line">            Modifier</span><br><span class="line">                <span class="comment">//.fillMaxWidth()</span></span><br><span class="line">                .width(width.toDp())</span><br><span class="line">                .border(<span class="number">3.</span>dp, Color.Magenta)</span><br><span class="line">        ) &#123;</span><br><span class="line">            tips.shuffled().forEachIndexed &#123; index, tip -&gt;</span><br><span class="line">                Box(</span><br><span class="line">                    Modifier</span><br><span class="line">                        .clip(RoundedCornerShape(<span class="number">50</span>))</span><br><span class="line">                        .background(colors[index % colors.size])</span><br><span class="line">                        .widthIn(min = <span class="number">50.</span>dp, max = <span class="number">200.</span>dp),</span><br><span class="line">                    contentAlignment = Alignment.Center</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Text(</span><br><span class="line">                        text = tip,</span><br><span class="line">                        color = Color.White,</span><br><span class="line">                        modifier = Modifier.padding(horizontal = <span class="number">8.</span>dp, vertical = <span class="number">5.</span>dp)</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StaggeredGridExampleTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tips = listOf(<span class="string">&quot;Compose&quot;</span>, <span class="string">&quot;Android&quot;</span>, <span class="string">&quot;扎心了，老铁&quot;</span>, <span class="string">&quot;干饭了&quot;</span>, <span class="string">&quot;内卷&quot;</span>,</span><br><span class="line">        <span class="string">&quot;StaggeredGrid&quot;</span>, <span class="string">&quot;锦鲤&quot;</span>, <span class="string">&quot;整个人都不好了&quot;</span>, <span class="string">&quot;卧槽&quot;</span>, <span class="string">&quot;无图无真相&quot;</span>, <span class="string">&quot;点赞收藏&quot;</span>,</span><br><span class="line">        <span class="string">&quot;在线等, 挺急的&quot;</span>, <span class="string">&quot;打工人&quot;</span>, <span class="string">&quot;是个狠人&quot;</span>, <span class="string">&quot;佛系交友&quot;</span>, <span class="string">&quot;火鸡科学家&quot;</span>, <span class="string">&quot;你是要把我笑死,然后继承我的花呗吗&quot;</span>,</span><br><span class="line">        <span class="string">&quot;补刀&quot;</span>, <span class="string">&quot;求生欲&quot;</span>, <span class="string">&quot;辣眼睛&quot;</span>, <span class="string">&quot;天生我材必有用，千金散尽还复来&quot;</span>, <span class="string">&quot;不忘初心&quot;</span>, <span class="string">&quot;割韭菜&quot;</span>, <span class="string">&quot;惊不惊喜，意不意外&quot;</span>, <span class="string">&quot;社交牛逼症&quot;</span>, <span class="string">&quot;安排&quot;</span>, <span class="string">&quot;YYDS&quot;</span>,</span><br><span class="line">        <span class="string">&quot;奥利给&quot;</span>, <span class="string">&quot;内容引起极度舒适&quot;</span>, <span class="string">&quot;OMG&quot;</span>, <span class="string">&quot;笑容渐渐凝固&quot;</span>, <span class="string">&quot;XSWL&quot;</span>, <span class="string">&quot;莫愁前路无知己，天下谁人不识君&quot;</span>, <span class="string">&quot;疑车无据&quot;</span>, <span class="string">&quot;快放我下车&quot;</span>,</span><br><span class="line">        <span class="string">&quot;听君一些话，如听一席话&quot;</span>, <span class="string">&quot;盘他&quot;</span>, <span class="string">&quot;躺平&quot;</span>, <span class="string">&quot;阳康了吗&quot;</span>, <span class="string">&quot;做核酸&quot;</span>, <span class="string">&quot;绿码&quot;</span>, <span class="string">&quot;爷青回&quot;</span>, <span class="string">&quot;元气满满&quot;</span>, <span class="string">&quot;黄沙百战穿金甲&quot;</span>)</span><br><span class="line">    StaggeredGridExample(tips)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了查看自定义的<code>StaggeredGrid</code>在不同宽度下的表现，所以这里使用了<code>Slider</code>动态控制<code>StaggeredGrid</code>的宽度，实际中你可以直接对<code>StaggeredGrid</code>应用<code>fillMaxWidth()</code>或固定宽度值。</p>
<p>运行效果如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/82ba64f6ee7c268ac04612528e66a74a.gif" alt="在这里插入图片描述"></p>
<p>下面是本示例代码实现的核心要点：</p>
<ul>
<li>测量每个Child时，不对其宽度进行约束限制，每个Child可以自由决定自己显示多大。</li>
<li>如何实现自动换行：逐步累加每一个Child的宽度，当宽度超过父约束的最大宽度值时，就应该另起一行放置该Child，否则该Child就放在同一行。</li>
<li>每个Child的x轴坐标计算：如果是同一行的Child，x坐标就是不断累加的当前行的总宽度，如果是另起一行的Child，则x坐标就是0。</li>
<li>每个Child的y轴坐标计算：每次换到下一行时，累加上一行中的最大高度值。如果Child没有换行，则y坐标就是这个累加的值。</li>
<li>StaggeredGrid的总宽度计算：所有行中的宽度总和的最大值，即最长的那一行。注意需要使用父约束对象对总宽度进行约束，防止溢出。</li>
<li>StaggeredGrid的总高度计算：在每次换行时，收集上一行中的最大高度值到一个List集合中，最后累加起来，但是由于是换到下一行时才会收集上一行的，因此最后会缺少一行的最大高度，因此记得要把最后一行的高度算进去。同样注意需要使用父约束对象对总高度进行约束，防止溢出。</li>
</ul>
<h4 id="Layout-Modifier-layout-小结"><a href="#Layout-Modifier-layout-小结" class="headerlink" title="Layout &#x2F; Modifier.layout 小结"></a>Layout &#x2F; Modifier.layout 小结</h4><p>最后，针对 <strong>Modifier.layout()</strong> 修饰符和 <strong>Layout</strong> 组件的使用进行一个简要总结（因为二者在使用上是类似的）:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9bd8edcbfe3c3b9bdbf1b3a343273546.png" alt="在这里插入图片描述"></p>
<p>并且我再次补充说明一下 <strong>Modifier.layout()</strong> 修饰符和 <strong>Layout</strong> 组件之间的使用区别：前者主要用于针对单个组件的定制，因为这时可能我们想要的不是在一个容器内包装很多个复杂的子组件，而是针对某个组件单元应用一些自定义的效果；而后者悄悄相反，这时说明我们的自定义组件使用到多个子组件，并需要处理它们之间的关系。</p>
<h3 id="Constraints-约束详解"><a href="#Constraints-约束详解" class="headerlink" title="Constraints 约束详解"></a>Constraints 约束详解</h3><p>在 Jetpack Compose 中自定义布局时，需要永远记住的一条黄金法则就是：<strong>父组件向子组件传递约束条件，子组件根据父组件传递的约束条件来决定如何测量子元素。</strong></p>
<p>约束条件限制了元素的 <code>width</code> 和 <code>height</code> 的最小值和最大值。如果某个元素拥有子元素，它可能会测量每个子元素，以帮助确定其尺寸。</p>
<p>约束条件会在整个视图树中从上往下进行传递，而测量结果的尺寸大小（表现为 <code>placeable</code> 对象）则会沿着视图树从下向上反馈：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a209653a7303e1c39edc12bd1424f3d7.png" alt="在这里插入图片描述"></p>
<p>只有在所有子元素测量完确定了尺寸大小之后，父组件才知道该如何摆放它们（执行place操作）。</p>
<p>约束条件由 <strong>Constraints</strong> 对象表示，它包含了如下四个值：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e117ec0552735ba8546161e969b651d7.png" alt="在这里插入图片描述"></p>
<p>下面通过以下示例代码来理解一下约束条件的传递对结果的影响：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">CustomColumnWithDefaultConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content</span><br><span class="line">    ) &#123; measurables: List&lt;Measurable&gt;, constraints: Constraints -&gt; </span><br><span class="line">        createCustomColumnLayout(measurables, constraints, constraints)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">createCustomColumnLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    measurables: <span class="type">List</span>&lt;<span class="type">Measurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    constraints: <span class="type">Constraints</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    updatedConstraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MeasureResult &#123;</span><br><span class="line">    <span class="comment">// 使用 updatedConstraints 约束测量每个 child</span></span><br><span class="line">    <span class="keyword">val</span> placeables = measurables.map &#123; measurable -&gt;</span><br><span class="line">        measurable.measure(updatedConstraints)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalHeight = placeables.sumOf &#123; it.height &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可选的操作一般有：</span></span><br><span class="line">    <span class="comment">// 1) 选择所有子元素中的一个最大的宽（或高）来作为自身的宽（或高）</span></span><br><span class="line">    <span class="comment">// val contentWidth = placeables.maxOf &#123; it.width &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2) 累加所有子元素的宽（或高）作为自身的宽（或高）</span></span><br><span class="line">    <span class="comment">// val contentWidth = placeables.sumOf &#123; it.width &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3) 直接使用传入的父组件的约束条件中的宽（或高）作为自身的宽（或高）</span></span><br><span class="line">    <span class="keyword">val</span> contentWidth = constraints.maxWidth</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4) 修改传入的父组件的约束条件中的某个值，使用更新后的约束信息</span></span><br><span class="line">    <span class="comment">// val contentWidth = updatedConstraints.maxWidth </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置布局的大小尽可能的大</span></span><br><span class="line">    <span class="keyword">return</span> layout(contentWidth, totalHeight) &#123;</span><br><span class="line">        <span class="comment">// 在当前组件中摆放每个child</span></span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">        placeables.forEach &#123; placeable -&gt;</span><br><span class="line">            placeable.placeRelative(x = <span class="number">0</span>, y = y)</span><br><span class="line">            y += placeable.height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CustomColumnWithDefaultConstraints(</span><br><span class="line">    modifier = Modifier.fillMaxWidth().border(<span class="number">2.</span>dp, Green400)</span><br><span class="line">) &#123; Content() &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Content</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Text(</span><br><span class="line">        <span class="string">&quot;First Text&quot;</span>,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .background(Pink400).padding(<span class="number">8.</span>dp),</span><br><span class="line">        color = Color.White</span><br><span class="line">    )</span><br><span class="line">    Text(</span><br><span class="line">        <span class="string">&quot;Second Text&quot;</span>,</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .background(Blue400).padding(<span class="number">8.</span>dp),</span><br><span class="line">        color = Color.White</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中为父组件添加了一个绿色的边框，为两个子组件添加了不同的背景色，以便区分。</p>
<p>下面通过尝试在 <code>CustomColumnWithDefaultConstraints</code> 组件的 <code>Modifier</code> 上应用不同的尺寸约束条件，观察并分析结果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/5aac426129a0eef8626ea1b0fca9839e.png" alt="在这里插入图片描述"></p>
<hr>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6a6b0d7250ce151459cfec52c7a9e9ad.png" alt="在这里插入图片描述"></p>
<hr>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6d8b12c48123153bc306c2d23ad48d81.png" alt="在这里插入图片描述"></p>
<hr>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/227423abc09360400725c8858bf728e9.png" alt="在这里插入图片描述"></p>
<hr>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9001f41c9cc9ac8eea38231ce580573f.png" alt="在这里插入图片描述"></p>
<p>下面修改一下代码，自定义Layout组件测量子元素使用的约束条件不再直接使用父组件传入的约束条件，而是进行一些修改，比如将最大最小宽度值全部强制设为使用父约束的最大宽度值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">CustomColumnWithCustomConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content</span><br><span class="line">    ) &#123; measurables: List&lt;Measurable&gt;, constraints: Constraints -&gt; </span><br><span class="line">        <span class="keyword">val</span> updatedConstraints = constraints.copy( <span class="comment">// 拷贝一份父约束进行修改</span></span><br><span class="line">                minWidth = constraints.maxWidth,</span><br><span class="line">                maxWidth = constraints.maxWidth</span><br><span class="line">            )  </span><br><span class="line">        createCustomColumnLayout(measurables, constraints, updatedConstraints)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>createCustomColumnLayout</code> 方法和前面的一样。</p>
<p>调用方式还是和前面类似：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CustomColumnWithCustomConstraints(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .wrapContentSize()</span><br><span class="line">            .border(<span class="number">2.</span>dp, Green400)</span><br><span class="line">    ) &#123; Content() &#125;</span><br></pre></td></tr></table></figure>

<p>同样通过尝试在 <code>CustomColumnWithDefaultConstraints</code> 组件的 <code>Modifier</code> 上应用不同的尺寸约束条件，观察并分析结果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/81e5f96ee2c3bb5b34bfcca8427eead4.png" alt="在这里插入图片描述"></p>
<p>跟前面一样进行其他几种情况的应用后发现，结果都类似，所以这里只列出这一种情况的分析结果。因为子组件的约束信息都使用了固定宽度值来测量，测量结果的宽度总是保持和父组件的<code>maxWidth</code>一致。可以通过下图进行对比：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/cd52108795994a7feaa10738e708da99.png" alt="在这里插入图片描述"><br>下面继续修改代码，将自定义Layout组件测量子元素使用的约束条件改为完全自定义的约束条件，例如改成一个拥有指定宽度值的约束对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">CustomColumnWithCustomConstraints2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> widthInPx = with(LocalDensity.current) &#123; <span class="number">250.</span>dp.roundToPx() &#125;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = content</span><br><span class="line">    ) &#123; measurables: List&lt;Measurable&gt;, constraints: Constraints -&gt; </span><br><span class="line">        <span class="keyword">val</span> updatedConstraints = Constraints.fixedWidth(widthInPx) </span><br><span class="line">        createCustomColumnLayout(measurables, constraints, updatedConstraints)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里使用了 <code>Constraints.fixedWidth()</code> 来创建约束对象，它的内部源码实现是将 <code>minWidth</code> 和 <code>maxWidth</code> 修改为传入的宽度值，而 <code>minHeight</code> 保持默认值 <code>0</code>， <code>maxHeight</code> 保持默认值 <code>Infinity</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fixedWidth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Constraints &#123;</span><br><span class="line">    require(width &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="string">&quot;width(<span class="variable">$width</span>) must be &gt;= 0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createConstraints(</span><br><span class="line">        minWidth = width,</span><br><span class="line">        maxWidth = width,</span><br><span class="line">        minHeight = <span class="number">0</span>,</span><br><span class="line">        maxHeight = Infinity</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代码跟之前一样，仍然以父组件应用<code>Modifier.wrapContentSize()</code> 的情况进行分析：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8b4420604ee32d930e2da14e6d1cb11d.png" alt="在这里插入图片描述"></p>
<p>跟前面一样进行其他几种情况的应用后发现，结果都类似， 因为子组件的约束信息都使用了固定宽度值来测量，测量结果的宽度总是固定的，无论父组件的约束条件如何。也就是说这种情况下跟父组件没啥关系了，可以通过下图进行对比：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d23f7502e942ccc3bcd8aec5a371f447.png" alt="在这里插入图片描述"></p>
<p>尝试更多的约束修改，效果跟之前对比如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/18369b7930757e5a8b7333385ac05622.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/dbebd340c90a6362bf549346c630473b.png" alt="在这里插入图片描述"></p>
<h4 id="Constraints-中的约束边界-Bounds"><a href="#Constraints-中的约束边界-Bounds" class="headerlink" title="Constraints 中的约束边界 Bounds"></a>Constraints 中的约束边界 Bounds</h4><p>在使用 <strong>Layout</strong> 自定义布局时，用于测量子元素 <code>measurables</code> 的 <code>Constraints</code> 对象决定了子元素的大小，而设置 <code>layout(width, height) &#123; &#125;</code> 方法中的宽度值则会决定 <strong>Layout</strong> 组件在其父组件中的位置和其覆盖范围的大小。</p>
<p>当 <strong>Layout</strong> 组件的宽度不在其所接受的约束条件的 <code>[Constraints.minWidth, Constraints.maxWidth]</code> 范围内时， <strong>Layout</strong> 组件会被放置在<code>-(layout.width-Constraints.maxWidth)/2</code>或<code>-(layout.width-Constraints.minWidth)/2</code> 位置。</p>
<p>下面看几个例子来理解一下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConstraintsExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(<span class="number">8.</span>dp)</span><br><span class="line">            .background(Color(<span class="number">0xffFBE9E7</span>))</span><br><span class="line">            .width(<span class="number">800f</span>.toDp())</span><br><span class="line">            .fillMaxHeight(),</span><br><span class="line">        verticalArrangement = Arrangement.spacedBy(<span class="number">10.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Column宽度是 800px, \n红色child宽度是 900px, \n蓝色child宽度是 700px&quot;</span>) </span><br><span class="line">        Text(<span class="string">&quot;MyLayout的宽度设为父组件的最大宽度\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;MyLayout使用父组件的约束范围：\n[minWidth, maxWidth] = [800, 800] 测量子组件&quot;</span>)</span><br><span class="line">        MyLayout(Modifier.border(<span class="number">3.</span>dp, Green400)) &#123; Content() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">MyLayout</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(constraints) &#125; <span class="comment">// 使用父组件的约束测量child</span></span><br><span class="line">        <span class="keyword">val</span> totalHeight = placeables.sumOf &#123; it.height &#125;</span><br><span class="line">        layout(constraints.maxWidth, totalHeight) &#123; <span class="comment">// 宽度设为父组件的最大宽度</span></span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                y += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Content</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> density = LocalDensity.current</span><br><span class="line">    <span class="keyword">val</span> child1Width = with(density) &#123; <span class="number">900f</span>.toDp() &#125;</span><br><span class="line">    <span class="keyword">val</span> child2Width = with(density) &#123; <span class="number">700f</span>.toDp() &#125;</span><br><span class="line">    BoxWithConstraints(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .shadow(<span class="number">2.</span>dp, RoundedCornerShape(<span class="number">8.</span>dp))</span><br><span class="line">            .width(child1Width)</span><br><span class="line">            .background(Pink400)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Child1: minWidth = <span class="subst">$&#123;constraints.minWidth&#125;</span> &quot;</span> +</span><br><span class="line">                <span class="string">&quot;maxWidth = <span class="subst">$&#123;constraints.maxWidth&#125;</span> \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;minHeight = <span class="subst">$&#123;constraints.minHeight&#125;</span> &quot;</span> +</span><br><span class="line">                <span class="string">&quot;maxHeight = <span class="subst">$&#123;constraints.maxHeight&#125;</span>\n&quot;</span></span><br><span class="line">            , color = Color.White)</span><br><span class="line">    &#125;</span><br><span class="line">    BoxWithConstraints(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .shadow(<span class="number">2.</span>dp, RoundedCornerShape(<span class="number">8.</span>dp))</span><br><span class="line">            .width(child2Width)</span><br><span class="line">            .background(Blue400)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Child2: minWidth = <span class="subst">$&#123;constraints.minWidth&#125;</span> &quot;</span> +</span><br><span class="line">                <span class="string">&quot;maxWidth = <span class="subst">$&#123;constraints.maxWidth&#125;</span> \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;minHeight = <span class="subst">$&#123;constraints.minHeight&#125;</span> &quot;</span> +</span><br><span class="line">                <span class="string">&quot;maxHeight = <span class="subst">$&#123;constraints.maxHeight&#125;</span>\n&quot;</span>,</span><br><span class="line">            color = Color.White)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Preview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(<span class="number">10.</span>dp)</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .verticalScroll(rememberScrollState()),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        ConstraintsExample()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/41707dd12c02fece82212dcee9bf7334.png" alt="在这里插入图片描述"></p>
<p>在上面代码中，</p>
<ul>
<li><code>Column</code>组件的宽度设置为<code>800px</code></li>
<li><code>Column</code>包含的 <code>MyLayout</code> 组件的宽度设置为使用父组件的最大宽度即也是<code>800px</code></li>
<li><code>MyLayout</code> 直接使用父组件的约束信息即<code>[minWidth, maxWidth] = [800, 800]</code>测量子组件。</li>
<li><code>红色Child</code>的宽度设置为<code>900px</code>, 但超出了 <code>MyLayout</code> 的约束范围，所以最终宽度被限制为<code>800px</code>。</li>
<li><code>蓝色Child</code>的宽度设置为<code>700px</code>, 么有超出 <code>MyLayout</code> 的约束范围，所以最终宽度为<code>700px</code>。</li>
</ul>
<p>下面修改一下<code>MyLayout</code>测量子组件的约束范围，改为 <code>[minWidth, maxWidth] = [850, 1000]</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConstraintsExample2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(<span class="number">8.</span>dp)</span><br><span class="line">            .background(Color(<span class="number">0xffFBE9E7</span>))</span><br><span class="line">            .width(<span class="number">800f</span>.toDp())</span><br><span class="line">            .fillMaxHeight(),</span><br><span class="line">        verticalArrangement = Arrangement.spacedBy(<span class="number">10.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Column宽度是 800px, \n红色child宽度是 900px, \n蓝色child宽度是 700px&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;MyLayout的宽度设为父组件的最大宽度\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;MyLayout使用约束范围：\n[minWidth, maxWidth] = [850, 1000] 测量子组件&quot;</span>)</span><br><span class="line">        MyLayout2(Modifier.border(<span class="number">3.</span>dp, Green400)) &#123; Content() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">MyLayout2</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="comment">// Measure with Constraints bigger than parent has.</span></span><br><span class="line">        <span class="keyword">val</span> updatedConstraints = constraints.copy(minWidth = <span class="number">850</span>, maxWidth = <span class="number">1000</span>) <span class="comment">// 使用[850, 1000]测量child</span></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(updatedConstraints) &#125;</span><br><span class="line">        <span class="keyword">val</span> totalHeight = placeables.sumOf &#123; it.height &#125;</span><br><span class="line">        layout(constraints.maxWidth, totalHeight) &#123; <span class="comment">// 宽度设为父组件的最大宽度</span></span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                y += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/405848d4c42462818c5a0da3158fbc88.png" alt="在这里插入图片描述"></p>
<p>在上面代码中，</p>
<ul>
<li><code>Column</code>组件的宽度设置为<code>800px</code></li>
<li><code>Column</code>包含的 <code>MyLayout</code> 组件的宽度设置为使用父组件的最大宽度即也是<code>800px</code></li>
<li><code>MyLayout</code> 使用约束范围<code>[minWidth, maxWidth] = [850, 1000]</code>测量子组件。</li>
<li><code>红色Child</code>的宽度设置为<code>900px</code>, 未超出 <code>MyLayout</code> 的约束范围，所以最终宽度显示为<code>900px</code>。这超过了<code>Column</code>组件的宽度，所以会在<code>Column</code>组件中溢出显示。</li>
<li><code>蓝色Child</code>的宽度设置为<code>700px</code>, 超出了 <code>MyLayout</code> 的约束范围，所以最终宽度使用父约束范围要求的下界即<code>850px</code>。这超过了<code>Column</code>组件的宽度，所以会在<code>Column</code>组件中溢出显示。</li>
</ul>
<p>下面修改<code>MyLayout</code>的宽度为<code>1000</code>，同时测量子组件的约束范围改为 <code>[minWidth, maxWidth] = [850, 1000]</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConstraintsExample3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(<span class="number">8.</span>dp)</span><br><span class="line">            .background(Color(<span class="number">0xffFBE9E7</span>))</span><br><span class="line">            .width(<span class="number">800f</span>.toDp())</span><br><span class="line">            .fillMaxHeight(),</span><br><span class="line">        verticalArrangement = Arrangement.spacedBy(<span class="number">10.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Column宽度是 800px, \n红色child宽度是 900px, \n蓝色child宽度是 700px&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;MyLayout的宽度设为1000\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;MyLayout使用约束范围：\n[minWidth, maxWidth] = [850, 1000] 测量子组件&quot;</span>)</span><br><span class="line">        MyLayout3(Modifier.border(<span class="number">3.</span>dp, Green400)) &#123; Content() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">MyLayout3</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> updatedConstraints = constraints.copy(minWidth = <span class="number">850</span>, maxWidth = <span class="number">1000</span>) <span class="comment">// 使用[850, 1000]测量child</span></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(updatedConstraints) &#125;</span><br><span class="line">        <span class="keyword">val</span> totalHeight = placeables.sumOf &#123; it.height &#125;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 修改这个宽度会改变当前组件在父布局中的位置（在超出父组件约束范围的情况下）</span></span><br><span class="line">        layout(width = <span class="number">1000</span>, height = totalHeight) &#123; <span class="comment">// 宽度设为1000</span></span><br><span class="line">            placeables.forEach &#123; placeable: Placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                y += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2f51efa4e6a2ba8985ba6e8645d4c603.png" alt="在这里插入图片描述"></p>
<p>在上面代码中，</p>
<ul>
<li><code>Column</code>组件的宽度设置为<code>800px</code></li>
<li><code>Column</code>包含的 <code>MyLayout</code> 组件的宽度设置为<code>1000px</code>，这超过了<code>Column</code>组件的宽度，因此 <code>MyLayout</code> 会在<code>Column</code>组件中溢出显示。</li>
<li><code>MyLayout</code> 使用约束范围<code>[minWidth, maxWidth] = [850, 1000]</code>测量子组件。</li>
<li><code>红色Child</code>的宽度设置为<code>900px</code>, 未超出 <code>MyLayout</code> 的约束范围，所以最终宽度显示为<code>900px</code>。这超过了<code>Column</code>组件的宽度，所以会在<code>Column</code>组件中溢出显示。</li>
<li><code>蓝色Child</code>的宽度设置为<code>700px</code>, 超出了 <code>MyLayout</code> 的约束范围，所以最终宽度使用父约束范围要求的下界即<code>850px</code>。这超过了<code>Column</code>组件的宽度，所以会在<code>Column</code>组件中溢出显示。</li>
</ul>
<p>下面的测试代码通过<strong>Slider</strong>组件动态控制相关参数，运行之后可以更直观的了解 <strong>Layout</strong>各个参数之间的相互影响：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConstraintsExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(<span class="number">8.</span>dp)</span><br><span class="line">            .background(Color(<span class="number">0xffFBE9E7</span>))</span><br><span class="line">            .width(<span class="number">800f</span>.toDp())</span><br><span class="line">            .fillMaxHeight(),</span><br><span class="line">        verticalArrangement = Arrangement.spacedBy(<span class="number">10.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Column宽度是 800px&quot;</span>)</span><br><span class="line">        ConstraintsOffsetAndBoundsSample()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ConstraintsOffsetAndBoundsSample</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> minWidth <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">100f</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> maxWidth <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">800f</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> constraintsMinWidth <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">100f</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> constraintsMaxWidth <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">800f</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> layoutWidth <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">800f</span>) &#125;</span><br><span class="line"></span><br><span class="line">    LayoutWidthWidthParams(</span><br><span class="line">        minWidth = minWidth.toInt(),</span><br><span class="line">        maxWidth = maxWidth.toInt(),</span><br><span class="line">        constraintsMinWidth = constraintsMinWidth.toInt(),</span><br><span class="line">        constraintsMaxWidth = constraintsMaxWidth.toInt(),</span><br><span class="line">        layoutWidth = layoutWidth.toInt()</span><br><span class="line">    ) &#123;</span><br><span class="line">        BoxWithConstraints &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;\n Child: minWidth = <span class="subst">$&#123;constraints.minWidth&#125;</span> &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;maxWidth = <span class="subst">$&#123;constraints.maxWidth&#125;</span> \n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;minHeight = <span class="subst">$&#123;constraints.minHeight&#125;</span> &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;maxHeight = <span class="subst">$&#123;constraints.maxHeight&#125;</span>\n&quot;</span>,</span><br><span class="line">                modifier = Modifier</span><br><span class="line">                    .shadow(<span class="number">2.</span>dp, RoundedCornerShape(<span class="number">8.</span>dp))</span><br><span class="line">                    .background(Color.Cyan)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SliderWithLabel(</span><br><span class="line">        label = <span class="string">&quot;Modifier.widthIn min: <span class="subst">$&#123;minWidth.toInt()&#125;</span>&quot;</span>,</span><br><span class="line">        value = minWidth</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &lt;= maxWidth) minWidth = it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SliderWithLabel(</span><br><span class="line">        label = <span class="string">&quot;Modifier.widthIn max: <span class="subst">$&#123;maxWidth.toInt()&#125;</span>&quot;</span>,</span><br><span class="line">        value = maxWidth</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &gt;= minWidth)  maxWidth = it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SliderWithLabel(</span><br><span class="line">        label = <span class="string">&quot;Layout Width: <span class="subst">$&#123;layoutWidth.toInt()&#125;</span>&quot;</span>,</span><br><span class="line">        value = layoutWidth</span><br><span class="line">    ) &#123;</span><br><span class="line">        layoutWidth = it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SliderWithLabel(</span><br><span class="line">        label = <span class="string">&quot;Child constraints.minWidth: <span class="subst">$&#123;constraintsMinWidth.toInt()&#125;</span>&quot;</span>,</span><br><span class="line">        value = constraintsMinWidth</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &lt;= constraintsMaxWidth) constraintsMinWidth = it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SliderWithLabel(</span><br><span class="line">        label = <span class="string">&quot;Child constraints.maxWidth: <span class="subst">$&#123;constraintsMaxWidth.toInt()&#125;</span>&quot;</span>,</span><br><span class="line">        value = constraintsMaxWidth</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &gt;= constraintsMinWidth) constraintsMaxWidth = it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">LayoutWidthWidthParams</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    minWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    maxWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    constraintsMinWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    constraintsMaxWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    layoutWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> density = LocalDensity.current</span><br><span class="line">    <span class="keyword">val</span> minWidthDp = density.run &#123; minWidth.toDp() &#125;</span><br><span class="line">    <span class="keyword">val</span> maxWidthDp = density.run &#123; maxWidth.toDp() &#125;</span><br><span class="line"></span><br><span class="line">    Layout(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .widthIn(min = minWidthDp, max = maxWidthDp)</span><br><span class="line">            .border(<span class="number">3.</span>dp, Green400),</span><br><span class="line">        content = content</span><br><span class="line">    ) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> updatedConstraints = constraints.copy(</span><br><span class="line">            minWidth = constraintsMinWidth,</span><br><span class="line">            maxWidth = constraintsMaxWidth</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(updatedConstraints) &#125;</span><br><span class="line">        <span class="keyword">val</span> totalHeight = placeables.sumOf &#123; it.height &#125;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 修改这个宽度会改变当前组件在父布局中的位置（在超出父组件约束范围的情况下）</span></span><br><span class="line">        layout(width = layoutWidth, height = totalHeight) &#123;</span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                y += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SliderWithLabel</span><span class="params">(label: <span class="type">String</span>, value: <span class="type">Float</span>, onValueChange: (<span class="type">Float</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(label)</span><br><span class="line">        Slider(</span><br><span class="line">            value = value,</span><br><span class="line">            onValueChange = onValueChange,</span><br><span class="line">            valueRange = <span class="number">0f</span>.<span class="number">.1000f</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConstraintsExamplePreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ForPreviewUse &#123; ConstraintsExample5() &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(<span class="number">10.</span>dp)</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .verticalScroll(rememberScrollState()),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        ConstraintsExample()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里自定义的 <strong>Layout</strong> 组件上使用了 <code>Modifier.widthIn(min, max)</code> 修饰符，这个修饰符的作用是：根据输入的测量约束，将内容的宽度限制在<code>[min, max]</code>的<code>dp</code>值范围之间，如果输入的约束更严格，则请求的大小将服从传入约束，并试图尽可能接近首选大小。一句话就是<strong>它可以在父约束范围内做一定的修改，但不能违背父约束</strong>。</p>
<p>我们运行上面的代码，改变 <strong>Layout</strong> 的 <code>layout(width, height)</code> 方法的 <code>width</code> 参数，查看效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f46c3b1d6d408ef24575372afa5d9ebd.gif" alt="在这里插入图片描述"></p>
<p>可以看到当拖动<code>Slider</code>改变<code>Layout</code>的<code>width</code>时，正如开头所提到的，如果超过了其所受约束边界范围<code>[minWidth, maxWidth]</code>，<code>Layout</code>在其父布局中的位置就会发生改变。具体发生的偏移量为 <code>-(layout.width-Constraints.maxWidth)/2</code>或<code>-(layout.width-Constraints.minWidth)/2</code> ，可以通过为<code>Layout</code>添加<code>Modifier.onPlaced</code>修饰符来打印日志观察：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layout(</span><br><span class="line">   modifier = Modifier</span><br><span class="line">       .widthIn(min = minWidthDp, max = maxWidthDp)</span><br><span class="line">       .border(<span class="number">3.</span>dp, Green400)</span><br><span class="line">       .onPlaced &#123; layoutCoordinates -&gt;</span><br><span class="line">           <span class="keyword">val</span> posInParent = layoutCoordinates.positionInParent()</span><br><span class="line">           <span class="keyword">val</span> size = layoutCoordinates.size</span><br><span class="line">           println(<span class="string">&quot;Layout&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;posInParent: <span class="variable">$posInParent</span>&quot;</span>)</span><br><span class="line">           println(<span class="string">&quot;Layout&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;size: <span class="variable">$size</span>&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   ,</span><br><span class="line">   content = content</span><br><span class="line">) &#123; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外当拖动<code>Slider</code>改变<code>Layout</code>的Child的约束条件时，只会影响Child的大小：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e355c3178342caf39a40fb69d3ea0b24.gif" alt="在这里插入图片描述"></p>
<h4 id="偏移量约束-Constraints-offset-和-宽高约束-Constraints-constrainWidth-Height"><a href="#偏移量约束-Constraints-offset-和-宽高约束-Constraints-constrainWidth-Height" class="headerlink" title="偏移量约束 Constraints.offset() 和 宽高约束 Constraints.constrainWidth&#x2F;Height()"></a>偏移量约束 Constraints.offset() 和 宽高约束 Constraints.constrainWidth&#x2F;Height()</h4><p>在前面使用 <code>Modifier.layout()</code> 自定义布局部分中，实现聊天对话框消息气泡的例子里，使用到了两个<code>Constraints</code>对象的方法：<code>Constraints.offset()</code> 和 <code>Constraints.constrainWidth()/constrainHeight()</code> ，这两个方法的作用是使用约束对象对偏移量和指定的宽高进行约束。</p>
<p>先看一下这两个方法分别会返回什么</p>
<p>对于 <code>constraints.offset(offsetX, offsetY)</code> 其实就是将最大最小的宽高值分别加上对应方向的偏移量，然后返回一个新的 <code>Constraints</code>对象：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/69661eb35978346dadc8aebbe390436b.png" alt="在这里插入图片描述"></p>
<p>而对于 <code>Constraints.constrainWidth(width)</code> 或 <code>Constraints.constrainHeight(height)</code> 则会根据当前约束对象的最大最小宽高值判断输入的<code>width</code>或<code>height</code>是否在上下界范围内，如果在范围内就返回输入的值，如果低于下界就返回下界值，如果高于上界就返回上界值：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4dd22f7fd05c4c39236ce19f9b539bac.png" alt="在这里插入图片描述"></p>
<p>为什么要关注这两个方法呢？因为这两个方法在需要设置独立于内容区域之外的额外边距时非常有用。</p>
<p>先看一个简单的例子，比如系统内置的 <code>Modifier.padding()</code> 修饰符就使用了这两个约束方法，我们看一下其源码实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">padding</span><span class="params">(all: <span class="type">Dp</span>)</span></span> =</span><br><span class="line">    <span class="keyword">this</span>.then(</span><br><span class="line">        PaddingModifier(</span><br><span class="line">            start = all,</span><br><span class="line">            top = all,</span><br><span class="line">            end = all,</span><br><span class="line">            bottom = all,</span><br><span class="line">            rtlAware = <span class="literal">true</span>,</span><br><span class="line">            inspectorInfo = debugInspectorInfo &#123;</span><br><span class="line">                name = <span class="string">&quot;padding&quot;</span></span><br><span class="line">                value = all</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingModifier</span>(</span><br><span class="line">    <span class="keyword">val</span> start: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> top: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> end: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> bottom: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> rtlAware: <span class="built_in">Boolean</span>,</span><br><span class="line">    inspectorInfo: InspectorInfo.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : LayoutModifier, InspectorValueInfo(inspectorInfo) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints.offset(-horizontal, -vertical))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + vertical)</span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rtlAware) &#123;</span><br><span class="line">                placeable.placeRelative(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                placeable.place(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到内部返回了一个 <code>PaddingModifier</code> 对象，该对象实现了 <code>LayoutModifier</code> 接口，因此其使用方式和 <code>Modifier.layout()</code> 类似，也需要覆写 <code>MeasureScope.measure()</code> 方法，在 <code>measure()</code>方法中我们看到 <code>measurable.measure()</code> 中传入的约束对象是 <code>constraints.offset(-horizontal, -vertical)</code>，并且它调用 <code>layout(width, height)</code> 方法传入的宽高值使用了 <code>Constraints.constrainWidth()</code> 和 <code>Constraints.constrainHeight()</code> 进行约束。</p>
<p>但是为什么要这么写呢？如果不使用这两个方法会发生什么？例如我们可以在不使用这两个约束方法的前提下自己实现一个简单的<code>padding</code>功能，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myPadding</span><span class="params">(all: <span class="type">Dp</span>)</span></span> = then(</span><br><span class="line">    PaddingModifier(start = all, top = all, end = all, bottom = all, rtlAware = <span class="literal">true</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingModifier</span>(</span><br><span class="line">    <span class="keyword">val</span> start: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> top: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> end: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> bottom: Dp = <span class="number">0.</span>dp,</span><br><span class="line">    <span class="keyword">val</span> rtlAware: <span class="built_in">Boolean</span>,</span><br><span class="line">) : LayoutModifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(measurable: <span class="type">Measurable</span>, constraints: <span class="type">Constraints</span>)</span></span>: MeasureResult &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> width = (placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = (placeable.height + vertical) </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rtlAware) &#123;</span><br><span class="line">                placeable.placeRelative(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                placeable.place(start.roundToPx(), top.roundToPx())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现非常简单，就是将设置的<code>padding</code>值附加到子元素测量结果的宽高值之上，再作为自身的宽高来应用。</p>
<p>使用测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConstraintOffsetAndWidthExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        Column(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .padding(vertical = <span class="number">4.</span>dp)</span><br><span class="line">                .width(<span class="number">300.</span>dp)</span><br><span class="line">                .fillMaxHeight()</span><br><span class="line">                .background(Color(<span class="number">0xffFBE9E7</span>)),</span><br><span class="line">            horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">            verticalArrangement = Arrangement.Center</span><br><span class="line">        ) &#123;</span><br><span class="line">            Text(<span class="string">&quot;系统内置的 Modifier.padding(15.dp) 效果：&quot;</span>)</span><br><span class="line">            Spacer(modifier = Modifier.height(<span class="number">10.</span>dp))</span><br><span class="line">            Column(</span><br><span class="line">                Modifier</span><br><span class="line">                    .background(Color(<span class="number">0xffFF9800</span>))</span><br><span class="line">                    .padding(<span class="number">15.</span>dp)</span><br><span class="line">            ) &#123;</span><br><span class="line">                MyText(<span class="string">&quot;aaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            Spacer(modifier = Modifier.height(<span class="number">20.</span>dp))</span><br><span class="line">            Text(<span class="string">&quot;自定义的 Modifier.myPadding(15.dp) 效果：&quot;</span>)</span><br><span class="line">            Spacer(modifier = Modifier.height(<span class="number">10.</span>dp))</span><br><span class="line">            Column(</span><br><span class="line">                Modifier</span><br><span class="line">                    .background(Color(<span class="number">0xffFF9800</span>))</span><br><span class="line">                    .myPadding(<span class="number">15.</span>dp)</span><br><span class="line">            ) &#123;</span><br><span class="line">                MyText(<span class="string">&quot;aaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyText</span><span class="params">(text: <span class="type">String</span>)</span></span> = Text(text, Modifier.background(Color(<span class="number">0xff2196F3</span>)), Color.White)</span><br></pre></td></tr></table></figure>

<p>运行上面代码之后发现，如果在在文本比较短的情况下是没有问题的，跟系统内置的padding修饰符几乎没有区别，但是如果在文本比较长的情况下就发现问题了，我们自定义的padding修饰符的padding部分会溢出父布局，而系统内置的则不会：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b9591556fca9ab4f0709342a98c8c8d6.png" alt="在这里插入图片描述"><br>（注：上图中橙色部分表示padding区域，padding应用在Column组件上，蓝色部分表示Text文本）</p>
<p>因此我们需要对自己的组件的最大宽度和高度进行限制，在应用<code>padding</code>的情况下也要保证不会超出<strong>父布局</strong>的范围，因此就需要使用<strong>父布局</strong>的<code>Constraints</code>对象的 <code>constrainWidth()</code> 和 <code>constrainHeight()</code> 方法对当前组件的宽高进行约束，使用约束之后的宽高进行布局，修改核心代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingModifier</span>(...) : LayoutModifier &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(measurable: <span class="type">Measurable</span>, constraints: <span class="type">Constraints</span>)</span></span>: MeasureResult &#123;</span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">        <span class="comment">//  val width = (placeable.width + horizontal)</span></span><br><span class="line">        <span class="comment">//  val height = (placeable.height + vertical)</span></span><br><span class="line">        <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + vertical)</span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是仅仅这样是不够的，因为运行之后你会发现，虽然文本很长的情况下，<code>padding</code>部分不会超出父布局了，但是内部的<code>Text</code>组件仍然会溢出<code>Column</code>的父布局：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/31920ee3d0b83fe210f9ec7eb29eb589.png" alt="在这里插入图片描述"><br>这是因为我们直接使用了父布局的约束对象对<code>Text</code>组件进行了测量，测量结果的宽度可能是跟父布局的最大宽度相等（在上面的测试代码中是<code>300.dp</code>），然后应用<code>padding</code>修饰符的<code>Column</code>在摆放<code>Text</code>组件时，是从起始位置向右偏移<code>15.dp</code>的位置开始摆放的，所以<code>Text</code>组件的最终表现就是从 <code>15.dp</code> 的地方开始显示<code>300.dp</code>的长度，总共是<code>315dp</code>, 肯定超出父布局了。所以应该保证测量<code>Text</code>用的约束条件中的最大最小宽度排除<code>padding</code>区域的大小，剩余的部分才用来真正的显示内容，这就是该使用 <code>constraints.offset()</code> 的时刻了。修改核心代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingModifier</span>(...) : LayoutModifier &#123; </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(measurable: <span class="type">Measurable</span>, constraints: <span class="type">Constraints</span>)</span></span>: MeasureResult &#123; </span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx() </span><br><span class="line">        <span class="comment">// val placeable = measurable.measure(constraints) </span></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints.offset(-horizontal, -vertical)) </span><br><span class="line">        <span class="comment">// val width = (placeable.width + horizontal)</span></span><br><span class="line">        <span class="comment">// val height = (placeable.height + vertical) </span></span><br><span class="line">        <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + vertical) </span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中 <code>constraints.offset(-horizontal, -vertical)</code>，传入的都是对应方向上<code>padding</code>总和的负值，这是因为我们要减去它们，正如上面分析的那样。</p>
<p>现在运行代码，效果就和系统的一模一样了：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/84800f77912fb5271c4bb02b266bb6d6.png" alt="在这里插入图片描述"></p>
<p>但是好像还有一种情况没有分析，那就是我们可以只使用<code>constraints.offset()</code>对偏移量进行约束，但是不对当前组件的宽高进行约束，因为子元素使用经过偏移量修正后的约束进行测量之后，得到宽度和高度一定不会超过父布局的宽高，因此如果我们把代码修改成下面这样，运行之后发现也是可以的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PaddingModifier</span>(...) : LayoutModifier &#123; </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(measurable: <span class="type">Measurable</span>, constraints: <span class="type">Constraints</span>)</span></span>: MeasureResult &#123; </span><br><span class="line">        <span class="keyword">val</span> horizontal = start.roundToPx() + end.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> vertical = top.roundToPx() + bottom.roundToPx()  </span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints.offset(-horizontal, -vertical)) </span><br><span class="line">        <span class="keyword">val</span> width = (placeable.width + horizontal)</span><br><span class="line">        <span class="keyword">val</span> height = (placeable.height + vertical) </span><br><span class="line">        <span class="comment">// val width = constraints.constrainWidth(placeable.width + horizontal)</span></span><br><span class="line">        <span class="comment">// val height = constraints.constrainHeight(placeable.height + vertical) </span></span><br><span class="line">        <span class="keyword">return</span> layout(width, height) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样可行，但是存在一种极端的情况，就是我们的<code>padding</code>值设置的极大，甚至比父布局的最大宽度还要大，此时依然会发生溢出。但这种情况是非常极端的，正常人肯定不会在一个<code>300dp</code>的组件内设置一个<code>400dp</code>的内边距。。。即便如此，还是把<code>constrainWidth()</code> 和 <code>constrainHeight()</code> 这两个都加上才是最完美的，这样在任何情况下都不会出现溢出，就像系统的 <code>Modifier.padding()</code> 那样。</p>
<p>现在再来回顾一下前面实现聊天对话框消息气泡的例子里的核心代码，就比较容易理解了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Modifier.then(shapeModifier)</span><br><span class="line">   .background(color, shape)</span><br><span class="line">   .layout &#123; measurable, constraints -&gt;</span><br><span class="line">       <span class="keyword">val</span> isHorizontalArrow =</span><br><span class="line">           arrowDirection == ArrowDirection.Left || arrowDirection == ArrowDirection.Right</span><br><span class="line">       <span class="keyword">val</span> isVerticalArrow =</span><br><span class="line">           arrowDirection == ArrowDirection.Top || arrowDirection == ArrowDirection.Bottom</span><br><span class="line">       <span class="comment">// 箭头偏移量</span></span><br><span class="line">       <span class="keyword">val</span> offsetX = <span class="keyword">if</span> (isHorizontalArrow) arrowWidthPx.toInt() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">       <span class="keyword">val</span> offsetY = <span class="keyword">if</span> (isVerticalArrow) arrowHeightPx.toInt() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 测量文本 先将约束信息的最大最小宽高值减去箭头的偏移量，再用来测量子元素</span></span><br><span class="line">       <span class="keyword">val</span> placeable = measurable.measure(</span><br><span class="line">           constraints.offset(horizontal = -offsetX, vertical = -offsetY)</span><br><span class="line">       ) </span><br><span class="line">       <span class="comment">// 对总宽度和总高度进行约束，保证不会溢出父布局</span></span><br><span class="line">       <span class="keyword">val</span> width = constraints.constrainWidth(placeable.width + offsetX)</span><br><span class="line">       <span class="keyword">val</span> height = constraints.constrainHeight(placeable.height + offsetY)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> posX = <span class="keyword">when</span> (arrowDirection) &#123;</span><br><span class="line">           ArrowDirection.Left -&gt; arrowWidthPx.toInt()</span><br><span class="line">           <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">val</span> posY = <span class="keyword">when</span> (arrowDirection) &#123;</span><br><span class="line">           ArrowDirection.Top -&gt; arrowHeightPx.toInt()</span><br><span class="line">           <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">       &#125;</span><br><span class="line">       layout(width, height) &#123;</span><br><span class="line">           placeable.placeRelative(posX, posY) <span class="comment">// 摆放文本</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/93ac17287924e1e4f2d335b1212c0ced.png" alt="在这里插入图片描述"></p>
<p>这里可以将气泡的箭头区域大小看成是上面padding修饰符的例子中的一种预留的padding，这样分析起来几乎和前面padding修饰符的例子是一模一样的思想。</p>
<h3 id="Intrinsic-固有特性测量"><a href="#Intrinsic-固有特性测量" class="headerlink" title="Intrinsic 固有特性测量"></a>Intrinsic 固有特性测量</h3><p>前面提到在Compose 中的每个 UI 组件是不允许多次进行测量的，多次测量在运行时会抛异常，禁止多次测量的好处是为了提高性能，但在很多场景中，多次测量子 UI 组件也可能是有意义的。例如，假设存在下面这样一个需求场景，我们希望两个文本中间的分割线高度与两边文案高的一边保持相等。如下图所示：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6c535621f7eaf7ee96233bb6d6ec641b.png" alt="在这里插入图片描述"><br>为了实现这个需求，我们可以直接使用一个 Row 组件来写出如下代码，但是并不能达到我们所要的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TwoTexts</span><span class="params">(text1: <span class="type">String</span>, text2: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Row(modifier = modifier) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>).padding(start = <span class="number">4.</span>dp).wrapContentWidth(Alignment.Start),</span><br><span class="line">            text = text1</span><br><span class="line">        )</span><br><span class="line">        Divider(color = Color.Black, modifier = Modifier.fillMaxHeight().width(<span class="number">1.</span>dp))</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>).padding(end = <span class="number">4.</span>dp).wrapContentWidth(Alignment.End),</span><br><span class="line">            text = text2</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TwoTextsPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        Surface &#123;</span><br><span class="line">            TwoTexts(text1 = <span class="string">&quot;Hi&quot;</span>, text2 = <span class="string">&quot;there&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b1e2e3fc4e125aa31511c6b7b76002a4.png" alt="在这里插入图片描述"><br>之所以出现这种情况，是因为 Row 会逐个测量每个子项，并且 Text 的高度不能用于限制 Divider。</p>
<p>假设父组件可以预先获取到两边的文案组件高度信息，然后计算两边高度的最大值即可确定当前父组件的高度值，此时仅需将分割线高度值铺满整个父组件即可完美解决问题。</p>
<p>为了应对父组件需要预先获取子组件宽高信息来确定自身大小的这种场景，Compose 为开发者提供了一种特殊的固有特性测量机制，允许开发者在每个子组件正式测量前能获取到每个子组件的宽高等信息。总而言之一句话：<strong>借助固有特性测量，可以突破禁止多次测量的限制，预先查询子项，然后再进行实际测量。</strong></p>
<h4 id="在内置组件上应用固有特性测量"><a href="#在内置组件上应用固有特性测量" class="headerlink" title="在内置组件上应用固有特性测量"></a>在内置组件上应用固有特性测量</h4><p>使用固有特性测量的前提是组件需要适配固有特性测量，目前许多内置的基础组件已经完成对固有特性测量的适配，可以直接使用。</p>
<p>在上面所提到的例子中，父组件所提供的能力使用基础组件中的 <strong>Row</strong> 组件即可承担，我们仅需为 <strong>Row</strong> 组件的高度设置固有特性测量即可。我们使用 <code>Modifier.height(IntrinsicSize.Min)</code> 即可为高度设置固有特性测量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TwoTexts</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, text1: <span class="type">String</span>, text2: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Row(modifier = modifier.height(IntrinsicSize.Min)) &#123; <span class="comment">// I&#x27;m here</span></span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>).padding(start = <span class="number">4.</span>dp).wrapContentWidth(Alignment.Start),</span><br><span class="line">            text = text1</span><br><span class="line">        )</span><br><span class="line">        Divider(color = Color.Black, modifier = Modifier.fillMaxHeight().width(<span class="number">1.</span>dp))</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>).padding(end = <span class="number">4.</span>dp).wrapContentWidth(Alignment.End),</span><br><span class="line">            text = text2</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TwoTextsPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box() &#123;</span><br><span class="line">        TwoTexts(text1 = <span class="string">&quot;Hi&quot;</span>, text2 = <span class="string">&quot;there&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/26a019e5887b6c5c550c4df51911be7c.png" alt="在这里插入图片描述"></p>
<p>上面仅使用 <code>Modifier.height(IntrinsicSize.Min)</code> 为高度设置了固有特性测量，并没有对宽度进行设置。此时所表达的意思是：当宽度不限时，通过子组件预先测量的宽高信息所能计算的高度最少可以是多少。当然你也可以进行宽度的设置，当宽度受限时，通过子组件预先测量的宽高信息所能计算的高度最少可以是多少。</p>
<p>可能你不能理解宽度受限可能影响高度这件事，其实我们常用的 Text 组件当宽度收到不同限制时，其高度就是不一样的。例如：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f8a543683bd1a484f6610f3704ecaa6e.png" alt="在这里插入图片描述"></p>
<p>上面例子中使用的固有特性测量是 <code>IntrinsicSize.Min</code>，对应的还有一个 <code>IntrinsicSize.Max</code>，那么二者有什么区别呢？ 可以通过下面的例子来了解二者的区别：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicMinMaxExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(Modifier.width(IntrinsicSize.Max)) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;Refresh&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Settings&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Send Feedback&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Help&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Sign out&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/15985be9fc448f1b62f41aec1d6a4a07.png" alt="在这里插入图片描述"></p>
<p>可以看到，对 <strong>Column</strong> 组件应用 <code>Modifier.width(IntrinsicSize.Max)</code> 后，它选择了能让所有 <strong>Text</strong> 组件都能完整显示的宽度中的<strong>最大值</strong>来作为自身的宽度。</p>
<p>如果设置为 <code>IntrinsicSize.Min</code> 会是什么效果呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicMinMaxExample2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(Modifier.width(IntrinsicSize.Min)) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;Refresh&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Settings&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Send Feedback&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Help&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;Sign out&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/37d08afa3a0539a496ac3b177f8ec120.png" alt="在这里插入图片描述"></p>
<p>可以看到，对 <strong>Column</strong> 组件应用 <code>Modifier.width(IntrinsicSize.Min)</code> 后，<strong>Column</strong> 组件会查询一遍所有子组件，选择能让所有 <strong>Text</strong> 组件都能完整显示的宽度中的<strong>最小值</strong>来作为自身的宽度。</p>
<p>假如把上面的代码中的文本换成中文，效果会更明显：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicMinMaxExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(Modifier.width(IntrinsicSize.Min)) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;刷新&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;设置&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;发送反馈&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;帮助&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">        Text(text = <span class="string">&quot;退出&quot;</span>, Modifier.fillMaxWidth())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b63e072ac5a0bc192b1c797ce496c920.png" alt="在这里插入图片描述"></p>
<p>可以看到Column选择了最少显示一个汉字的宽度来设置自身的宽度。</p>
<blockquote>
<p>注意： 你只能对<strong>已经适配固有特性测量的内置组件</strong>使用 <code>IntrinsicSize.Min</code> 或 <code>IntrinsicSize.Max</code> ，否则程序会运行崩溃。对于所有<strong>自定义 Layout</strong> 的开发者来说，如果打算支持使用固有特性测量，则必须要进行固有特性测量的适配工作。</p>
</blockquote>
<h4 id="自定义固有特性测量"><a href="#自定义固有特性测量" class="headerlink" title="自定义固有特性测量"></a>自定义固有特性测量</h4><p>其实，绝大多数的内置组件都是用前面提到的 <strong>Layout</strong> 组件来实现的， 前面提到 <strong>Layout</strong> 组件中需要传入一个 <code>measurePolicy</code> , 默认只需实现其 <code>measure()</code> 方法，但是如果要实现固有特性测量，就需要额外重写 <code>Intrinsic</code> 系列方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> </span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fee67dd80558f46bfcc70d52143f8f59.png" alt="在这里插入图片描述"></p>
<ul>
<li>当组件使用 <code>Modifier.width(IntrinsicSize.Max)</code> 时，则会调用 <code>maxIntrinsicWidth</code> 方法</li>
<li>当组件使用 <code>Modifier.width(IntrinsicSize.Min)</code> 时，则会调用 <code>minIntrinsicWidth</code> 方法</li>
<li>当组件使用 <code>Modifier.height(IntrinsicSize.Max)</code> 时，则会调用 <code>maxIntrinsicHeight</code> 方法</li>
<li>当组件使用 <code>Modifier.height(IntrinsicSize.Min)</code> 时，则会调用 <code>minIntrinsicHeight</code> 方法</li>
</ul>
<p>注意： 如果组件的 <code>Modifier</code> 使用了上面某一个, 但其对应方法在 <strong>Layout</strong> 组件中没有重写仍会导致崩溃。</p>
<p>在 Layout 声明时，我们就不能使用 SAM 形式了，而是要规规矩矩实现 <code>MeasurePolicy</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyCustomComposable</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(content = content, modifier = modifier, measurePolicy = <span class="keyword">object</span>: MeasurePolicy &#123; </span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                measurables: <span class="type">List</span>&lt;<span class="type">Measurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">                constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>: MeasureResult &#123;</span><br><span class="line">                <span class="comment">// Measure and layout here</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicHeight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">                width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">                <span class="comment">// Logic here</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 其他 intrinsics 相关方法都有默认值  </span></span><br><span class="line">            <span class="comment">// 你可以选择只实现你所需要的方法，而不是实现所有方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    ) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面自定义一个 <strong>IntrinsicRow</strong> 组件来实现前面分割线对齐文本的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicRow</span><span class="params">(modifier: <span class="type">Modifier</span>, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    Layout(content = content, modifier = modifier, measurePolicy = <span class="keyword">object</span>: MeasurePolicy &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                measurables: <span class="type">List</span>&lt;<span class="type">Measurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">                constraints: <span class="type">Constraints</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>: MeasureResult &#123;</span><br><span class="line">                <span class="keyword">val</span> textPlaceables = measurables</span><br><span class="line">                    .filter &#123; it.layoutId == <span class="string">&quot;text&quot;</span> &#125;.map &#123; it.measure(constraints) &#125;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">val</span> dividerPlaceable = measurables</span><br><span class="line">                    .first &#123; it.layoutId == <span class="string">&quot;divider&quot;</span>&#125;.measure(constraints)</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">val</span> midPos = constraints.maxWidth / <span class="number">2</span></span><br><span class="line">                <span class="keyword">return</span> layout(constraints.maxWidth, constraints.maxHeight) &#123;</span><br><span class="line">                    textPlaceables.forEach &#123; it.placeRelative(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">                    dividerPlaceable.placeRelative(midPos, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicHeight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">                width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">                <span class="comment">// 计算所有子组件中的最大固有高度值来作为Layout自身的最小固有高度</span></span><br><span class="line">                measurables.forEach &#123;</span><br><span class="line">                    maxHeight = it.maxIntrinsicHeight(width).coerceAtLeast(maxHeight)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> maxHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicRowPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box() &#123;</span><br><span class="line">        IntrinsicRow(Modifier.fillMaxWidth().height(IntrinsicSize.Min)) &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Left&quot;</span>,</span><br><span class="line">                Modifier.wrapContentWidth(Alignment.Start).layoutId(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            Divider(</span><br><span class="line">                color = Color.Black,</span><br><span class="line">                modifier = Modifier.width(<span class="number">4.</span>dp).fillMaxHeight().layoutId(<span class="string">&quot;divider&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Right&quot;</span>,</span><br><span class="line">                Modifier.wrapContentWidth(Alignment.End).layoutId(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的案例中仅使用了 <code>Modifier.height(IntrinsicSize.Min)</code> ，出于简单考虑仅重写了 <code>minIntrinsicHeight</code> 以作示例。</p>
<p><code>minIntrinsicHeight</code> 与 <code>maxIntrinsicHeight</code> 有相同的两个参数 <code>measurables</code> 与 <code>width</code>：</p>
<ul>
<li><code>measurables</code> 类似于 <code>measure</code> 方法的 <code>measurables</code>，用于获取子组件的宽高信息。</li>
<li><code>width</code>：父组件所能提供的最大宽度（无论此时是 <code>minIntrinsicHeight</code> 还是 <code>maxIntrinsicHeight</code> ）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier</span><br><span class="line">    .widthIn(<span class="number">100.</span>dp, <span class="number">200.</span>dp) <span class="comment">// 在此场景下 minIntrinsicHeight 的参数 width 值为 200.dp 对应的 px</span></span><br><span class="line">    .height(IntrinsicSize.Max)</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e73ec298cd8084e37fc09ab897bd098f.png" alt="在这里插入图片描述"></p>
<p>出现这种效果的原因是：由于在 <strong>IntrinsicRow</strong> 上使用了 <code>Modifier.fillMaxWidth()</code>，导致我们自定义 <code>Layout</code> 的宽度是固定的（即<code>measure</code>方法的 <code>constraints</code> 参数中的最大最小宽度值相等 <code>minWidth == maxWidth</code> ），又因为我们使用了固有特性测量，导致组件的高度也是固定的（<code>constraints</code> 参数中 <code>minHeight == maxHeight</code> ）。如果在<code>measure</code>方法中直接使用该 <code>constraints</code> 去测量 <strong>Divider</strong> ，就会导致 <strong>Divider</strong> 的宽度也被设置为父组件的宽度。</p>
<p>而我们希望 <strong>Divider</strong> 测量的<strong>宽度</strong>不应与父组件相同，而是要根据其自身声明的宽度，也就是 <code>Modifier.width(4.dp)</code> ，所以我们需要对 <strong>Divider</strong> 测量使用的 <code>constraints</code> 进行修正，将其最小宽度值<code>minWidth</code> 设置为 <code>0</code>, 这样宽度范围变成 <code>[0, maxWidth]</code> 就不会作为一个确定的值影响 <strong>Divider</strong> 的测量结果。因为 <code>constraints</code> 的高度是确定的，这会使 <strong>Divider</strong> 的高度被强制指定为该确定值。</p>
<p>最终的实现代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicRow</span><span class="params">(modifier: <span class="type">Modifier</span>, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    Layout(content = content, modifier = modifier, measurePolicy = <span class="keyword">object</span>: MeasurePolicy &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                measurables: <span class="type">List</span>&lt;<span class="type">Measurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">                constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>: MeasureResult &#123;</span><br><span class="line">                <span class="keyword">val</span> textPlaceables = measurables</span><br><span class="line">                    .filter &#123; it.layoutId == <span class="string">&quot;text&quot;</span> &#125;.map &#123; it.measure(constraints) &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修正：将约束的最小宽度值设为 0，宽度范围变成 [0, maxWidth]</span></span><br><span class="line">                <span class="keyword">val</span> dividerConstraints = constraints.copy(minWidth = <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">val</span> dividerPlaceable = measurables</span><br><span class="line">                    .first &#123; it.layoutId == <span class="string">&quot;divider&quot;</span>&#125;.measure(dividerConstraints)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> midPos = constraints.maxWidth / <span class="number">2</span></span><br><span class="line">                <span class="keyword">return</span> layout(constraints.maxWidth, constraints.maxHeight) &#123;</span><br><span class="line">                    textPlaceables.forEach &#123; it.placeRelative(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">                    dividerPlaceable.placeRelative(midPos, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicHeight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">                width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">            )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">                <span class="comment">// 计算所有子组件中的最大固有高度值来作为Layout自身的最小固有高度</span></span><br><span class="line">                measurables.forEach &#123;</span><br><span class="line">                    maxHeight = it.maxIntrinsicHeight(width).coerceAtLeast(maxHeight)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> maxHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">IntrinsicRowPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box() &#123;</span><br><span class="line">        IntrinsicRow(Modifier.fillMaxWidth().height(IntrinsicSize.Min)) &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Left&quot;</span>,</span><br><span class="line">                Modifier.wrapContentWidth(Alignment.Start).layoutId(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            Divider(</span><br><span class="line">                color = Color.Black,</span><br><span class="line">                modifier = Modifier.width(<span class="number">4.</span>dp).fillMaxHeight().layoutId(<span class="string">&quot;divider&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Right&quot;</span>,</span><br><span class="line">                Modifier.wrapContentWidth(Alignment.End).layoutId(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/868175e50dd2eb71cf3f915aa8ea5c48.png" alt="在这里插入图片描述"></p>
<p>如果两侧的文案高度不同，则分割线会跟最高的那一侧文案对齐，效果如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a8776b4f2d340e0ecaa201efb599ab78.png" alt="在这里插入图片描述"></p>
<h4 id="Intrinsic-小结"><a href="#Intrinsic-小结" class="headerlink" title="Intrinsic 小结"></a>Intrinsic 小结</h4><p>固有特性测量的本质就是 <strong>允许父组件预先获取到每个子组件的宽高信息后，影响自身在测量阶段获取到的 <code>constraints</code> 参数的宽高信息，从而间接的控制和影响对子组件的测量。</strong></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ee31d5df075a950d7f3a492f35cb4a67.png" alt="在这里插入图片描述"></p>
<p>在上面例子中，就是通过预先测量 <strong>Text</strong> 组件的高度，从而确定了父组件在测量时 <code>constraints</code> 的高度信息，变为固定高度，从而间接确定了分割线的高度。</p>
<p>在使用上：</p>
<ul>
<li>如果是内置组件，根据需要直接在 <code>width/height</code> 修饰符上应用 <code>IntrinsicSize.Min</code> 或者 <code>IntrinsicSize.Max</code></li>
<li>如果是自定义 <strong>Layout</strong> 组件，根据需要选择重写 <code>measurePolicy</code> 的 <code>maxIntrinsicWidth/height</code> 或 <code>minIntrinsicWidth/height</code> 方法，在使用自定义的组件时，同样是在修饰符上应用 <code>IntrinsicSize.Min</code> 或者 <code>IntrinsicSize.Max</code>。</li>
</ul>
<h3 id="SubcomposeLayout-的超能力"><a href="#SubcomposeLayout-的超能力" class="headerlink" title="SubcomposeLayout 的超能力"></a>SubcomposeLayout 的超能力</h3><p>如果说 <strong>Intrinsic</strong> 的超能力是可以<strong>预先感知子组件的宽高信息</strong>，那么 <strong>SubcomposeLayout</strong> 的超能力就是：可以允许我们 <strong>将某个子组件的合成过程延迟至其所依赖的同级组件测量之后进行</strong>，它为我们提供了更强的测量定制能力。而它的这个能力也说明了这个组件可以根据其他组件的测量结果来确定自身的尺寸，因此它可以用来取代固有特性测量。</p>
<p>我们仍然使用前面固有特性测量中分割线对齐两侧文本的例子，看看使用 <strong>SubcomposeLayout</strong> 该如何实现。</p>
<p>使用 <strong>SubcomposeLayout</strong> 可以允许组件根据定制测量顺序直接相互作用影响，与固有特性测量具有本质的区别，在这整个过程中父组件是没有参与的。</p>
<p>看一下 SubcomposeLayout 组件的声明：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">SubcomposeMeasureScope</span>.(<span class="type">Constraints</span>) -&gt; <span class="type">MeasureResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>其实 <strong>SubcomposeLayout</strong> 和 <strong>Layout</strong> 组件是差不多的，它也需要传入一个 <code>measurePolicy</code> 测量策略参数。不同的是，此时传入的 <code>measurePolicy</code> 是一个 <code>SubcomposeMeasureScope</code> 类型 Lambda，打开接口声明可以看到其中仅有一个名为 <code>subcompose</code>的接口方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SubcomposeMeasureScope</span> : <span class="type">MeasureScope</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">subcompose</span><span class="params">(slotId: <span class="type">Any</span>?, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span>: List&lt;Measurable&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>subcompose</code> 方法会根据传入的 <code>slotId</code> 和 <code>content</code> 生成一个 <code>LayoutNode</code> 用于构建子 <code>Composition</code>，最终会返回 <code>content</code> 中所有子 <code>LayoutNode</code> 的 <code>Measurable</code> 测量句柄列表，所以结果是一个 <code>List&lt;Measurable&gt;</code>。其中 <code>content</code> 是我们声明的<code>Composable</code>子组件，可以包含多个子元素。<code>slotId</code> 是用来让 <code>SubcomposeLayout</code> 追踪管理我们所创建的子 <code>Composition</code> 的，作为唯一索引每个 <code>Composition</code> 都需要具有唯一的 <code>slotId</code>。</p>
<p>简单的理解：你可以认为 <code>subcompose</code> 方法就是对某个 <code>content</code>的<code>Composable</code>启动了一个子组合，并返回测量句柄，以便接下来你可以进行测量。</p>
<p>由于我们的 <strong>Divider</strong> 组件的高度是依赖 <strong>Text</strong> 组件的，所以声明 <strong>Divider</strong> 组件时我们传入一个 <code>Int</code> 值作为测量高度。首先我们定义一个 Composable：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeRow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    text: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    divider: @<span class="type">Composable</span> (<span class="type">Int</span>) -&gt; <span class="type">Unit</span> <span class="comment">// 传入高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    SubcomposeLayout(modifier = modifier) &#123; constraints-&gt;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先可以使用 <code>subcompose</code> 来先测量 <code>text</code> 中的所有 <code>LayoutNode</code>，并根据测量结果计算出<strong>最大高度</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SubcomposeLayout(modifier = modifier) &#123; constraints-&gt;</span><br><span class="line">    <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> textPlaceables = subcompose(<span class="string">&quot;text&quot;</span>, text).map &#123;</span><br><span class="line">        <span class="keyword">var</span> placeable = it.measure(constraints)</span><br><span class="line">        maxHeight = placeable.height.coerceAtLeast(maxHeight)</span><br><span class="line">        placeable</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然计算得到了文本的最大高度，我们接下来可以将该高度值传入 <strong>Divider</strong> 组件中，完成组合阶段并进行测量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubcomposeLayout(modifier = modifier) &#123; constraints-&gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> dividerPlaceable = subcompose(<span class="string">&quot;divider&quot;</span>) &#123; divider(maxHeight) &#125;.map &#123;</span><br><span class="line">        it.measure(constraints.copy(minWidth = <span class="number">0</span>))</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，与前面固有特性测量中的实现一样，在测量 <strong>Divider</strong> 组件时，仍需要拷贝一份 <code>constraints</code> 将 <code>minWidth</code> 设置为 <code>0</code>，避免 <code>constraints</code> 中的宽度变成固定值导致出现 <strong>Divider</strong> 组件宽度与整个父组件宽度相同的情况。</p>
<p>接下来分别对文本组件和分隔符组件进行摆放就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubcomposeLayout(modifier = modifier) &#123; constraints-&gt;</span><br><span class="line">    ...</span><br><span class="line">    layout(constraints.maxWidth, constraints.maxHeight)&#123;</span><br><span class="line">        textPlaceables.forEach &#123; it.placeRelative(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">        dividerPlaceable.forEach &#123; it.placeRelative(midPos, <span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整实现代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeRow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    text: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    divider: @<span class="type">Composable</span> (<span class="type">Int</span>) -&gt; <span class="type">Unit</span> <span class="comment">// 传入高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    SubcomposeLayout(modifier = modifier) &#123; constraints-&gt;</span><br><span class="line">        <span class="comment">// 测量计算得到文本的最大高度</span></span><br><span class="line">        <span class="keyword">var</span> maxHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> textPlaceables = subcompose(<span class="string">&quot;text&quot;</span>, text).map &#123;</span><br><span class="line">            <span class="keyword">val</span> placeable = it.measure(constraints)</span><br><span class="line">            maxHeight = placeable.height.coerceAtLeast(maxHeight)</span><br><span class="line">            placeable</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最大高度传入分隔符组件中, 并进行组合和测量</span></span><br><span class="line">        <span class="keyword">val</span> dividerPlaceable = subcompose(<span class="string">&quot;divider&quot;</span>) &#123; divider(maxHeight) &#125;.map &#123;</span><br><span class="line">            it.measure(constraints.copy(minWidth = <span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        assert(dividerPlaceable.size == <span class="number">1</span>) &#123; <span class="string">&quot;DividerScope Error!&quot;</span> &#125;</span><br><span class="line">        <span class="comment">// 分别摆放text和divider</span></span><br><span class="line">        <span class="keyword">val</span> midPos = constraints.maxWidth / <span class="number">2</span></span><br><span class="line">        layout(constraints.maxWidth, constraints.maxHeight)&#123;</span><br><span class="line">            textPlaceables.forEach &#123; it.placeRelative(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">            dividerPlaceable.forEach &#123; it.placeRelative(midPos, <span class="number">0</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TwoTextWithDivider</span><span class="params">()</span></span> &#123;</span><br><span class="line">    SubcomposeRow(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        text = &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Left&quot;</span>, Modifier.wrapContentWidth(Alignment.Start), fontSize = <span class="number">20.</span>sp)</span><br><span class="line">            Text(text = <span class="string">&quot;Right&quot;</span>, Modifier.wrapContentWidth(Alignment.End), fontSize = <span class="number">20.</span>sp)</span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123; maxHeight -&gt;</span><br><span class="line">        <span class="keyword">val</span> heightDp = with(LocalDensity.current) &#123; maxHeight.toDp() &#125; </span><br><span class="line">        Divider(Modifier.width(<span class="number">4.</span>dp).height(heightDp), Color.Black)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d0dc6c42899f2c7b484bdfef671c0236.png" alt="在这里插入图片描述"><br>最终效果与使用固有特性测量完全相同。</p>
<p>再来看一个例子，假设现在要实现一个搜索栏组件，它包含一个输入框和一个取消按钮，如下图所示：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/001708f0d7f928717eff6087bf8b608c.gif" alt="在这里插入图片描述"></p>
<p>在非搜索状态下，输入框占据全部父组件宽度，而在搜索状态下，输入框和取消按钮共享整个父组件的宽度。因此，输入框的宽度实际取决于取消按钮的宽度。</p>
<p>这里非常适合使用 <strong>SubcomposeLayout</strong>，首先会先尝试测量取消按钮的宽度，获取到已消费的宽度，如果取消按钮不存在，则已消费宽度为 0，然后将输入框的宽度测量设置为剩余宽度。最终在布局摆放阶段，只需将两个组件水平摆放即可。</p>
<p>实现代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeSearchFriendRow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    textField: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cancel: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    SubcomposeLayout(modifier) &#123; constraints -&gt;</span><br><span class="line">        <span class="comment">// 尝试获取取消按钮的测量句柄</span></span><br><span class="line">        <span class="keyword">val</span> cancelMeasureables = subcompose(<span class="string">&quot;cancel&quot;</span>) &#123; cancel() &#125;</span><br><span class="line">        <span class="comment">// 当cancel中存在组件时进行测量</span></span><br><span class="line">        <span class="keyword">val</span> cancelPlaceable: Placeable? = cancelMeasureables.firstOrNull()?.measure(constraints)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据测量结果获取已消费的宽度</span></span><br><span class="line">        <span class="keyword">val</span> consumeWidth = cancelPlaceable?.width ?: <span class="number">0</span></span><br><span class="line">        <span class="comment">// 获取输入框的测量句柄</span></span><br><span class="line">        <span class="keyword">val</span> textFieldMeasureable = subcompose(<span class="string">&quot;text_field&quot;</span>) &#123; textField() &#125;.first()</span><br><span class="line">        <span class="comment">// 将输入框的宽度强制设为剩余宽度</span></span><br><span class="line">        <span class="keyword">val</span> textFieldPlaceable = textFieldMeasureable.measure(</span><br><span class="line">            constraints.copy(</span><br><span class="line">                minWidth = constraints.maxWidth - consumeWidth,</span><br><span class="line">                maxWidth = constraints.maxWidth - consumeWidth</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前组件的宽度为约束允许的最大宽度</span></span><br><span class="line">        <span class="keyword">val</span> width = constraints.maxWidth</span><br><span class="line">        <span class="comment">// 当前组件的高度为两个组件的最大高度</span></span><br><span class="line">        <span class="keyword">val</span> height = max(cancelPlaceable?.height ?: <span class="number">0</span>, textFieldPlaceable.height)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成组件的摆放</span></span><br><span class="line">        layout(width, height) &#123;</span><br><span class="line">            textFieldPlaceable.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            cancelPlaceable?.placeRelative(textFieldPlaceable.width, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeSearchFriendRowPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isSearching <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> focusManager = LocalFocusManager.current</span><br><span class="line">    Column &#123;</span><br><span class="line">        SubcomposeSearchFriendRow(</span><br><span class="line">            modifier = Modifier.padding(<span class="number">16.</span>dp),</span><br><span class="line">            textField = &#123;</span><br><span class="line">                <span class="keyword">var</span> text <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">                OutlinedTextField(</span><br><span class="line">                    value = text,</span><br><span class="line">                    onValueChange = &#123; text = it &#125;,</span><br><span class="line">                    singleLine = <span class="literal">true</span>, <span class="comment">// 单行</span></span><br><span class="line">                    placeholder = &#123; Text(<span class="string">&quot;请输入关键字&quot;</span>) &#125;,</span><br><span class="line">                    leadingIcon = &#123;</span><br><span class="line">                        Icon(Icons.Filled.Search, <span class="literal">null</span>)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    textStyle = TextStyle(fontSize = <span class="number">15.</span>sp),</span><br><span class="line">                    colors = TextFieldDefaults.textFieldColors(</span><br><span class="line">                        backgroundColor = Color.Transparent <span class="comment">// 修改输入框背景色</span></span><br><span class="line">                    ),</span><br><span class="line">                    modifier = Modifier.onFocusChanged &#123; isSearching = it.isFocused &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;,</span><br><span class="line">            cancel = &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSearching) &#123;</span><br><span class="line">                    Button(</span><br><span class="line">                        modifier = Modifier.padding(horizontal = <span class="number">5.</span>dp),</span><br><span class="line">                        onClick = &#123; focusManager.clearFocus() &#125;</span><br><span class="line">                    ) &#123; Text(text = <span class="string">&quot;取消&quot;</span>) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个例子有点牵强，纯粹是为了练习 <strong>SubcomposeLayout</strong> 的使用。假如你在实际项目中有这样的需求，只需要使用 <strong>Row</strong> 组件搭配<code>weight</code>修饰符即可实现，例如，如下代码可以实现跟上面相同的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SearchFriendRow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isSearching <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> focusManager = LocalFocusManager.current</span><br><span class="line">    Row(Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">var</span> text <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = text,</span><br><span class="line">            onValueChange = &#123; text = it &#125;,</span><br><span class="line">            singleLine = <span class="literal">true</span>, <span class="comment">// 单行</span></span><br><span class="line">            placeholder = &#123; Text(<span class="string">&quot;请输入关键字&quot;</span>) &#125;,</span><br><span class="line">            leadingIcon = &#123;</span><br><span class="line">                Icon(Icons.Filled.Search, <span class="literal">null</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            textStyle = TextStyle(fontSize = <span class="number">15.</span>sp),</span><br><span class="line">            colors = TextFieldDefaults.textFieldColors(</span><br><span class="line">                backgroundColor = Color.Transparent <span class="comment">// 修改输入框背景色</span></span><br><span class="line">            ),</span><br><span class="line">            modifier = Modifier.fillMaxWidth().weight(<span class="number">1f</span>)</span><br><span class="line">                .onFocusChanged &#123; isSearching = it.isFocused &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (isSearching) &#123;</span><br><span class="line">            Button(</span><br><span class="line">                modifier = Modifier.padding(horizontal = <span class="number">5.</span>dp),</span><br><span class="line">                onClick = &#123; focusManager.clearFocus() &#125;</span><br><span class="line">            ) &#123; Text(text = <span class="string">&quot;取消&quot;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子使用 <strong>SubcomposeLayout</strong> 实现了一个可以横向滚动的新闻列表栏组件，它的每个子项的高度被设置为最大子项的高度：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SubComposeRowExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    SubcomposeRow(Modifier.padding(horizontal = <span class="number">8.</span>dp).horizontalScroll(rememberScrollState())) &#123;</span><br><span class="line">        Item(</span><br><span class="line">            text = <span class="string">&quot;重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;重大新闻重大新闻重大新闻&quot;</span></span><br><span class="line">        )</span><br><span class="line">        Spacer(Modifier.width(<span class="number">10.</span>dp))</span><br><span class="line">        Item(</span><br><span class="line">            text = <span class="string">&quot;重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻 &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻 &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;重大新闻重大&quot;</span></span><br><span class="line">        )</span><br><span class="line">        Spacer(Modifier.width(<span class="number">10.</span>dp))</span><br><span class="line">        Item(</span><br><span class="line">            text = <span class="string">&quot;重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻重大新闻&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Item</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, text: <span class="type">String</span>, )</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = modifier.clip(RoundedCornerShape(<span class="number">8</span>))</span><br><span class="line">            .background(Color.LightGray)</span><br><span class="line">            .padding(<span class="number">8.</span>dp).width(<span class="number">250.</span>dp),</span><br><span class="line">        horizontalAlignment = Alignment.End,</span><br><span class="line">        verticalArrangement = Arrangement.SpaceBetween</span><br><span class="line">    ) &#123;</span><br><span class="line">        Column &#123;</span><br><span class="line">            Text(<span class="string">&quot;重大新闻&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">            Text(text, modifier = Modifier.padding(top = <span class="number">5.</span>dp))</span><br><span class="line">        &#125;</span><br><span class="line">        Button(</span><br><span class="line">            modifier = Modifier.padding(top = <span class="number">20.</span>dp),</span><br><span class="line">            colors = ButtonDefaults.buttonColors(</span><br><span class="line">                backgroundColor = Red400,</span><br><span class="line">                contentColor = Color.White</span><br><span class="line">            ),</span><br><span class="line">            shape = RoundedCornerShape(<span class="number">8.</span>dp),</span><br><span class="line">            onClick = &#123;&#125;</span><br><span class="line">        ) &#123; Text(<span class="string">&quot;Button&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Row that sets all of its children composables to same height like news columns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeRow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span> = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    SubcomposeLayout(modifier = modifier) &#123; constraints -&gt;</span><br><span class="line">        <span class="keyword">var</span> subcomposeIndex = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 对内容进行测量</span></span><br><span class="line">        <span class="keyword">var</span> placeables = subcompose(subcomposeIndex++, content).map &#123;</span><br><span class="line">            it.measure(constraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算整个组件的大小</span></span><br><span class="line">        <span class="keyword">var</span> rowSize = placeables.fold(IntSize.Zero) &#123; currentMax, placeable -&gt;</span><br><span class="line">                IntSize(</span><br><span class="line">                    width = currentMax.width + placeable.width, <span class="comment">// 宽度累加所有子项宽度</span></span><br><span class="line">                    height = maxOf(currentMax.height, placeable.height) <span class="comment">// 高度取最大子项的高度</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 使用最高项的高度重新测量每个元素，并将其作为每个子组合项的最小高度</span></span><br><span class="line">        <span class="keyword">if</span> (placeables.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            placeables = subcompose(subcomposeIndex, content).map &#123; measurable -&gt;</span><br><span class="line">                measurable.measure(</span><br><span class="line">                    Constraints(</span><br><span class="line">                        minHeight = rowSize.height,</span><br><span class="line">                        maxHeight = constraints.maxHeight</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新计算row的大小</span></span><br><span class="line">            rowSize = placeables.fold(IntSize.Zero) &#123; currentMax, placeable -&gt;</span><br><span class="line">                    IntSize(</span><br><span class="line">                        width = currentMax.width + placeable.width,</span><br><span class="line">                        height = maxOf(currentMax.height, placeable.height)</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        layout(rowSize.width, rowSize.height) &#123;</span><br><span class="line">            <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">            placeables.forEach &#123; placeable: Placeable -&gt;</span><br><span class="line">                placeable.placeRelative(x, <span class="number">0</span>)</span><br><span class="line">                x += placeable.width</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8f8dfdab09e30d86a7f2ebe9086028c2.gif" alt="在这里插入图片描述"><br>如果使用普通的Row组件，除了设置每个子项为固定高度外，很难达到上面的效果。下面是使用普通Row组件的效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/62422de3386255e33ea85fb01ce7d253.gif" alt="在这里插入图片描述"></p>
<p>在下面的例子中，使用 <strong>SubcomposeLayout</strong> 实现了一个可以根据最大子项宽度自动调整每个子项宽度的Column组件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeLayoutExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> textList = List(<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> textValue = remember &#123; mutableStateOf(TextFieldValue(<span class="string">&quot;Text content&quot;</span>)) &#125;</span><br><span class="line">        textValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> bgColors = listOf(Orange400, Pink400, Blue400, Green400)</span><br><span class="line"></span><br><span class="line">    SubcomposeColumn(</span><br><span class="line">        modifier = Modifier.padding(<span class="number">8.</span>dp).background(Color.LightGray).padding(<span class="number">8.</span>dp),</span><br><span class="line">        content = &#123;</span><br><span class="line">            textList.forEachIndexed &#123; index, textValue -&gt;</span><br><span class="line">                Column(Modifier.background(bgColors[index]).padding(<span class="number">4.</span>dp)) &#123;</span><br><span class="line">                    Text(text = textValue.value.text, fontSize = <span class="number">15.</span>sp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    textList.forEachIndexed &#123; index, textValue -&gt;</span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            modifier = Modifier.padding(horizontal = <span class="number">8.</span>dp).fillMaxWidth(),</span><br><span class="line">            value = textValue.value,</span><br><span class="line">            label = &#123; Text(<span class="string">&quot;Text<span class="subst">$&#123;index&#125;</span>&quot;</span>) &#125;,</span><br><span class="line">            placeholder = &#123; Text(<span class="string">&quot;Set text to change main width&quot;</span>) &#125;,</span><br><span class="line">            onValueChange = &#123; textValue.value = it &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Column that resizes its children to width of the longest child</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeColumn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span> = &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    SubcomposeLayout(modifier = modifier) &#123; constraints -&gt;</span><br><span class="line">        <span class="keyword">var</span> subcomposeIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对内容进行测量</span></span><br><span class="line">        <span class="keyword">var</span> placeables = subcompose(subcomposeIndex++, content).map &#123;</span><br><span class="line">            it.measure(constraints)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算整个组件的大小</span></span><br><span class="line">        <span class="keyword">val</span> columnSize = placeables.fold(IntSize.Zero) &#123; currentMax, placeable -&gt;</span><br><span class="line">                IntSize(</span><br><span class="line">                    width = maxOf(currentMax.width, placeable.width), <span class="comment">// 宽度取最长的子元素的宽度</span></span><br><span class="line">                    height = currentMax.height + placeable.height <span class="comment">// 高度累加</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用最长子项的宽度重新测量每个子元素，并将其作为每个子组合项的最小宽度</span></span><br><span class="line">        <span class="keyword">if</span> (placeables.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            placeables = subcompose(subcomposeIndex, content).map &#123; measurable -&gt;</span><br><span class="line">                measurable.measure(Constraints(columnSize.width, constraints.maxWidth))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        layout(columnSize.width, columnSize.height) &#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                y += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/186dd1bf91b01fb45a3b5b7bb6116213.gif" alt="在这里插入图片描述"></p>
<h4 id="SubcomposeLayout-小结"><a href="#SubcomposeLayout-小结" class="headerlink" title="SubcomposeLayout 小结"></a>SubcomposeLayout 小结</h4><p>最后我们再来总结一下 <strong>SubcomposeLayout</strong> 跟前面介绍过的 <strong>Layout</strong> 组件的主要区别是，它会将子组件的<strong>合成阶段</strong>延迟到自己的<strong>布局阶段</strong>执行，也就是说在布局阶段会多启动一个<strong>子组合</strong>过程（SubComposition）：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/aede71a5be21bf42da1129631e255632.png" alt="在这里插入图片描述"></p>
<p>虽然 <strong>SubcomposeLayout</strong> 具有很强的灵活性，然而性能上不如常规的 <strong>Layout</strong> 组件，因为子组件的合成需要要迟到父组件测量时才能进行，并且需要还需要额外创建一个子 <strong>Composition</strong>，因此 <strong>SubcomposeLayout 可能并不适用在一些对性能要求比较高的 UI 场景</strong>。在一些实在没有办法的特殊场景下，才推荐尝试使用它。</p>
<p>但这并不代表它完全没有用处。例如图片加载库 <a target="_blank" rel="noopener" href="https://github.com/coil-kt/coil">Coil</a> 的 <a target="_blank" rel="noopener" href="https://coil-kt.github.io/coil/compose/">Jetpack Compose 版本</a> 中的 <code>SubcomposeAsyncImage</code> 组件就是基于 <strong>SubcomposeLayout</strong> 能力实现的，再比如系统内置的 <strong>LazyRow</strong> 和 <strong>LazyColumn</strong> 等延迟列表系列组件的内部实现最终都调用了 <strong>SubcomposeLayout</strong>，而系统内置的 <strong>Scaffold</strong> 脚手架组件内部也是通过<strong>SubcomposeLayout</strong>来处理不同槽位之间的测量信息依赖。包括在后文中将要介绍的 <strong>BoxWithConstraints</strong> 组件，内部也是基于<strong>SubcomposeLayout</strong>的封装。</p>
<p>以 <strong>LayzyList</strong> 系列的组件为例，之所以使用<strong>SubcomposeLayout</strong>来实现它，是因为那些滑出屏幕之外的列表项组件是不需要在当前<strong>立即</strong>进行组合的，因此这里它们的<strong>组合阶段</strong>的执行会有一个<strong>延迟</strong>的过程（也就是会延迟到当它们被滑入屏幕之内的时候再被执行），这对于提高长列表的性能而言是非常重要的，这也是为什么这一系列的组件的名字中包含了一个 “<strong>Lazy</strong>” 单词的含义和原因。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1ff67be7772a4b0a2d821364153a20cc.png" alt="在这里插入图片描述"></p>
<p>可见在某些情况下我们是避不开使用它的，我不能说在所有这些情况下都推荐一定去使用它，只能说你需要 “对症下药”，了解它的能力有可能作为我们在极端情况下唯一的救命稻草或者灵丹妙药。</p>
<p>另外，Compose 官方也为我们提供了一些关于 SubcomposeLayout 的使用建议：</p>
<ul>
<li>如果说，你的需求场景是：至少一个 child 的<strong>组合</strong>依赖于其他 child 的<strong>测量</strong>结果，那么你可以使用它。</li>
<li>但是如果说，你的需求场景只是：一个 child 的<strong>测量</strong>结果依赖于另一个 child 的<strong>测量</strong>结果，那么这种场景下就完全不需要使用 <strong>SubcomposeLayout</strong>，因为通过前面介绍的常规 <strong>Layout</strong> 组件的自定义即可满足需求。</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/040ceb73a5302e02824d780d3546d45a.png" alt="在这里插入图片描述"></p>
<h3 id="ParentDataModifier-和-Scope"><a href="#ParentDataModifier-和-Scope" class="headerlink" title="ParentDataModifier 和 Scope"></a>ParentDataModifier 和 Scope</h3><p><strong>ParentDataModifier：</strong> 一个继承自<code>Modifier.Element</code>的接口，它是一个可以为父布局提供数据的修饰符。可以在测量和布局期间通过<code>IntrinsicMeasurable.parentData</code> 读取到设置的数据值。<code>parentData</code> 通常用于通知父类如何测量和定位子类布局。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ParentDataModifier</span> : <span class="type">Modifier.Element</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span>: Any?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，以下代码利用<strong>ParentDataModifier</strong>实现了一个简易版的<code>Row/Column</code>中的<strong>weight</strong>属性的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">VerticalScope</span> &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">weight</span><span class="params">(weight: <span class="type">Float</span>)</span></span>: Modifier = <span class="keyword">this</span>.then(</span><br><span class="line">        WeightParentData(weight)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : VerticalScope</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightParentData</span>(<span class="keyword">val</span> weight: <span class="built_in">Float</span>=<span class="number">0f</span>) : ParentDataModifier &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> = <span class="keyword">this</span><span class="symbol">@WeightParentData</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WeightedVerticalLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">VerticalScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> measurePolicy = MeasurePolicy &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123;it.measure(constraints)&#125;</span><br><span class="line">        <span class="comment">// 获取各weight值</span></span><br><span class="line">        <span class="keyword">val</span> weights = measurables.map &#123;</span><br><span class="line">            (it.parentData <span class="keyword">as</span> WeightParentData).weight</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> totalHeight = constraints.maxHeight</span><br><span class="line">        <span class="keyword">val</span> totalWeight = weights.sum()</span><br><span class="line">        <span class="comment">// 宽度：最宽的一项</span></span><br><span class="line">        <span class="keyword">val</span> width = placeables.maxOf &#123; it.width &#125;</span><br><span class="line">        layout(width, totalHeight) &#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">            placeables.forEachIndexed() &#123; i, placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                <span class="comment">// 按比例设置大小</span></span><br><span class="line">                y += (totalHeight * weights[i] / totalWeight).toInt()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Layout(&#123; VerticalScope.content() &#125;, modifier, measurePolicy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 <code>Modifier.width</code> 属性修饰符，只能在我们自定义的 <code>VerticalScope</code> 作用域内使用，因为<code>WeightedVerticalLayout</code>的 <code>content</code> Composable 的 Receiver 被限制为 <code>VerticalScope</code> 。</p>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WeightedVerticalLayoutExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    WeightedVerticalLayout(Modifier.padding(<span class="number">16.</span>dp).height(<span class="number">200.</span>dp)) &#123;</span><br><span class="line">        Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">1f</span>).background(Color.Red))</span><br><span class="line">        Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">2f</span>).background(Color.Green))</span><br><span class="line">        Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">7f</span>).background(Color.Blue))</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fe901788644032700cb17b2107989e59.png"></p>
<p>下面例子实现一个类似 <strong>Column</strong> 组件的 <code>horizontalAlignment</code> 参数，可以设置水平方向的对齐方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 - 创建用于设置水平对齐选项的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">HorizontalAlignment</span> &#123;</span><br><span class="line">    Start, Center, End</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2 - 创建一个ParentDataModifier接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CustomColumnData</span>(<span class="keyword">val</span> alignment: HorizontalAlignment) : ParentDataModifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> = <span class="keyword">this</span><span class="symbol">@CustomColumnData</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(other <span class="keyword">is</span> CustomColumnData)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alignment != other.alignment) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = alignment.hashCode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;CustomColumnData(alignment=<span class="variable">$alignment</span>)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3 - 创建一个Scope作用域接口，该接口中一个返回CustomColumnData的Modifier自定义扩展函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CustomColumnScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">horizontalAlign</span><span class="params">(align: <span class="type">HorizontalAlignment</span>)</span></span> = <span class="keyword">this</span>.then(</span><br><span class="line">        CustomColumnData(align)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : CustomColumnScope</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4 - 创建扩展属性以便在自定义Layout中进行测量时，可以方便的获取到CustomColumnData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Measurable.childData: CustomColumnData?</span><br><span class="line">    <span class="keyword">get</span>() = parentData <span class="keyword">as</span>? CustomColumnData</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Measurable.alignment: HorizontalAlignment</span><br><span class="line">    <span class="keyword">get</span>() = childData?.alignment ?: HorizontalAlignment.Start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomColumnWithScope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">CustomColumnScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = &#123; CustomColumnScope.content() &#125;</span><br><span class="line">    ) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="comment">// 我们需要将minWidth设置为0来包装可放置的宽度</span></span><br><span class="line">        <span class="keyword">val</span> looseConstraints = constraints.copy(minWidth = <span class="number">0</span>, minHeight = <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 测量每个子项</span></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.measure(looseConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取到每个子项上面horizontalAlign自定义修饰符设置的alignment参数值</span></span><br><span class="line">        <span class="keyword">val</span> measurableAlignments = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.alignment</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算总高度值：max[所有子项的高度之和，父约束条件的最小高度值]</span></span><br><span class="line">        <span class="keyword">val</span> totalHeight: <span class="built_in">Int</span> = placeables.sumOf &#123; it.height &#125;.coerceAtLeast(constraints.minHeight)</span><br><span class="line">        <span class="keyword">val</span> maxWidth = constraints.maxWidth <span class="comment">// 总宽度使用父约束条件的最大宽度值</span></span><br><span class="line">        println(<span class="string">&quot;🤯 Constraints minWidth: <span class="subst">$&#123;constraints.minWidth&#125;</span>, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;minHeight: <span class="subst">$&#123;constraints.minHeight&#125;</span>, maxWidth: <span class="subst">$&#123;constraints.maxWidth&#125;</span>, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;maxHeight: <span class="subst">$&#123;constraints.maxHeight&#125;</span>, totalHeight: <span class="variable">$totalHeight</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置布局大小尽可能的大</span></span><br><span class="line">        layout(maxWidth, totalHeight) &#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 摆放每个子元素</span></span><br><span class="line">            placeables.forEachIndexed &#123; index, placeable -&gt;</span><br><span class="line">                <span class="keyword">val</span> x = <span class="keyword">when</span> (measurableAlignments[index]) &#123;</span><br><span class="line">                    HorizontalAlignment.Start -&gt; <span class="number">0</span></span><br><span class="line">                    HorizontalAlignment.Center -&gt; (maxWidth - placeable.measuredWidth) / <span class="number">2</span></span><br><span class="line">                    HorizontalAlignment.End -&gt; maxWidth - placeable.measuredWidth</span><br><span class="line">                &#125;</span><br><span class="line">                placeable.placeRelative(x, y)</span><br><span class="line">                y += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomColumnWithScopeExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CustomColumnWithScope(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .padding(<span class="number">8.</span>dp)</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                <span class="comment">//.height(250.dp)</span></span><br><span class="line">                .wrapContentHeight() </span><br><span class="line">                .background(Color.LightGray)</span><br><span class="line">    ) &#123; </span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align Start&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xffF44336</span>))</span><br><span class="line">                .horizontalAlign(HorizontalAlignment.Start),</span><br><span class="line">            color = Color.White</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align Center&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xff9C27B0</span>))</span><br><span class="line">                .horizontalAlign(HorizontalAlignment.Center),</span><br><span class="line">            color = Color.White</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align End&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xff2196F3</span>))</span><br><span class="line">                .horizontalAlign(HorizontalAlignment.End),</span><br><span class="line">            color = Color.White</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align Start&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xff8BC34A</span>))</span><br><span class="line">                .horizontalAlign(HorizontalAlignment.Start),</span><br><span class="line">            color = Color.White</span><br><span class="line">        ) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1a9fb04b219a6572e84c81e1848456f2.png" alt="在这里插入图片描述"></p>
<p>如果把 <code>CustomColumnWithScope</code> 高度改为 <code>Modifier.height(250.dp)</code> 则效果如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/39effc5030f5396c602adc08a460db7a.png" alt="在这里插入图片描述"></p>
<p>类似的，下面例子实现一个类似 <strong>Row</strong> 组件的 <code>verticalAlignment</code> 参数，可以设置垂直方向上的对齐方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 - 创建用于设置垂直对齐选项的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">VerticalAlignment</span> &#123;</span><br><span class="line">    Top, Center, Bottom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2 - 创建一个ParentDataModifier接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CustomRowData</span>(</span><br><span class="line">    <span class="keyword">val</span> alignment: VerticalAlignment</span><br><span class="line">) : ParentDataModifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> = <span class="keyword">this</span><span class="symbol">@CustomRowData</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === other) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (javaClass != other?.javaClass) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(other <span class="keyword">is</span> CustomRowData)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alignment != other.alignment) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = alignment.hashCode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;CustomRowData(alignment=<span class="variable">$alignment</span>)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3 - 创建一个Scope作用域接口，该接口中一个返回CustomRowData的Modifier自定义扩展函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CustomRowScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">verticalAlign</span><span class="params">(align: <span class="type">VerticalAlignment</span>)</span></span> = <span class="keyword">this</span>.then(</span><br><span class="line">        CustomRowData(align)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : CustomRowScope</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4 - 创建扩展属性以便在自定义Layout中进行测量时，可以方便的获取到CustomRowData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Measurable.<span class="keyword">data</span>: CustomRowData?</span><br><span class="line">    <span class="keyword">get</span>() = parentData <span class="keyword">as</span>? CustomRowData</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Measurable.verticalAlignment: VerticalAlignment</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">data</span>?.alignment ?: VerticalAlignment.Center</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomRowWithScope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">CustomRowScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        content = &#123; CustomRowScope.content() &#125;,</span><br><span class="line">    ) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="comment">// 我们需要将minWidth设置为0来包装可放置的宽度</span></span><br><span class="line">        <span class="keyword">val</span> looseConstraints = constraints.copy(minWidth = <span class="number">0</span>, minHeight = <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 测量每个子项</span></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.measure(looseConstraints)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取到每个子项上面verticalAlign自定义修饰符设置的alignment参数值</span></span><br><span class="line">        <span class="keyword">val</span> measurableAlignments = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.verticalAlignment</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算总宽度值：max[所有子项的宽度之和，父约束条件的最小宽度值]</span></span><br><span class="line">        <span class="keyword">val</span> totalWidth: <span class="built_in">Int</span> = placeables.sumOf &#123; it.width &#125;.coerceAtLeast(constraints.minWidth)</span><br><span class="line">        <span class="comment">// 计算总高度值：max[所有子项中的最大高度值，父约束条件的最小高度值]</span></span><br><span class="line">        <span class="keyword">val</span> maxHeight: <span class="built_in">Int</span> = (placeables.maxOfOrNull &#123; it.height &#125; ?: <span class="number">0</span>).coerceAtLeast(constraints.minHeight)</span><br><span class="line">        println(<span class="string">&quot;🧨 Constraints minWidth: <span class="subst">$&#123;constraints.minWidth&#125;</span>, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;minHeight: <span class="subst">$&#123;constraints.minHeight&#125;</span>, maxWidth: <span class="subst">$&#123;constraints.maxWidth&#125;</span>, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;maxHeight: <span class="subst">$&#123;constraints.maxHeight&#125;</span>, totalWidth: <span class="subst">$&#123;totalWidth&#125;</span>,  height: <span class="variable">$maxHeight</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置布局大小尽可能的大</span></span><br><span class="line">        layout(totalWidth, maxHeight) &#123;</span><br><span class="line">            <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 摆放每个子元素</span></span><br><span class="line">            placeables.forEachIndexed &#123; index, placeable -&gt;</span><br><span class="line">                <span class="keyword">val</span> y = <span class="keyword">when</span> (measurableAlignments[index]) &#123;</span><br><span class="line">                    VerticalAlignment.Top -&gt; <span class="number">0</span></span><br><span class="line">                    VerticalAlignment.Center -&gt; (maxHeight - placeable.measuredHeight) / <span class="number">2</span></span><br><span class="line">                    VerticalAlignment.Bottom -&gt; maxHeight - placeable.measuredHeight</span><br><span class="line">                &#125;</span><br><span class="line">                placeable.placeRelative(x, y)</span><br><span class="line">                x += placeable.width</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomRowWithScopeExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CustomRowWithScope(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .padding(<span class="number">8.</span>dp)</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .height(<span class="number">100.</span>dp)</span><br><span class="line">                .background(Color.DarkGray)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align Top&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xffF44336</span>))</span><br><span class="line">                .verticalAlign(VerticalAlignment.Top),</span><br><span class="line">            color = Color.White</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align Center&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xff9C27B0</span>))</span><br><span class="line">                .verticalAlign(VerticalAlignment.Center),</span><br><span class="line">            color = Color.White</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            <span class="string">&quot;Align Bottom&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .background(Color(<span class="number">0xff2196F3</span>))</span><br><span class="line">                .verticalAlign(VerticalAlignment.Bottom),</span><br><span class="line">            color = Color.White</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c188a82127448e73de8492b2e71912eb.png" alt="在这里插入图片描述"></p>
<h4 id="ParentDataModifier-小结"><a href="#ParentDataModifier-小结" class="headerlink" title="ParentDataModifier 小结"></a>ParentDataModifier 小结</h4><p>下面对 <strong>ParentDataModifier</strong> 的使用步骤进行一个简要概况总结：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/044fee477a8f541ed0107d94e6dc98eb.png" alt="在这里插入图片描述"></p>
<p>在上面几个例子的代码中，我们都会创建一个<code>Scope</code>作用域的接口，并在该接口中自定义 Modifier 的扩展函数，为什么要这样做呢？这是因为限制自定义属性的作用域是非常有意义的，例如系统的 <strong>Box</strong> 组件的 <code>matchParentSize()</code> 修饰符只能在 <strong>BoxScope</strong> 作用域范围内使用，同样的 <strong>Row</strong> 组件的 <code>weight()</code> 修饰符只能在 <strong>RowScope</strong> 作用域范围内使用。这样的好处是可以避免在某个组件上使用不属于它的修饰符，否则这会让人非常困惑，就像在 Android 传统 <strong>View</strong> 体系开发过程中编写 <strong>xml</strong> 布局文件时，有时我们并不能确定是否应该在某个控件上应用某个属性。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9d6b9a96c050af19e06dc416ed07965d.png" alt="在这里插入图片描述"></p>
<h3 id="BoxWithConstraints-构建自适应布局"><a href="#BoxWithConstraints-构建自适应布局" class="headerlink" title="BoxWithConstraints 构建自适应布局"></a>BoxWithConstraints 构建自适应布局</h3><p><strong>BoxWithConstraints</strong> 是一种类似于 <strong>Box</strong> 的布局组件，但它的优点是可以获取到当前Composable的<strong>最小&#x2F;最大可用宽度和高度信息</strong>以及<strong>来自父组件的约束信息</strong>。你可以利用这些信息来决定如何显示不同的内容，它会自行调整大小以适应内容。这对于需要构建自适应屏幕的布局场景非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BoxWithConstraints &#123;</span><br><span class="line">    <span class="comment">// 当前能访问到的 this 对象为 BoxWithConstraintsScope 的实例</span></span><br><span class="line">    <span class="keyword">val</span> boxWithConstraintsScope = <span class="keyword">this</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>BoxWithConstraints</strong> 的 lambda 代码块内，你可以直接访问到 <strong>BoxWithConstraintsScope</strong> 作用域对象的<code>minWidth</code>, <code>maxWidth</code>, <code>minHeight</code>, <code>maxHeight</code>（<code>dp</code>值）和 <code>constraints</code>（父组件传入的约束对象，可以获取前面四个属性对应的<code>px</code>值）属性，从而根据这几个属性值做出进一步的决定，来安排你要显示的内容。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/94e52659f1315fe445cd2ef9df177034.png" alt="在这里插入图片描述"></p>
<p>例如，下面的示例<code>Composable</code>跟据<code>maxHeight</code>的值不同而显示不同内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BoxWithConstraintsExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    BoxWithConstraints &#123;</span><br><span class="line">        <span class="keyword">val</span> boxWithConstraintsScope = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeight &lt; <span class="number">200.</span>dp) &#123;</span><br><span class="line">            Column(Modifier.fillMaxWidth().background(Color.Cyan)) &#123;</span><br><span class="line">                Text(<span class="string">&quot;只在最大高度 &lt; 200dp 时显示&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                with(boxWithConstraintsScope) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;minHeight: <span class="variable">$minHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;maxHeight: <span class="variable">$maxHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;minWidth: <span class="variable">$minWidth</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;maxWidth: <span class="variable">$maxWidth</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Column(Modifier.fillMaxWidth().background(Color.Green)) &#123;</span><br><span class="line">                Text(<span class="string">&quot;当 maxHeight &gt;= 200dp 时显示&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                with(boxWithConstraintsScope) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;minHeight: <span class="variable">$minHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;maxHeight: <span class="variable">$maxHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;minWidth: <span class="variable">$minWidth</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;maxWidth: <span class="variable">$maxWidth</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>minWidth</code>, <code>maxWidth</code>, <code>minHeight</code>, <code>maxHeight</code> 必须在<strong>BoxWithConstraintsScope</strong> 作用域内才能访问到，因此上面代码中位于 Column 的 ColumnScope 作用域内的 Text 组件无法访问到，所以必须先暂存一下当前作用域对象，随后通过 <code>boxWithConstraintsScope.minWidth</code> 方式调用，这里使用了Kotlin中一个比较方便的 <code>with</code> 函数来指定要访问属性的 Receiver。</p>
<p>可以定义两个不同高度的预览函数来进行测试：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(heightDp = 150, showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BoxWithConstraintsExamplePreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    BoxWithConstraintsExample()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview(heightDp = 250, showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BoxWithConstraintsExamplePreview2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    BoxWithConstraintsExample()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预览效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a47f562837e8683c2901ae7fb2e8ddca.png" alt="在这里插入图片描述"></p>
<p>下面的示例中，定义<strong>BoxWithConstraints</strong>中的两个子元素的高度分别占总空间可用高度的<code>2/3</code>和<code>1/3</code>，实现类似 <code>weight</code> 的效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">BoxWithConstraintsExample2</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    BoxWithConstraints(modifier.background(Color.LightGray)) &#123;</span><br><span class="line">        <span class="keyword">val</span> boxWithConstraintsScope = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">val</span> topHeight = maxHeight * <span class="number">2</span> / <span class="number">3f</span></span><br><span class="line">        <span class="comment">// 也可以通过父组件传入的constraints来获取，不过这样得到的值是px，需要按需转成成dp使用</span></span><br><span class="line">        <span class="comment">// val topHeight = (this.constraints.maxHeight * 2 / 3f).toDp()</span></span><br><span class="line">        Column(Modifier.fillMaxWidth()) &#123;</span><br><span class="line">            Column(Modifier.background(Color.Magenta).fillMaxWidth().height(topHeight)) &#123;</span><br><span class="line">                Text(<span class="string">&quot;占整个组件高度的 2/3 \ntopHeight: <span class="variable">$topHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                with(boxWithConstraintsScope) &#123;</span><br><span class="line">                    Text(<span class="string">&quot;minHeight: <span class="variable">$minHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;maxHeight: <span class="variable">$maxHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;minWidth: <span class="variable">$minWidth</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    Text(<span class="string">&quot;maxWidth: <span class="variable">$maxWidth</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> bottomHeight = boxWithConstraintsScope.maxHeight * <span class="number">1</span> / <span class="number">3f</span></span><br><span class="line">            Box(Modifier.background(Color.Cyan).fillMaxWidth().height(bottomHeight)) &#123;</span><br><span class="line">                Text(<span class="string">&quot;占整个组件高度的 1/3 \nbottomHeight: <span class="variable">$bottomHeight</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BoxWithConstraintsExample2Preview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(verticalArrangement = Arrangement.SpaceBetween) &#123;</span><br><span class="line">        <span class="keyword">var</span> height <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">200f</span>) &#125;</span><br><span class="line">        BoxWithConstraintsExample2(</span><br><span class="line">            Modifier.fillMaxWidth()</span><br><span class="line">                .height(height.dp)</span><br><span class="line">        )</span><br><span class="line">        Slider(value = height, onValueChange = &#123; height = it&#125;, valueRange = <span class="number">200f</span>.<span class="number">.600f</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/379da5d1f79e9bbd2643f8692d62173d.gif" alt="在这里插入图片描述"></p>
<p>下面假设这样一个需求，现在有一个卡片布局，我们希望卡片布局在空间允许的情况下能够显示更多的内容详情。如下所示：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a43fa2dd87cc5b31987f91d9cb2c3546.png" alt="在这里插入图片描述"></p>
<p>我们应该避免尝试使用设备的实际屏幕尺寸，对于多屏幕设备或者不是全屏显示的应用，这会不准确。使用 <strong>BoxWithConstraints</strong> 可以轻松地解决此需求，代码实现可以像下面这样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Card</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    imageUrl: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    title: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    BoxWithConstraints &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxWidth &lt; <span class="number">400.</span>dp) &#123;</span><br><span class="line">            Column &#123;</span><br><span class="line">                Image(imageUrl)</span><br><span class="line">                Title(title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Row &#123;</span><br><span class="line">                Column &#123;</span><br><span class="line">                    Title(title)</span><br><span class="line">                    Description(description)</span><br><span class="line">                &#125;</span><br><span class="line">                Image(imageUrl)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个更加实际一点的场景，假设我们的 UI 设计师现在设计了一个按照以下要求进行展示的卡片列表：</p>
<ol>
<li>在竖屏模式下，有 2 张卡片是完全可见的，第 3 张卡片只显示一小部分，以便让用户知道还有更多的内容可以滚动查看</li>
<li>在横屏模式下，有 4 张卡片是完全可见的，第 5 张卡片只显示一小部分，以便让用户知道还有更多的内容可以滚动查看</li>
</ol>
<p>展示效果如下图所示：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c17809fe4b8a23dd91a188e072651de2.gif" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/25025598fd651f66993d991284394d37.gif" alt="在这里插入图片描述"></p>
<p>由于 <strong>BoxWithConstraints</strong> 能让我们访问到 <code>maxWidth</code> 和 <code>maxHeight</code>，我们可以：</p>
<ol>
<li>判断当前是竖屏模式还是横屏模式</li>
<li>根据可用的屏幕宽度计算每张卡片的宽度，同时考虑到一张卡片应该是部分可见的</li>
</ol>
<p>看一下实现代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyAdaptiveCardList</span><span class="params">(cardDataList: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">    BoxWithConstraints &#123;</span><br><span class="line">        LazyRow(</span><br><span class="line">            horizontalArrangement = Arrangement.spacedBy(<span class="number">12.</span>dp),</span><br><span class="line">            verticalAlignment = Alignment.CenterVertically,</span><br><span class="line">            contentPadding = PaddingValues(<span class="number">24.</span>dp)</span><br><span class="line">        ) &#123;</span><br><span class="line">            items(cardDataList) &#123; card -&gt;</span><br><span class="line">                <span class="keyword">if</span> (maxWidth &gt; maxHeight) &#123;</span><br><span class="line">                    <span class="comment">// 横屏模式</span></span><br><span class="line">                    <span class="keyword">val</span> cardWidth = maxWidth / <span class="number">4</span></span><br><span class="line">                    MyCard(</span><br><span class="line">                        title = card.first,</span><br><span class="line">                        imgId = card.second,</span><br><span class="line">                        height = maxHeight / <span class="number">3</span>,</span><br><span class="line">                        width = cardWidth - cardWidth * <span class="number">0.15f</span></span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 竖屏模式</span></span><br><span class="line">                    <span class="keyword">val</span> cardWidth = maxWidth / <span class="number">2</span></span><br><span class="line">                    MyCard(</span><br><span class="line">                        title = card.first,</span><br><span class="line">                        imgId = card.second,</span><br><span class="line">                        height = maxHeight / <span class="number">4</span>,</span><br><span class="line">                        width = cardWidth - cardWidth * <span class="number">0.2f</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<strong>BoxWithConstraints</strong> 中使用了 <strong>LazyRow</strong> 组件，在 <strong>LazyRow</strong> 的 lambda 代码块内不属于特定的Scope作用域（使用的是DSL语法），因此在上面的代码中是可以直接访问到 <strong>BoxWithConstraintsScope</strong> 作用域对象的属性值。但是假如 <strong>BoxWithConstraints</strong> 里面换成别的组件，例如普通的 <strong>Row</strong> 组件，就会比较麻烦：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyAdaptiveCardList2</span><span class="params">(cardDataList: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">    BoxWithConstraints &#123;</span><br><span class="line">        <span class="keyword">val</span> boxWithConstraintsScope = <span class="keyword">this</span></span><br><span class="line">        Row(</span><br><span class="line">            horizontalArrangement = Arrangement.spacedBy(<span class="number">12.</span>dp),</span><br><span class="line">            verticalAlignment = Alignment.CenterVertically,</span><br><span class="line">        ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (boxWithConstraintsScope.maxWidth &gt; boxWithConstraintsScope.maxHeight) &#123;</span><br><span class="line">                    <span class="keyword">val</span> cardWidth = boxWithConstraintsScope.maxWidth / <span class="number">4</span></span><br><span class="line">                    MyCard(</span><br><span class="line">                        ...</span><br><span class="line">                        height = boxWithConstraintsScope.maxHeight / <span class="number">3</span>,</span><br><span class="line">                        width = cardWidth - cardWidth * <span class="number">0.15f</span></span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> cardWidth = boxWithConstraintsScope.maxWidth / <span class="number">2</span></span><br><span class="line">                    MyCard(</span><br><span class="line">                        ...</span><br><span class="line">                        height = boxWithConstraintsScope.maxHeight / <span class="number">4</span>,</span><br><span class="line">                        width = cardWidth - cardWidth * <span class="number">0.2f</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在每次需要访问属性的地方就必须显示地调用 <code>boxWithConstraintsScope</code> 来访问，甚是麻烦，可以选择使用第一个例子中提到的 <code>with</code> 语法来解决。但其实还有一个更简单的方法是，我们可以将展示列表内容的逻辑部分定义为 <strong>BoxWithConstraintsScope</strong> 的一个扩展函数来解决：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> BoxWithConstraintsScope.<span class="title">AdaptiveCardList</span><span class="params">(cardDataList: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;<span class="type">String</span>, <span class="built_in">Int</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">    LazyRow(</span><br><span class="line">        horizontalArrangement = Arrangement.spacedBy(<span class="number">12.</span>dp),</span><br><span class="line">        verticalAlignment = Alignment.CenterVertically,</span><br><span class="line">        contentPadding = PaddingValues(<span class="number">24.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        items(cardDataList) &#123; card -&gt;</span><br><span class="line">            <span class="keyword">if</span> (maxWidth &gt; maxHeight) &#123;</span><br><span class="line">                <span class="comment">// 横屏模式</span></span><br><span class="line">                <span class="keyword">val</span> cardWidth = maxWidth / <span class="number">4</span></span><br><span class="line">                MyCard(</span><br><span class="line">                    title = card.first,</span><br><span class="line">                    imgId = card.second,</span><br><span class="line">                    height = maxHeight / <span class="number">3</span>,</span><br><span class="line">                    width = cardWidth - cardWidth * <span class="number">0.15f</span></span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 竖屏模式</span></span><br><span class="line">                <span class="keyword">val</span> cardWidth = maxWidth / <span class="number">2</span></span><br><span class="line">                MyCard(</span><br><span class="line">                    title = card.first,</span><br><span class="line">                    imgId = card.second,</span><br><span class="line">                    height = maxHeight / <span class="number">4</span>,</span><br><span class="line">                    width = cardWidth - cardWidth * <span class="number">0.2f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于扩展函数的 <strong>Receiver</strong> 是 <strong>BoxWithConstraintsScope</strong>，因此里面就可以直接访问其属性了。</p>
<p>使用时也非常简单，只需要在外层套上 <strong>BoxWithConstraints</strong> 即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">AdaptiveCardListPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cardData = remember &#123; getCardDatas() &#125;</span><br><span class="line">    BoxWithConstraints &#123;</span><br><span class="line">        AdaptiveCardList(cardData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，通过这个例子，我们知道了一个技能点就是可以通过如下代码来判断屏幕当前的横竖屏模式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须在 BoxWithConstraintsScope 作用域内访问</span></span><br><span class="line"><span class="keyword">if</span> (maxWidth &gt; maxHeight) &#123;</span><br><span class="line">    <span class="comment">// 横屏模式</span></span><br><span class="line">    ... </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 竖屏模式 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里顺便提一下，如果是在其他非 <strong>BoxWithConstraints</strong> 的 <code>Composable</code> 组件中，常规的判断横竖屏模式的方法是使用 <code>LocalConfiguration</code> 来判断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> configuration = LocalConfiguration.current</span><br><span class="line"><span class="keyword">when</span> (configuration.orientation) &#123;</span><br><span class="line">    Configuration.ORIENTATION_LANDSCAPE -&gt; &#123;</span><br><span class="line">        <span class="comment">// in landscape mode</span></span><br><span class="line">    &#125;</span><br><span class="line">    Configuration.ORIENTATION_PORTRAIT -&gt; &#123;</span><br><span class="line">        <span class="comment">// in portrait mode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本示例使用了 <strong>BoxWithConstraints</strong> ，所以就没必要再使用 <code>LocalConfiguration</code> 来判断了。</p>
<h4 id="BoxWithConstraints-小结"><a href="#BoxWithConstraints-小结" class="headerlink" title="BoxWithConstraints 小结"></a>BoxWithConstraints 小结</h4><p><strong>BoxWithConstraints</strong> 在默认情况下不会将它接收到的约束信息继续传递给子组件（不被子组件 <code>Layout</code> 的 lambda 的 <code>constraints</code>参数所接收），这是在Compose可能是一个特例，但是它有一个参数 <code>propagateMinConstraints</code> 可以控制是否希望将约束继续往下传，该参数默认值为 <code>false</code>，如果你有需要可以改成 <code>true</code> 则约束会继续往下传。所以我们可以认为 <strong>BoxWithConstraints</strong> 还具有一种可以拒绝父组件约束条件的超能力，正所谓 “将在外，君命有所不受” 。</p>
<p>虽然 <strong>BoxWithConstraints</strong> 在构建自适应布局方面有着强大的优势，但是，使用它也会带来一些后果，因为 <strong>BoxWithConstraints</strong> 会将<strong>组合</strong>推迟到<strong>布局阶段</strong>（此时已知道这些约束条件），从而导致在<strong>布局</strong>期间执行更多的工作。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/84b2eeeadfbe89ed6dbeb8d496a0f214.png" alt="在这里插入图片描述"></p>
<p><strong>BoxWithConstraints</strong> 会在<strong>布局阶段</strong>启动<strong>子组合</strong>，出于性能原因的考虑，我们应该尽可能避免在布局期间进行组合，尽量使用根据尺寸变化的布局，首选使用前面提到的<code>layout</code>修饰符或 <strong>Layout</strong> 组件来自定义布局，而非 <strong>BoxWithConstraints</strong> 。只有在信息内容的类型会随着大小变化时才推荐使用<strong>BoxWithConstraints</strong> 。</p>
<p>如果要深究一下 <strong>BoxWithConstraints</strong> 为啥能将<strong>组合</strong>延迟到<strong>布局</strong>阶段，只需要点开它的源码看一眼就会发现，它的内部是基于 <strong>SubcomposeLayout</strong> 实现的：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/16534ff94d95a5535023233f4b29c6d8.png" alt="在这里插入图片描述"></p>
<p>前面提到过 <strong>SubcomposeLayout</strong> 的超能力就是能将某个子组件的组合阶段延迟到依赖的其他组件的测量阶段之后进行，因此 <strong>BoxWithConstraints</strong> 只不过是 <strong>SubcomposeLayout</strong> 的一个套壳而已。它只是简单的对传入的 <code>content</code> Composable 调用了 <code>subcompose</code> 启动子组合，同时为 <code>content</code> 添加了一个 Receiver，而通过该 Receiver 对象你能够访问到父组件的 <code>constraints</code> 对象的信息。</p>
<h3 id="LookaheadLayout-超前测量"><a href="#LookaheadLayout-超前测量" class="headerlink" title="LookaheadLayout 超前测量"></a>LookaheadLayout 超前测量</h3><p><strong>LookaheadLayout</strong> 的能力和 <strong>Intrinsic</strong> 固有特性测量有点类似，它也可以提前获取子组件的测量信息，但是貌似官方提供该组件的主要目的是为了<strong>动画</strong>专供。使用它你可以实现一些比较fashion的动画效果。</p>
<p>为什么说是<strong>动画</strong>专供，比如这样一种场景：我想在当前组件显示的尺寸大小的基础之上，通过动画渐变的方式逐渐变化到另一个尺寸大小。很明显，这是需要从一个<strong>初始值</strong>过渡到一个<strong>目标值</strong>，假如我们使用<code>animate*AsState</code> 或者<code>Animatable</code>动画API（当然也可以选择其他的API，这不是重点），那么问题来了，这里的<strong>初始值</strong>是指组件开始显示的尺寸大小，那么我们如何一上来就能获取到<strong>组件的初始大小</strong>呢？显然，这也是一个需要<strong>解除Compose禁止多次测量的魔咒</strong>的方法，那么跟<strong>Intrinsic</strong> 的情况其实就有一定的类似了，官方提供的 <strong>LookaheadLayout</strong> 主要是来做这件事的。</p>
<p>通过 <strong>LookaheadLayout</strong> 布局，你可以对子组件进行<strong>两次</strong>测量和布局（解除只能1次测量的魔咒），它会先进行一次叫做<strong>前瞻性</strong>的或者叫<strong>超前</strong>的测量和布局，随后紧接着它会再进行一次<strong>真正</strong>的测量和布局。在<strong>前瞻性</strong>的测量和布局阶段之后，它就获得了子组件的尺寸信息，然后在<strong>真正</strong>的测量和布局阶段，你就可以通过 <code>LookaheadLayoutScope</code> 作用域的 <code>Modifier.intermediateLayout</code> 修饰符提供的 <code>lookaheadSize</code> 参数来获取到子组件的<strong>初始化大小</strong>。其中在<strong>前瞻性</strong>的测量阶段中并不会执行 <code>Modifier.intermediateLayout</code> 中的测量逻辑，只有在真正测量阶段才会调用，这是其特意为之。（注意：官方目前 API中标注 <code>SubcomposeLayout</code>目前还不支持<code>LookaheadLayout</code>）</p>
<p>使用 <strong>LookaheadLayout</strong> 需要提供三个参数：<code>content</code> 就是子组件的内容，<code>modifier</code> 以及 <code>measurePolicy</code>。其实跟 <strong>Layout</strong> 组件的使用类似，也需要覆写 <code>measurePolicy</code> 的<code>measure</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LookaheadLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> @<span class="type">UiComposable</span> <span class="type">LookaheadLayoutScope</span>.() -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> </span><br></pre></td></tr></table></figure>

<p>直接看一个例子（也是官方的例子）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LookaheadLayoutSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        LookaheadLayout(</span><br><span class="line">            content = &#123;</span><br><span class="line">                <span class="keyword">val</span> lookaheadScope = <span class="keyword">this</span></span><br><span class="line">                <span class="keyword">var</span> useFullWidth <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">                Row(</span><br><span class="line">                    Modifier.then(<span class="keyword">if</span> (useFullWidth) Modifier.fillMaxWidth() <span class="keyword">else</span> Modifier.width(<span class="number">200.</span>dp))</span><br><span class="line">                        .height(<span class="number">200.</span>dp)</span><br><span class="line">                        <span class="comment">// 这里使用自定义的修饰符来以动画的方式改变要传递给child的constraints约束信息</span></span><br><span class="line">                        <span class="comment">// 因此child的大小改变会以一个动画效果呈现。</span></span><br><span class="line">                        .animateConstraints(lookaheadScope)</span><br><span class="line">                        .clickable &#123; useFullWidth = !useFullWidth &#125;</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Box(Modifier.weight(<span class="number">1f</span>).fillMaxHeight().background(Color.Red))</span><br><span class="line">                    Box(Modifier.weight(<span class="number">2f</span>).fillMaxHeight().background(Color.Blue))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ) &#123; measurables, constraints -&gt;</span><br><span class="line">            <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(constraints) &#125;</span><br><span class="line">            <span class="keyword">val</span> maxWidth = placeables.maxOf &#123; it.width &#125;</span><br><span class="line">            <span class="keyword">val</span> maxHeight = placeables.maxOf &#123; it.height &#125;</span><br><span class="line">            <span class="comment">// Position the children.</span></span><br><span class="line">            layout(maxWidth, maxHeight) &#123;</span><br><span class="line">                placeables.forEach &#123; it.place(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自定义修饰符，该修饰符使约束动画化，并使用该约束测量子元素。</span></span><br><span class="line"><span class="comment">// 它构建在 Modifier.intermediateLayout 之上，允许访问布局的目标大小。并以动画的形式将组件的尺寸调整到目标大小。</span></span><br><span class="line"><span class="comment">// 基于动画值创建的固定约束将用于测量子元素，以便所有的child逐渐改变它们的大小以适应动画约束。</span></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">animateConstraints</span><span class="params">(lookaheadScope: <span class="type">LookaheadLayoutScope</span>)</span></span> = composed &#123;</span><br><span class="line">    <span class="keyword">var</span> sizeAnimation <span class="keyword">by</span> remember &#123; mutableStateOf&lt;Animatable&lt;IntSize, AnimationVector2D&gt;?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> targetSize <span class="keyword">by</span> remember &#123; mutableStateOf&lt;IntSize?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        snapshotFlow &#123; targetSize &#125;.collect &#123; target -&gt;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; target != sizeAnimation?.targetValue) &#123;</span><br><span class="line">                sizeAnimation?.run &#123; launch &#123; animateTo(target) &#125; &#125;</span><br><span class="line">                <span class="keyword">if</span> (sizeAnimation == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sizeAnimation = Animatable(target, IntSize.VectorConverter)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    with(lookaheadScope) &#123;</span><br><span class="line">        <span class="comment">// intermediateLayout 中的测量逻辑会在超前测量阶段中被跳过, 因为 intermediateLayout 会在布局过程中产生中间阶段。</span></span><br><span class="line">        <span class="comment">// 当 measure 方法的 block 代码块在超前测量阶段之后被调用时，可以通过其 lookaheadSize 参数获取到在超前测量阶段的child的尺寸大小</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@composed</span>.intermediateLayout &#123; measurable, _, lookaheadSize -&gt;</span><br><span class="line">            <span class="comment">// 当布局改变时，超前测量阶段将为子元素的修饰符计算一个新的最终大小。</span></span><br><span class="line">            <span class="comment">// 这个前瞻大小可以用来做大小改变的动画，这样动画可以从当前大小开始，逐渐变化到 lookaheadSize。</span></span><br><span class="line">            targetSize = lookaheadSize</span><br><span class="line">            <span class="comment">// 如果动画已设置，则读取当前动画的状态值，否则(例如第一帧被执行时)就使用没有动画效果的lookaheadSize。</span></span><br><span class="line">            <span class="keyword">val</span> (width, height) = sizeAnimation?.value ?: lookaheadSize</span><br><span class="line">            <span class="comment">// 使用当前动画的状态值来创建一个固定宽高的约束</span></span><br><span class="line">            <span class="keyword">val</span> animatedConstraints = Constraints.fixed(width, height)</span><br><span class="line">            <span class="comment">// 并使用该约束来测量 child/children</span></span><br><span class="line">            <span class="keyword">val</span> placeable = measurable.measure(animatedConstraints)</span><br><span class="line">            layout(placeable.width, placeable.height) &#123;</span><br><span class="line">                placeable.place(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，它的子组件的测量约束信息跟当前动画的状态值有关，而当前动画的状态值的初始值就是通过超前测量之后获得的 <code>lookaheadSize</code> 来设置的，也就是说在第一帧显示的时候，它初始化动画API的值就是子组件的大小。而在点击之后，Row的宽度改变，触发重组，再次进行超前测量，随后在真正测量阶段<code>targetSize</code>被更新成新的<code>lookaheadSize</code>，因此 <code>snapshotFlow &#123; targetSize &#125;</code>收集的值会发生变化，进而触发<code>Animatable</code>的 <code>animateTo(target)</code> 方法被执行，那么当前动画的状态值开始变化，而<code>intermediateLayout</code>中依赖动画状态值的约束信息就被不断的更新，最终用该约束信息测量的子组件的尺寸大小就不断变化。</p>
<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/24febbce1b51e1ed62507404606b7476.gif" alt="在这里插入图片描述"></p>
<p><strong>LookaheadLayout</strong> 除了可以前瞻性的获取尺寸信息，还可以前瞻性的获取<strong>位置</strong>信息， <code>LookaheadLayoutScope</code> 作用域的 <code>Modifier.onPlaced</code> 修饰符提供了这一能力，该修饰符的lambda中提供了两个参数 <code>lookaheadScopeCoordinates</code> 和 <code>layoutCoordinates</code>分别表示当前LookaheadLayout的坐标信息，以及应用当前modifier的组件的坐标信息，并提供了两个方法<code>lookaheadScopeCoordinates.localLookaheadPositionOf(layoutCoordinates)</code> 和 <code>lookaheadScopeCoordinates.localPositionOf(layoutCoordinates, Offset.Zero)</code>，能分别获取到前瞻性的位置和当前的位置信息（相对于父组件LookaheadLayout），随后就能在 <code>intermediateLayout</code> 中基于这些信息使用动画。</p>
<p>下面是官方的一个使用示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LookaheadLayoutCoordinatesSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> colors = listOf(</span><br><span class="line">        Color(<span class="number">0xffff6f69</span>), Color(<span class="number">0xffffcc5c</span>), Color(<span class="number">0xff264653</span>), Color(<span class="number">0xff2a9d84</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 创建包含4个Box的可移动内容。它们将被放在[Row]或[Column]中，这取决于状态</span></span><br><span class="line">    <span class="keyword">val</span> items = remember &#123;</span><br><span class="line">        movableContentWithReceiverOf&lt;LookaheadLayoutScope&gt; &#123;</span><br><span class="line">            colors.forEach &#123; color -&gt;</span><br><span class="line">                Box(Modifier.padding(<span class="number">15.</span>dp).size(<span class="number">100.</span>dp, <span class="number">80.</span>dp)</span><br><span class="line">                        .animatePlacement(<span class="keyword">this</span>)</span><br><span class="line">                        .background(color, RoundedCornerShape(<span class="number">20</span>))</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> isInColumn <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">true</span>) &#125;</span><br><span class="line">    LookaheadLayout(</span><br><span class="line">        content = &#123;</span><br><span class="line">            <span class="comment">// 当items在Column和Row之间移动时，它们在lookheadlayout中的位置将发生变化。</span></span><br><span class="line">            <span class="comment">// 自定义的 animatePlacement 修饰器将通过 localLookaheadPositionOf 观察到最终的位置变化，并创建一个位置动画。</span></span><br><span class="line">            <span class="keyword">if</span> (isInColumn) &#123;</span><br><span class="line">                Column &#123; items() &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Row &#123; items() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        modifier = Modifier.fillMaxSize().clickable &#123; isInColumn = !isInColumn &#125;</span><br><span class="line">    ) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(constraints) &#125;</span><br><span class="line">        <span class="keyword">val</span> maxWidth: <span class="built_in">Int</span> = placeables.maxOf &#123; it.width &#125;</span><br><span class="line">        <span class="keyword">val</span> maxHeight = placeables.maxOf &#123; it.height &#125;</span><br><span class="line">        <span class="comment">// Position the children.</span></span><br><span class="line">        layout(maxWidth, maxHeight) &#123;</span><br><span class="line">            placeables.forEach &#123; it.place(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个自定义修饰符，每当布局发生变化时, 通过动画方式改变LookaheadLayout中布局的位置</span></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">animatePlacement</span><span class="params">(lookaheadScope: <span class="type">LookaheadLayoutScope</span>)</span></span> = composed &#123;</span><br><span class="line">    <span class="keyword">var</span> offsetAnimation <span class="keyword">by</span> remember &#123; mutableStateOf&lt;Animatable&lt;IntOffset, AnimationVector2D&gt;?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> placementOffset <span class="keyword">by</span> remember &#123; mutableStateOf(IntOffset.Zero) &#125;</span><br><span class="line">    <span class="keyword">var</span> targetOffset <span class="keyword">by</span> remember &#123; mutableStateOf&lt;IntOffset?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        snapshotFlow &#123; targetOffset &#125;.collect &#123; target -&gt;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; target != offsetAnimation?.targetValue) &#123;</span><br><span class="line">                offsetAnimation?.run &#123; launch &#123; animateTo(target) &#125; &#125;</span><br><span class="line">                <span class="keyword">if</span> (offsetAnimation == <span class="literal">null</span>) &#123;</span><br><span class="line">                    offsetAnimation = Animatable(target, IntOffset.VectorConverter)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    with(lookaheadScope) &#123; </span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@composed</span></span><br><span class="line">        .onPlaced &#123; lookaheadScopeCoordinates, layoutCoordinates -&gt;  <span class="comment">// 重新摆放时被调用</span></span><br><span class="line">            <span class="comment">// block中第一个参数是当前LookaheadLayout的坐标信息，第二个参数是应用当前modifier的组件的坐标信息</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// localLookaheadPositionOf 返回当前modifier在LookaheadLayout局部坐标系中的目标位置</span></span><br><span class="line">            targetOffset = lookaheadScopeCoordinates.localLookaheadPositionOf(layoutCoordinates).round()</span><br><span class="line">            <span class="comment">// localPositionOf 返回当前modifier在LookaheadLayout局部坐标系中的当前位置</span></span><br><span class="line">            placementOffset = lookaheadScopeCoordinates.localPositionOf(layoutCoordinates, Offset.Zero).round()</span><br><span class="line">        &#125;</span><br><span class="line">        .intermediateLayout &#123; measurable, constraints, _ -&gt;</span><br><span class="line">            <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">            layout(placeable.width, placeable.height) &#123;</span><br><span class="line">                <span class="comment">// 每当目标位置发生变化时，offsetAnimation将使目标位置动画化。</span></span><br><span class="line">                <span class="comment">// 为了将子元素放在动画位置，我们需要基于LookaheadLayout中的目标位置和当前位置来偏移子元素。</span></span><br><span class="line">                <span class="keyword">val</span> (x, y) = offsetAnimation?.run &#123; value - placementOffset &#125;</span><br><span class="line">                    ?: (targetOffset!! - placementOffset) <span class="comment">// 如果offsetAnimation还没有设置(即在第一帧中)，跳过动画</span></span><br><span class="line">                placeable.place(x, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1043513e0ea22dc024d3e7c7d24592c5.gif" alt="在这里插入图片描述"></p>
<p>在这个例子中，子组件被摆放的位置信息跟当前基于偏移量动画的状态值有关。在初始时，会进行一次前瞻性测量，这会在<code>onPlaced</code>回调中更新<code>targetOffset</code> 的值，那么<code>snapshotFlow &#123; targetOffset &#125;</code>收集的值变化，在其<code>collect</code>方法中，就会以该值初始化偏移量动画<code>offsetAnimation</code>。随后在点击时，<code>items</code>会在Column和Row之间移动，它们在<code>lookheadlayout</code>中的位置将发生变化，LookaheadLayout又会进行前瞻性测量，在<code>onPlaced</code>回调中，就可以通过 <code>lookaheadScopeCoordinates.localLookaheadPositionOf</code> 观测到最终的变化位置，并将该最终位置更新给 <code>targetOffset</code> ，这会再次触发<code>snapshotFlow &#123; targetOffset &#125;</code>的<code>collect</code>方法，这时偏移量动画<code>offsetAnimation</code>的<code>animateTo(target)</code>，这会导致当前位置信息会渐变到target值。而 <code>placeable.place(x, y)</code> 依赖偏移量动画<code>offsetAnimation</code>的当前状态值，因此位置就会逐渐变化。</p>
<p>可能还是感觉不是很好理解，可以看下图：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c12c4b459cf8972eea936924d73a2f12.png" alt="在这里插入图片描述"></p>
<p>以第二个黄色方块为例，点击时，它从Column中跑到Row中，在前瞻性测量阶段，可以拿到其在父组件中的目标位置是<code>(380, 39)</code>，而此时<code>offsetAnimation</code>动画的初始值还处在初始化时设置的 <code>(39, 327)</code>, 因此动画就会从 <code>(39, 327)</code> 坐标向 <code>(380, 39)</code> 坐标位置变化，而 <code>placeable.place(x, y)</code> 这个方法如果最终要摆放的组件位置没有偏移，那么x和y应该都是0，也就是 <code>placeable.place(0, 0)</code>，因此 <code>(x, y)</code> 的变化范围就是从某一个值变化到 <code>(0, 0)</code> ，因此需要拿动画当前值和目标值作差，得出 <code>(-341, 288)</code> ，则 <code>(x, y)</code> 的变化就是从 <code>(-341, 288)</code> 变化到 <code>(0, 0)</code> 。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/33f1782047347a0e07e43cde0da85adc.png" alt="在这里插入图片描述"></p>
<p>上面两个例子看不出使用LookaheadLayout有什么特别的值得哇塞的效果，下面再看一个例子。下面代码中利用前面的代码稍加修改，实现了一个在列表页面和详情页面之间的共享元素动画效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LookaheadLayoutShareAnimationExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isSmall <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">true</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> clickIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> headImages = remember &#123;</span><br><span class="line">        List(<span class="number">6</span>) &#123; index -&gt;</span><br><span class="line">            movableContentWithReceiverOf&lt;LookaheadLayoutScope&gt; &#123;</span><br><span class="line">                Box(Modifier</span><br><span class="line">                    .size(<span class="keyword">if</span> (isSmall) <span class="number">50.</span>dp <span class="keyword">else</span> <span class="number">250.</span>dp)</span><br><span class="line">                    .shareAnimation(<span class="keyword">this</span>, isSmall)</span><br><span class="line">                    .clickable &#123;</span><br><span class="line">                        isSmall = !isSmall</span><br><span class="line">                        clickIndex = index</span><br><span class="line">                    &#125;</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Image(painter = painterResource(id = R.drawable.ic_head), contentDescription = <span class="literal">null</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleLookaheadLayout &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSmall) &#123;</span><br><span class="line">            ListScreen(headImages) &#123; clickedIndex -&gt;</span><br><span class="line">                isSmall = !isSmall</span><br><span class="line">                clickIndex = clickedIndex</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DetailScreen(headImages[clickIndex])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SimpleLookaheadLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">LookaheadLayoutScope</span>.() -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    LookaheadLayout(content = content, modifier = modifier) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; it.measure(constraints) &#125;</span><br><span class="line">        <span class="keyword">val</span> maxWidth = placeables.maxOf &#123; it.width &#125;</span><br><span class="line">        <span class="keyword">val</span> maxHeight = placeables.maxOf &#123; it.height &#125;</span><br><span class="line">        layout(maxWidth, maxHeight) &#123;</span><br><span class="line">            placeables.forEach &#123; it.place(<span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> LookaheadLayoutScope.<span class="title">ListScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    headImages: <span class="type">List</span>&lt;@<span class="type">Composable</span> (<span class="type">LookaheadLayoutScope</span>.() -&gt; <span class="type">Unit</span>)&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onItemClick: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Column(Modifier.fillMaxSize()) &#123;</span><br><span class="line">        headImages.forEachIndexed &#123; index, headImage -&gt;</span><br><span class="line">            Spacer(Modifier.height(<span class="number">5.</span>dp))</span><br><span class="line">            Row(Modifier.padding(<span class="number">8.</span>dp).clickable &#123; onItemClick(index) &#125;) &#123;</span><br><span class="line">                headImage()</span><br><span class="line">                Spacer(Modifier.width(<span class="number">10.</span>dp))</span><br><span class="line">                Text(<span class="string">&quot;<span class="variable">$index</span> &quot;</span> + <span class="string">&quot;简介&quot;</span>.repeat(<span class="number">15</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            Spacer(Modifier.height(<span class="number">5.</span>dp))</span><br><span class="line">            Divider()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> LookaheadLayoutScope.<span class="title">DetailScreen</span><span class="params">(headImage: @<span class="type">Composable</span> (<span class="type">LookaheadLayoutScope</span>.() -&gt; <span class="type">Unit</span>))</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        Modifier.fillMaxSize(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">        verticalArrangement = Arrangement.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        headImage()</span><br><span class="line">        Spacer(Modifier.height(<span class="number">10.</span>dp))</span><br><span class="line">        Divider()</span><br><span class="line">        Spacer(Modifier.height(<span class="number">10.</span>dp))</span><br><span class="line">        Text(<span class="string">&quot;详情&quot;</span>.repeat(<span class="number">200</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">shareAnimation</span><span class="params">(lookaheadScope: <span class="type">LookaheadLayoutScope</span>, isSmall: <span class="type">Boolean</span> = <span class="literal">true</span>)</span></span> = composed &#123;</span><br><span class="line">    <span class="keyword">var</span> offsetAnimation <span class="keyword">by</span> remember &#123; mutableStateOf&lt;Animatable&lt;IntOffset, AnimationVector2D&gt;?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> placementOffset <span class="keyword">by</span> remember &#123; mutableStateOf(IntOffset.Zero) &#125;</span><br><span class="line">    <span class="keyword">var</span> targetOffset <span class="keyword">by</span> remember &#123; mutableStateOf&lt;IntOffset?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        snapshotFlow &#123; targetOffset &#125;.collect &#123; target -&gt;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; target != offsetAnimation?.targetValue) &#123;</span><br><span class="line">                offsetAnimation?.run &#123; launch &#123; animateTo(target) &#125; &#125;</span><br><span class="line">                <span class="keyword">if</span> (offsetAnimation == <span class="literal">null</span>) &#123;</span><br><span class="line">                    offsetAnimation = Animatable(target, IntOffset.VectorConverter)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> sizeAnimation <span class="keyword">by</span> remember &#123; mutableStateOf&lt;Animatable&lt;IntSize, AnimationVector2D&gt;?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> targetSize <span class="keyword">by</span> remember &#123; mutableStateOf&lt;IntSize?&gt;(<span class="literal">null</span>) &#125;</span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        snapshotFlow &#123; targetSize &#125;.collect &#123; target -&gt;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; target != sizeAnimation?.targetValue) &#123;</span><br><span class="line">                sizeAnimation?.run &#123; launch &#123; animateTo(target) &#125; &#125;</span><br><span class="line">                <span class="keyword">if</span> (sizeAnimation == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sizeAnimation = Animatable(target, IntSize.VectorConverter)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> maxPercent = <span class="number">50</span></span><br><span class="line">    <span class="keyword">val</span> minPercent = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> cornerPercent <span class="keyword">by</span> remember &#123; mutableStateOf(maxPercent) &#125;</span><br><span class="line">    <span class="keyword">val</span> cornerPercentAnimation = remember &#123; Animatable(maxPercent, <span class="built_in">Int</span>.VectorConverter) &#125;</span><br><span class="line">    cornerPercent = <span class="keyword">if</span> (isSmall) maxPercent <span class="keyword">else</span> minPercent</span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        snapshotFlow &#123; cornerPercent &#125;.collect &#123; target -&gt;</span><br><span class="line">            <span class="keyword">if</span> (target != cornerPercentAnimation.targetValue) &#123;</span><br><span class="line">                launch &#123; cornerPercentAnimation.animateTo(target) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    with(lookaheadScope) &#123;</span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@composed</span></span><br><span class="line">            .onPlaced &#123; lookaheadScopeCoordinates, layoutCoordinates -&gt;</span><br><span class="line">                targetOffset = lookaheadScopeCoordinates</span><br><span class="line">                    .localLookaheadPositionOf(layoutCoordinates).round()</span><br><span class="line">                placementOffset = lookaheadScopeCoordinates</span><br><span class="line">                    .localPositionOf(layoutCoordinates, Offset.Zero).round()</span><br><span class="line">            &#125;</span><br><span class="line">            .intermediateLayout &#123; measurable, constraints, lookaheadSize -&gt;</span><br><span class="line">                targetSize = lookaheadSize</span><br><span class="line">                <span class="keyword">val</span> (width, height) = sizeAnimation?.value ?: lookaheadSize</span><br><span class="line">                <span class="keyword">val</span> animatedConstraints = Constraints.fixed(width, height)</span><br><span class="line">                <span class="keyword">val</span> placeable = measurable.measure(animatedConstraints)</span><br><span class="line">                layout(placeable.width, placeable.height) &#123;</span><br><span class="line">                    <span class="keyword">val</span> (x, y) = offsetAnimation?.run &#123; value - placementOffset &#125;</span><br><span class="line">                        ?: (targetOffset!! - placementOffset)</span><br><span class="line">                    placeable.place(x, y)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .clip(RoundedCornerShape(cornerPercentAnimation.value))</span><br><span class="line">            .border(<span class="number">1.</span>dp, Color.Red, RoundedCornerShape(cornerPercentAnimation.value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/048badc6ebd0c8b7f899e7a26c543d62.gif" alt="在这里插入图片描述"></p>
<p>注意，上面代码中每个列表项中的头像和其详情页面的头像其实是同一个元素，因此需要执行6次<code>movableContentWithReceiverOf</code>，创建6个共享头像，为每一个列表项和对应详情页面分配一个共享头像，这样点击的时候才会从对应列表项的小头像放大到对应详情页的大头像，再次点击大头像的时候会返回点击的列表项位置。如果只创建一个共享头像，则所有列表项都会共用这一个，效果是放大之后再次点击会全部缩小到第一个列表项中。</p>
<h4 id="LookaheadLayout-小结"><a href="#LookaheadLayout-小结" class="headerlink" title="LookaheadLayout 小结"></a>LookaheadLayout 小结</h4><p>相对于前面提到的组件，<strong>LookaheadLayout</strong> 是我至今发现的使用方式最复杂的一个了，但是它能实现的动画效果相当不错。下面总结一下 <strong>LookaheadLayout</strong> 使用的大概流程：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f6ee78b61662a757372aef623cf09193.png" alt="在这里插入图片描述"></p>
<h3 id="自定义对齐线"><a href="#自定义对齐线" class="headerlink" title="自定义对齐线"></a>自定义对齐线</h3><p>Compose中提供了一个默认的 <code>Modifier.alignByBaseline()</code> 对齐线修饰符，可以用来做组件的基线对齐效果，该修饰符的效果可以透传父组件中。</p>
<p>例如，下面是一个应用 <code>Modifier.alignByBaseline()</code> 的简单例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true, heightDp = 200, widthDp = 250)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">AlignmentBasicExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">        verticalArrangement = Arrangement.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Row &#123;</span><br><span class="line">            Text(<span class="string">&quot;Jetpack &quot;</span>)</span><br><span class="line">            Button(onClick = &#123;&#125;) &#123; Text(<span class="string">&quot;Compose&quot;</span>, color = Color.White) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Spacer(Modifier.height(<span class="number">20.</span>dp))</span><br><span class="line">        Row &#123;</span><br><span class="line">            Text(<span class="string">&quot;Jetpack &quot;</span>, modifier = Modifier.alignByBaseline())</span><br><span class="line">            Button(onClick = &#123;&#125;, modifier = Modifier.alignByBaseline()) &#123;</span><br><span class="line">                Text(<span class="string">&quot;Compose&quot;</span>, color = Color.White)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预览效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3e0fb5f7aa79ab422986adf7328dbd22.png" alt="在这里插入图片描述"></p>
<p>可以看到如果不使用对齐线，默认 <strong>Row</strong> 组件中的 <strong>Text</strong> 文本和 <strong>Button</strong> 组件中的 <strong>Text</strong> 文本是不会自动对齐的，当对 <strong>Button</strong> 组件使用对齐线以后，<strong>Button</strong> 组件会从它的子组件 <strong>Text</strong> 来获取对齐线，因此对齐线透传到了 <strong>Row</strong> 组件中，两个文本便被对齐。</p>
<p>再来看下面这样一个场景，我想让下面的卡片中的红心按钮与它左侧的文本基线对齐，如下图所示：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/32b525175b22be09ad067ce28245ed44.png" alt="在这里插入图片描述"></p>
<p>我们可以这样来实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">UserCard</span><span class="params">(title: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Row(</span><br><span class="line">        modifier = Modifier.padding(all = <span class="number">8.</span>dp),</span><br><span class="line">        verticalAlignment = Alignment.CenterVertically</span><br><span class="line">    ) &#123;</span><br><span class="line">        Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.ic_doctor_strange),</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(<span class="number">80.</span>dp)</span><br><span class="line">                .clip(RoundedCornerShape(<span class="number">15</span>)),</span><br><span class="line">            contentScale = ContentScale.Crop,</span><br><span class="line">            contentDescription = <span class="string">&quot;head&quot;</span></span><br><span class="line">        )</span><br><span class="line">        Spacer(Modifier.width(<span class="number">8.</span>dp))</span><br><span class="line">        <span class="keyword">var</span> isExpanded <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">        Column(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .weight(<span class="number">1f</span>)</span><br><span class="line">                .clickable &#123; isExpanded = !isExpanded &#125;</span><br><span class="line">        )&#123;</span><br><span class="line">            Text(text = title, color = Color.Black, fontSize = <span class="number">18.</span>sp)</span><br><span class="line">            Spacer(Modifier.height(<span class="number">15.</span>dp))</span><br><span class="line">            Row(horizontalArrangement = Arrangement.SpaceBetween) &#123;</span><br><span class="line">                Text(</span><br><span class="line">                    text = msg,</span><br><span class="line">                    fontSize = <span class="number">16.</span>sp,</span><br><span class="line">                    maxLines = <span class="keyword">if</span> (isExpanded) <span class="built_in">Int</span>.MAX_VALUE <span class="keyword">else</span> <span class="number">1</span>,</span><br><span class="line">                    modifier = Modifier</span><br><span class="line">                        .weight(<span class="number">1f</span>)</span><br><span class="line">                        .alignByBaseline()</span><br><span class="line">                )</span><br><span class="line">                Row(</span><br><span class="line">                    modifier = Modifier</span><br><span class="line">                        .padding(start = <span class="number">8.</span>dp, end = <span class="number">8.</span>dp)</span><br><span class="line">                        .alignByBaseline()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Icon(</span><br><span class="line">                        imageVector = Icons.Filled.Favorite,</span><br><span class="line">                        contentDescription = <span class="literal">null</span>,</span><br><span class="line">                        tint = Color.Red,</span><br><span class="line">                        modifier = Modifier.size(<span class="number">18.</span>dp)</span><br><span class="line">                    )</span><br><span class="line">                    Text(<span class="string">&quot;65663&quot;</span>, modifier = Modifier.padding(start = <span class="number">5.</span>dp), fontSize = <span class="number">13.</span>sp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Preview(heightDp = 200, widthDp = 500)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">AlignmentExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .background(Color.Cyan),</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Surface(</span><br><span class="line">            shape = RoundedCornerShape(<span class="number">15</span>),</span><br><span class="line">            shadowElevation = <span class="number">1.5</span>.dp,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .padding(all = <span class="number">8.</span>dp)</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .wrapContentHeight(),</span><br><span class="line">        )&#123; </span><br><span class="line">            UserCard(</span><br><span class="line">                title = <span class="string">&quot;The Avengers&quot;</span>,</span><br><span class="line">                msg = <span class="string">&quot;This is the only way we can beat Thanos!&quot;</span>.repeat(<span class="number">3</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/413b1d89403677040c40b7e47a7e89b2.gif" alt="在这里插入图片描述"></p>
<p>但是我们发现，当文本展开显示多行以后，右侧收藏按钮会跟随文本跑到上面去。假如我想让收藏按钮始终保留在卡片的底部且与文本的基线对齐该怎么办？此时可以使用另一个比较有用的修饰符 <code>Modifier.alignBy&#123; &#125;</code>，<code>alignBy</code> 的 lambda block 中会传入一个 <code>Measured</code> 对象，通过该对象可以获取到当前组件已测量的宽度和高度值，然后你可以选择以哪个值为标准进行对齐。修改上面的部分代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">UserCard</span><span class="params">(title: <span class="type">String</span>, msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Row(...) &#123;</span><br><span class="line">        Image(...)</span><br><span class="line">        Column(...) &#123;</span><br><span class="line">            Text(...) </span><br><span class="line">            Row(...) &#123;</span><br><span class="line">                Text(...</span><br><span class="line">                    modifier = Modifier.weight(<span class="number">1f</span>) </span><br><span class="line">                        .alignBy &#123; it.measuredHeight &#125;</span><br><span class="line">                )</span><br><span class="line">                Row(</span><br><span class="line">                    modifier = Modifier.padding(...) </span><br><span class="line">                        .alignBy &#123; it.measuredHeight &#125;</span><br><span class="line">                ) &#123;</span><br><span class="line">                   ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/385c3ff1937b5216b4db481e22538956.gif" alt="在这里插入图片描述"></p>
<p>需要注意的是， <code>Modifier.alignByBaseline()</code> 只能在<code>RowScope</code>中使用，而 <code>Modifier.alignBy&#123; &#125;</code> 系列可以在 <code>RowScope</code> 和 <code>ColumnScope</code> 中使用，在其他组件中是没有办法使用这两个修饰符的。</p>
<h4 id="创建自定义对齐线"><a href="#创建自定义对齐线" class="headerlink" title="创建自定义对齐线"></a>创建自定义对齐线</h4><p>除了上面提到的两个修饰符可以直接使用外，官方也为我们提供了一个创建自定义对齐线的示例。</p>
<p>以下示例展示了一个自定义 <strong>BarChart</strong> 可组合项，它公开了两条对齐线：<strong>MaxChartValue</strong> 和 <strong>MinChartValue</strong>；这样，其他可组合项就可以对齐到图表的最大和最小数据值。两个文本元素“<code>Max</code>”和“<code>Min</code>” 可以与自定义对齐线的中心对齐。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a6098498fab66b8a5bf3104594196611.png" alt="在这里插入图片描述"><br>自定义对齐线被定义为项目中的顶级变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.layout.HorizontalAlignmentLine</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由[BarChart]中的最大数据值定义的AlignmentLine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> MaxChartValue = HorizontalAlignmentLine(merger = &#123; old, new -&gt; min(old, new) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由[BarChart]中的最小数据值定义的AlignmentLine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> MinChartValue = HorizontalAlignmentLine(merger = &#123; old, new -&gt; max(old, new) &#125;)</span><br></pre></td></tr></table></figure>

<p>我们的示例中用到的自定义对齐线属于 <code>HorizontalAlignmentLine</code> 类型，因为它们用于垂直对齐子项。如果多个布局为这些对齐线提供了一个值，系统就会以参数的形式传递合并政策。由于 <code>Compose</code> 布局坐标系和 <code>Canvas</code> 坐标系都以 <code>[0, 0]</code>代表左上角，并且 <code>x</code> 轴和 <code>y</code> 轴的正方向都是向下的，因此 <code>MaxChartValue</code> 值将始终小于 <code>MinChartValue</code>。因此，对于最大图表数据值基线，合并策略为 <code>min</code>；对于最小图表数据值基线，合并策略为 <code>max</code>。</p>
<p>在创建自定义 <code>Layout</code> 或 <code>LayoutModifier</code> 时，请在接收 <code>alignmentLines: Map&lt;AlignmentLine, Int&gt;</code> 参数的 <code>MeasureScope.layout() &#123; &#125;</code> 方法中指定自定义对齐线。</p>
<p><strong>BarChart</strong> 的完整代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由[BarChart]中的最大数据值定义的AlignmentLine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> MaxChartValue = HorizontalAlignmentLine(merger = &#123; old, new -&gt; min(old, new) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由[BarChart]中的最小数据值定义的AlignmentLine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> MinChartValue = HorizontalAlignmentLine(merger = &#123; old, new -&gt; max(old, new) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">BarChart</span><span class="params">(dataPoints: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> maxValue: <span class="built_in">Float</span> = remember(dataPoints) &#123; dataPoints.maxOrNull()!! * <span class="number">1.2f</span> &#125;</span><br><span class="line"></span><br><span class="line">    BoxWithConstraints(modifier = modifier) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Omit the content block for the code snippets in DAC</span></span><br><span class="line">        <span class="keyword">val</span> density = LocalDensity.current</span><br><span class="line">        with(density) &#123;</span><br><span class="line">            <span class="keyword">val</span> yPositionRatio = remember(density, maxHeight, maxValue) &#123;</span><br><span class="line">                maxHeight.toPx() / maxValue</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> xPositionRatio = remember(density, maxWidth, dataPoints) &#123;</span><br><span class="line">                maxWidth.toPx() / (dataPoints.size + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 图中的中心点</span></span><br><span class="line">            <span class="keyword">val</span> xOffset = remember(density) &#123; xPositionRatio / dataPoints.size &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算自定义的对齐线 minYBaseline 和 maxYBaseline 的位置 </span></span><br><span class="line">            <span class="keyword">val</span> maxYBaseline = remember(dataPoints) &#123;</span><br><span class="line">                dataPoints.maxOrNull()?.let &#123; (maxValue - it) * yPositionRatio &#125; ?: <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> minYBaseline = remember(dataPoints) &#123;</span><br><span class="line">                dataPoints.minOrNull()?.let &#123; (maxValue - it) * yPositionRatio &#125; ?: <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line">            Layout(content = &#123;&#125;, modifier = Modifier.drawBehind &#123;</span><br><span class="line">                dataPoints.forEachIndexed &#123; index, dataPoint -&gt;</span><br><span class="line">                    <span class="keyword">val</span> rectSize = Size(<span class="number">60f</span>, dataPoint * yPositionRatio)</span><br><span class="line">                    <span class="keyword">val</span> topLeftOffset = Offset(</span><br><span class="line">                        x = xPositionRatio * (index + <span class="number">1</span>) - xOffset,</span><br><span class="line">                        y = (maxValue - dataPoint) * yPositionRatio</span><br><span class="line">                    )</span><br><span class="line">                    drawRect(Color(<span class="number">0xFF3DDC84</span>), topLeftOffset, rectSize)</span><br><span class="line">                &#125;</span><br><span class="line">                drawLine(</span><br><span class="line">                    Color(<span class="number">0xFF073042</span>),</span><br><span class="line">                    start = Offset(<span class="number">0f</span>, <span class="number">0f</span>),</span><br><span class="line">                    end = Offset(<span class="number">0f</span>, maxHeight.toPx()),</span><br><span class="line">                    strokeWidth = <span class="number">6f</span></span><br><span class="line">                )</span><br><span class="line">                drawLine(</span><br><span class="line">                    Color(<span class="number">0xFF073042</span>),</span><br><span class="line">                    start = Offset(<span class="number">0f</span>, maxHeight.toPx()),</span><br><span class="line">                    end = Offset(maxWidth.toPx(), maxHeight.toPx()),</span><br><span class="line">                    strokeWidth = <span class="number">6f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;) &#123; _, constraints -&gt;</span><br><span class="line">                with(constraints) &#123;</span><br><span class="line">                    layout(</span><br><span class="line">                        width = <span class="keyword">if</span> (hasBoundedWidth) maxWidth <span class="keyword">else</span> minWidth,</span><br><span class="line">                        height = <span class="keyword">if</span> (hasBoundedHeight) maxHeight <span class="keyword">else</span> minHeight,</span><br><span class="line">                        <span class="comment">// 自定义对齐线设置在这里，它们会被传播到直接和间接的父Composable中。</span></span><br><span class="line">                        alignmentLines = mapOf(</span><br><span class="line">                            MinChartValue to minYBaseline.roundToInt(),</span><br><span class="line">                            MaxChartValue to maxYBaseline.roundToInt()</span><br><span class="line">                        )</span><br><span class="line">                    ) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BarChart 的直接和间接父级均可使用对齐线。</strong> 在下面的代码中创建了一个自定义布局 <strong>BarChartMinMax</strong> ，在其中使用了 <strong>BarChart</strong> 组件，它将两个 <code>Text</code> 槽和数据点作为参数，并将两个文本与最大和最小图表数据值对齐。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">BarChartMinMax</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    dataPoints: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    maxText: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    minText: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Layout(</span><br><span class="line">        content = &#123;</span><br><span class="line">            maxText()</span><br><span class="line">            minText()</span><br><span class="line">            BarChart(dataPoints, Modifier.size(<span class="number">200.</span>dp)) <span class="comment">// 设置一个固定的大小，使示例更容易理解</span></span><br><span class="line">        &#125;,</span><br><span class="line">        modifier = modifier</span><br><span class="line">    ) &#123; measurables, constraints -&gt;</span><br><span class="line"></span><br><span class="line">        check(measurables.size == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123;</span><br><span class="line">            it.measure(constraints.copy(minWidth = <span class="number">0</span>, minHeight = <span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> maxTextPlaceable = placeables[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">val</span> minTextPlaceable = placeables[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">val</span> barChartPlaceable = placeables[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从条形图中获取对齐线以定位文本</span></span><br><span class="line">        <span class="keyword">val</span> minValueBaseline = barChartPlaceable[MinChartValue]</span><br><span class="line">        <span class="keyword">val</span> maxValueBaseline = barChartPlaceable[MaxChartValue]</span><br><span class="line">        layout(constraints.maxWidth, constraints.maxHeight) &#123;</span><br><span class="line">            maxTextPlaceable.placeRelative(</span><br><span class="line">                x = <span class="number">0</span>,</span><br><span class="line">                y = maxValueBaseline - (maxTextPlaceable.height / <span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line">            minTextPlaceable.placeRelative(</span><br><span class="line">                x = <span class="number">0</span>,</span><br><span class="line">                y = minValueBaseline - (minTextPlaceable.height / <span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line">            barChartPlaceable.placeRelative(</span><br><span class="line">                x = max(maxTextPlaceable.width, minTextPlaceable.width) + <span class="number">20</span>,</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true, heightDp = 300)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ChartDataPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MaterialTheme &#123;</span><br><span class="line">        BarChartMinMax(</span><br><span class="line">            dataPoints = listOf(<span class="number">4</span>, <span class="number">24</span>, <span class="number">15</span>),</span><br><span class="line">            maxText = &#123; Text(<span class="string">&quot;Max&quot;</span>) &#125;,</span><br><span class="line">            minText = &#123; Text(<span class="string">&quot;Min&quot;</span>) &#125;,</span><br><span class="line">            modifier = Modifier.padding(<span class="number">24.</span>dp)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预览效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/279a79593c12ca2e7737934a2f99ea9a.png" alt="在这里插入图片描述"></p>
<p>这个例子涉及到了一个自定义的图表，如果在实际项目中想要使用图表的话，建议最好在Github中进行搜索，选择使用一些功能比较完整的图表库。当然如果你只是使用一种类型的图表，完全可以自己用Canvas来绘制自定义组件，但如果是涉及到很多图表类型，这对于个人来说将会是一个项长期且工作量巨大的工作。这里推荐一个功能相对来说比起齐全的图表库 <a target="_blank" rel="noopener" href="https://github.com/hi-manshu/Charty">Charty</a> 。</p>
<p>That’s the END.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/">https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Compose/">Compose</a><a class="post-meta__tags" href="/tags/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">绘制流程</a><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/">自定义布局</a></div><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1/" title="Compose中的导航路由"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose中的导航路由</div></div><div class="info-2"><div class="info-item-1">  1implementation &quot;androidx.navigation:navigation-compose:$nav_version&quot;   Jetpack库中的Navigation使用起来还是比较麻烦的，首先需要在xml中进行导航图的配置，然后在代码中使用NavController.navigate(id)进行跳转到指定的id的fragment页面，个人感觉这种方式还是不够灵活，需要预先定义，假如某个fragment没有在xml中定义就无法使用NavController进行跳转，另外还需要在xml和java&#x2F;kotlin文件来回折腾修改。 Jetpack...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E7%9A%84%E5%8A%A8%E7%94%BB/" title="Compose的动画"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Compose的动画</div></div><div class="info-2"><div class="info-item-1"> 乍一看Jetpack Compose中的动画Api，尼玛是真的多呀，我C了，简直令人眼花缭乱、云里雾里、天马行空、小兔乱撞、手脚慌乱、头冒虚汗、四肢抓狂、不知所措呀 。。。😭 但是我们可以对其进行分一下类，如果按照使用的方便程度划分，大概可以分为两大类：高级动画API和低级动画API（这里类比高级开发语言的分类，并不是指效果多高级）。 其中高级动画API使用比较简单方便，封装度高，更加适用于日常业务开发，而低级动画API则使用起来较为麻烦，因为其配置项或流程较多，但是却更加灵活，能对动画效果做出更加精细的控制，适合自定义要求度较高的业务场景。 我们还可以按照功能类型进行一个大概的分类，也就是上图中的划分，这里再用表格归类一下：    功能需求点 可能符合的API类型    单个组件的显示隐藏转场动画  每个子组件需要不同的入场&#x2F;出场效果 AnimatedVisibility   根据组件内容状态变化的动画(数据、尺寸等)  不同组件间的切换动画 AnimatedContent ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84Accompanist/" title="Compose中的Accompanist"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的Accompanist</div></div><div class="info-2"><div class="info-item-1">  权限依赖配置： 1234567repositories &#123;    mavenCentral()&#125;dependencies &#123;    implementation &quot;com.google.accompanist:accompanist-permissions:0.28.0&quot;&#125;  单个权限申请例如，我们需要获取相机权限，可以通过rememberPermissionState(Manifest.permission.CAMERA)创建一个 PermissionState对象，然后通过PermissionState.status.isGranted判断权限是否已获取，并通过调用permissionState.launchPermissionRequest()来申请权限。 12345&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!-- 别忘了在清单文件中添加权限声明 --&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84startActivityForResult%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" title="Compose中的startActivityForResult的正确姿势"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的startActivityForResult的正确姿势</div></div><div class="info-2"><div class="info-item-1">  后来研究了一下，在Compose 中startActivityForResult也有了新的姿势，要理解Compose 中startActivityForResult的姿势，这还得从androidx的startActivityForResult的姿势说起，因为Compose 就是在androidx的基础上利用其API简单封装了一下而已。 倒也不是说以前的不能用了，毕竟有系统自带的，谁还去用第三方的呀，用第三方的还得导入一个依赖库不是，能少依赖三方的就尽量少依赖吧。 androidx之后如何正确的startActivityForResult如何使用如果是在Activity或Fragment内部使用的话，直接调用registerForActivityResult方法即可。 例如，选择文件： 12345val launcher = registerForActivityResult(ActivityResultContracts.GetContent()) &#123; uri -&gt;    uri?.apply &#123; showToast(uri.toString())...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1/" title="Compose中的导航路由"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的导航路由</div></div><div class="info-2"><div class="info-item-1">  1implementation &quot;androidx.navigation:navigation-compose:$nav_version&quot;   Jetpack库中的Navigation使用起来还是比较麻烦的，首先需要在xml中进行导航图的配置，然后在代码中使用NavController.navigate(id)进行跳转到指定的id的fragment页面，个人感觉这种方式还是不够灵活，需要预先定义，假如某个fragment没有在xml中定义就无法使用NavController进行跳转，另外还需要在xml和java&#x2F;kotlin文件来回折腾修改。 Jetpack...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E7%9A%84%E5%8A%A8%E7%94%BB/" title="Compose的动画"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose的动画</div></div><div class="info-2"><div class="info-item-1"> 乍一看Jetpack Compose中的动画Api，尼玛是真的多呀，我C了，简直令人眼花缭乱、云里雾里、天马行空、小兔乱撞、手脚慌乱、头冒虚汗、四肢抓狂、不知所措呀 。。。😭 但是我们可以对其进行分一下类，如果按照使用的方便程度划分，大概可以分为两大类：高级动画API和低级动画API（这里类比高级开发语言的分类，并不是指效果多高级）。 其中高级动画API使用比较简单方便，封装度高，更加适用于日常业务开发，而低级动画API则使用起来较为麻烦，因为其配置项或流程较多，但是却更加灵活，能对动画效果做出更加精细的控制，适合自定义要求度较高的业务场景。 我们还可以按照功能类型进行一个大概的分类，也就是上图中的划分，这里再用表格归类一下：    功能需求点 可能符合的API类型    单个组件的显示隐藏转场动画  每个子组件需要不同的入场&#x2F;出场效果 AnimatedVisibility   根据组件内容状态变化的动画(数据、尺寸等)  不同组件间的切换动画 AnimatedContent ...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E7%9A%84%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" title="Compose的手势操作和事件处理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose的手势操作和事件处理</div></div><div class="info-2"><div class="info-item-1">  Compose 中的手势操作或事件处理全部都是以 Modifier 修饰符的形式提供的，事件处理按照层次可以划分为高级事件处理API和低级事件处理API。 其中高级事件处理API是位于更上层的API，它们都是基于更底层的低级事件处理API实现的，也是开发中比较常用的。高级事件处理API的分类大概如下图所示：  点击事件监听点击事件非常简单，使用 clickable 和 combinedClickable 修饰符即可满足需求： 123456789101112131415161718@OptIn(ExperimentalFoundationApi::class)@Composablefun ClickableExample() &#123;    Column&#123;        Box(Modifier            .clickable &#123; println(&quot;clickable&quot;) &#125;            .size(30.dp)            .background(Color.Red))       ...</div></div></div></a><a class="pagination-related" href="/2022/08/22/posts/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="Activity的启动流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-22</div><div class="info-item-2">Activity的启动流程</div></div><div class="info-2"><div class="info-item-1">Application的初始化从应用进程到系统进程ActivityThread在创建的时候，会将自己的ApplicationThread绑定到AMS中。  ActivityThread.main() ActivityThread.attach() IActivityManager.attachApplication(mAppThread) Binder.transact()        应用程序通过IActivityManager接口发起系统调用，调用attachApplication并传递IApplicationThread，执行流程从应用进程到了系统进程。  ActivityManagerService.onTransact() ActivityManagerService.attachApplication(IApplicationThread thread)AMS作为IActivityService的接口的服务端实现，会响应客户端的请求，最终attachApplication(IApplicationThread...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-1-%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%84%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">第 1 阶段：组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-2-%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%B8%83%E5%B1%80"><span class="toc-number">2.</span> <span class="toc-text">第 2 阶段：布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-3-%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%98%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">第 3 阶段：绘制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Modifier-layout-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80"><span class="toc-number"></span> <span class="toc-text">使用 Modifier.layout() 自定义布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Modifier-layout-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">Modifier.layout() 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Layout-%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80"><span class="toc-number"></span> <span class="toc-text">使用 Layout 组件自定义布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout-%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.</span> <span class="toc-text">Layout 组件使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout-Modifier-layout-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">Layout &#x2F; Modifier.layout 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraints-%E7%BA%A6%E6%9D%9F%E8%AF%A6%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">Constraints 约束详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Constraints-%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F%E8%BE%B9%E7%95%8C-Bounds"><span class="toc-number">1.</span> <span class="toc-text">Constraints 中的约束边界 Bounds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F%E7%BA%A6%E6%9D%9F-Constraints-offset-%E5%92%8C-%E5%AE%BD%E9%AB%98%E7%BA%A6%E6%9D%9F-Constraints-constrainWidth-Height"><span class="toc-number">2.</span> <span class="toc-text">偏移量约束 Constraints.offset() 和 宽高约束 Constraints.constrainWidth&#x2F;Height()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intrinsic-%E5%9B%BA%E6%9C%89%E7%89%B9%E6%80%A7%E6%B5%8B%E9%87%8F"><span class="toc-number"></span> <span class="toc-text">Intrinsic 固有特性测量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%E4%B8%8A%E5%BA%94%E7%94%A8%E5%9B%BA%E6%9C%89%E7%89%B9%E6%80%A7%E6%B5%8B%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">在内置组件上应用固有特性测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BA%E6%9C%89%E7%89%B9%E6%80%A7%E6%B5%8B%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">自定义固有特性测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Intrinsic-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">Intrinsic 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SubcomposeLayout-%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B"><span class="toc-number"></span> <span class="toc-text">SubcomposeLayout 的超能力</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SubcomposeLayout-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">SubcomposeLayout 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParentDataModifier-%E5%92%8C-Scope"><span class="toc-number"></span> <span class="toc-text">ParentDataModifier 和 Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ParentDataModifier-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">ParentDataModifier 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BoxWithConstraints-%E6%9E%84%E5%BB%BA%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80"><span class="toc-number"></span> <span class="toc-text">BoxWithConstraints 构建自适应布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BoxWithConstraints-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">BoxWithConstraints 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LookaheadLayout-%E8%B6%85%E5%89%8D%E6%B5%8B%E9%87%8F"><span class="toc-number"></span> <span class="toc-text">LookaheadLayout 超前测量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LookaheadLayout-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">LookaheadLayout 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E9%BD%90%E7%BA%BF"><span class="toc-number"></span> <span class="toc-text">自定义对齐线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E9%BD%90%E7%BA%BF"><span class="toc-number">1.</span> <span class="toc-text">创建自定义对齐线</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>