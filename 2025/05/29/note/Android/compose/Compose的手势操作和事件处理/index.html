<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose的手势操作和事件处理 | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Compose 中的手势操作或事件处理全部都是以 Modifier 修饰符的形式提供的，事件处理按照层次可以划分为高级事件处理API和低级事件处理API。 其中高级事件处理API是位于更上层的API，它们都是基于更底层的低级事件处理API实现的，也是开发中比较常用的。高级事件处理API的分类大概如下图所示：  点击事件监听点击事件非常简单，使用 clickable 和 combinedClic">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose的手势操作和事件处理">
<meta property="og:url" content="https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E7%9A%84%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="Compose 中的手势操作或事件处理全部都是以 Modifier 修饰符的形式提供的，事件处理按照层次可以划分为高级事件处理API和低级事件处理API。 其中高级事件处理API是位于更上层的API，它们都是基于更底层的低级事件处理API实现的，也是开发中比较常用的。高级事件处理API的分类大概如下图所示：  点击事件监听点击事件非常简单，使用 clickable 和 combinedClic">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-05-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.125Z">
<meta property="article:author" content="BravestSnail">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Compose">
<meta property="article:tag" content="手势">
<meta property="article:tag" content="事件处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose的手势操作和事件处理",
  "url": "https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E7%9A%84%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-05-29T16:00:00.000Z",
  "dateModified": "2025-06-04T12:46:35.125Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E7%9A%84%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose的手势操作和事件处理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose的手势操作和事件处理</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose的手势操作和事件处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-29T16:00:00.000Z" title="发表于 2025-05-30 00:00:00">2025-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.125Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/note/">note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><!-- filepath: /Users/lijiapei/Project/Blog/source/_posts/note/compose/Compose的手势操作和事件处理.md -->

<p>Compose 中的手势操作或事件处理全部都是以 Modifier 修饰符的形式提供的，事件处理按照层次可以划分为高级事件处理API和低级事件处理API。</p>
<p>其中高级事件处理API是位于更上层的API，它们都是基于更底层的低级事件处理API实现的，也是开发中比较常用的。高级事件处理API的分类大概如下图所示：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e47bd394bb9539e60ee4d9f53b6cd6b1.png" alt="在这里插入图片描述"></p>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><p>监听点击事件非常简单，使用 <code>clickable</code> 和 <code>combinedClickable</code> 修饰符即可满足需求：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalFoundationApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ClickableExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column&#123;</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .clickable &#123; println(<span class="string">&quot;clickable&quot;</span>) &#125;</span><br><span class="line">            .size(<span class="number">30.</span>dp)</span><br><span class="line">            .background(Color.Red))</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">50.</span>dp)</span><br><span class="line">            .background(Color.Blue)</span><br><span class="line">            .combinedClickable(</span><br><span class="line">                onLongClick = &#123; println(<span class="string">&quot;combinedClickable --&gt; onLongClick&quot;</span>) &#125;,</span><br><span class="line">                onDoubleClick = &#123; println(<span class="string">&quot;combinedClickable --&gt; onDoubleClick&quot;</span>) &#125;,</span><br><span class="line">                onClick = &#123; println(<span class="string">&quot;combinedClickable --&gt; onClick&quot;</span>) &#125;</span><br><span class="line">            ))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当点击事件发生时会为被点击的组件施加一个水波纹效果动画的蒙层，这是Material Design中的默认效果，如果不希望点击时有这个效果，可以使用低级别的Api <code>detectTapGestures</code> 。</p>
<p>另外， <code>clickable</code> 和 <code>combinedClickable</code> 可以传入一个 <code>enable</code> 参数作为一个可变状态，可以通过该状态来动态控制是否启用点击监听。</p>
<h3 id="Draggable拖动"><a href="#Draggable拖动" class="headerlink" title="Draggable拖动"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Draggable&spm=1001.2101.3001.7020">Draggable</a>拖动</h3><p>Draggable可以监听拖动手势偏移量，然后可以根据偏移量定制UI拖动交换效果。但是值得注意的是，Draggable修饰符只支持监听水平方向或垂直方向的偏移，如希望监听任意方向，则可以使用<code>detectDragGestures</code>方法。</p>
<p>使用Draggable至少需要传入2个参数 <strong><code>draggableState</code></strong> 和 <strong><code>orientation</code></strong>：</p>
<ul>
<li><strong><code>draggableState</code></strong>: 通过它可以获取到拖动手势的偏移量，并且也允许我们动态控制发生偏移行为</li>
<li><strong><code>orientation</code></strong>：监听拖动的方向，只能是水平或垂直</li>
</ul>
<p>如下代码实现一个简单的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%BB%91%E5%9D%97&spm=1001.2101.3001.7020">滑块</a>拖动效果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DraggableExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> offsetX <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> boxSlideSize = <span class="number">50.</span>dp</span><br><span class="line">    <span class="keyword">val</span> maxLengthPx = with(LocalContext.current) &#123;</span><br><span class="line">        resources.displayMetrics.widthPixels - boxSlideSize.toPx()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并获取一个DraggableState实例</span></span><br><span class="line">    <span class="keyword">val</span> draggableState = rememberDraggableState &#123;</span><br><span class="line">        <span class="comment">// 使用回调方法回传的参数对状态偏移量进行累加，并限制范围</span></span><br><span class="line">        offsetX = (offsetX + it).coerceIn(<span class="number">0f</span>, maxLengthPx)</span><br><span class="line">    &#125;</span><br><span class="line">    Box(</span><br><span class="line">        Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .height(boxSlideSize)</span><br><span class="line">            .background(Color.LightGray)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Box(</span><br><span class="line">            Modifier</span><br><span class="line">                .size(boxSlideSize)</span><br><span class="line">                .offset &#123; IntOffset(offsetX.roundToInt(), <span class="number">0</span>) &#125;</span><br><span class="line">                .draggable(</span><br><span class="line">                    orientation = Orientation.Horizontal,</span><br><span class="line">                    state = draggableState</span><br><span class="line">                )</span><br><span class="line">                .background(Color.Red)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Modifier是链式执行的，因此这里<code>offset</code>修饰符应该放在<code>draggable</code>和<code>background</code>之前。</p>
</blockquote>
<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/69fbb9a3cbeb5f0d27c9f2c98b2306f8.gif" alt="在这里插入图片描述"></p>
<blockquote>
<p>错误示例1(draggable在offset前面)：第二次拖动时UI控件拖动只能拖动初始位置才生效，不会跟随UI控件而移动监听，原因是每次拖动时draggable都监听的都是初始位置，不是偏移后位置。<br>错误示例2(background在offset前面)：UI控件不会跟手，原因在于每次绘制时background都在初始位置绘制，不是偏移后位置。</p>
</blockquote>
<p>另外，<code>draggable</code> 还有几个参数：</p>
<ul>
<li><code>enabled</code>：是否启用拖拽，方便动态控制，默认值是true。</li>
<li><code>interactionSource</code>：可以用来收集拖拽的状态，默认值是null。</li>
<li><code>startDragImmediately</code>：是否立即开始拖动，默认值是false，如果设为true可防止其他手势检测器对“down”事件做出反应。这是为了允许最终用户通过按下操作来“捕获”动画组件。当你拖动的值正在设定&#x2F;动画时，设置它很有用。</li>
<li><code>onDragStarted</code>：一个挂起函数，开始拖动时回调。</li>
<li><code>onDragStopped</code>：一个挂起函数，停止拖动时回调。</li>
<li><code>reverseDirection</code>：是否反方向执行拖拽效果，默认值是false。</li>
</ul>
<p>其中<code>interactionSource</code> 可以这样使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> interactionSource = remember&#123; MutableInteractionSource() &#125;</span><br><span class="line">Box(</span><br><span class="line">    Modifier </span><br><span class="line">        .draggable(</span><br><span class="line">            orientation = Orientation.Horizontal,</span><br><span class="line">            state = draggableState,</span><br><span class="line">            interactionSource = interactionSource, </span><br><span class="line">        ).background(Color.Red)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> isDragged <span class="keyword">by</span> interactionSource.collectIsDraggedAsState()</span><br><span class="line">Text(<span class="keyword">if</span>(isDragged) <span class="string">&quot;正在拖动&quot;</span> <span class="keyword">else</span> <span class="string">&quot;静止&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Swipeable滑动"><a href="#Swipeable滑动" class="headerlink" title="Swipeable滑动"></a>Swipeable滑动</h3><p>使用方式跟<code>Draggable</code>差不多，但是<code>Swipeable</code>可以通过<strong>锚点</strong>设置吸附效果。</p>
<p>使用<strong>Swipeable</strong>至少需要传入4个参数：</p>
<ul>
<li><strong><code>State</code></strong>: 手势状态，通过它可以实时获取当前手势的偏移信息</li>
<li><strong><code>Anchors</code></strong>: 锚点，用于记录不同状态对应数值的映射关系</li>
<li><strong><code>Orientation</code></strong>: 手势方向，只支持水平或垂直</li>
<li><strong><code>thresholds</code></strong>: 不同锚点之间吸附效果的临界阈值，常用的阈值有<code>FixedThreshold(Dp)</code>和<code>FractionalThreshold(Float)</code>两种</li>
</ul>
<p>以下代码使用<code>Swipeable</code>创建一个简单的开关效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Status</span>&#123; CLOSE, OPEN &#125; <span class="comment">// 定义两个枚举项表示开关状态</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalMaterialApi::class)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SwipeableDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> blockSize = <span class="number">48.</span>dp</span><br><span class="line">    <span class="keyword">val</span> blockSizePx = blockSize.toPx()</span><br><span class="line">    <span class="comment">// 创建并获取一个SwipeableState实例</span></span><br><span class="line">    <span class="keyword">val</span> swipeableState = rememberSwipeableState(initialValue = Status.CLOSE)</span><br><span class="line">    <span class="comment">// 定义锚点，锚点以Pair表示，每个状态对应一个锚点</span></span><br><span class="line">    <span class="keyword">val</span> anchors = mapOf(</span><br><span class="line">        <span class="number">0f</span> to Status.CLOSE,</span><br><span class="line">        blockSizePx*<span class="number">2</span> to Status.OPEN</span><br><span class="line">    )</span><br><span class="line">    Box(</span><br><span class="line">        Modifier</span><br><span class="line">            .size(height = blockSize, width = blockSize * <span class="number">3</span>)</span><br><span class="line">            .clip(RoundedCornerShape(<span class="number">50</span>))</span><br><span class="line">            .background(Color.Gray)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Box(</span><br><span class="line">            Modifier</span><br><span class="line">                .offset &#123; IntOffset(swipeableState.offset.value.toInt(), <span class="number">0</span>) &#125;</span><br><span class="line">                .swipeable(</span><br><span class="line">                    state = swipeableState,</span><br><span class="line">                    anchors = anchors,</span><br><span class="line">                    thresholds = &#123; from, to -&gt;</span><br><span class="line">                        <span class="comment">// 从关闭到开启状态时，滑块移动超过30%距离自动吸附到开启状态</span></span><br><span class="line">                        <span class="keyword">if</span> (from == Status.CLOSE) &#123; </span><br><span class="line">                            FractionalThreshold(<span class="number">0.3f</span>)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从开启状态到关闭状态时，滑块移动超过50%才会自动吸附到关闭状态</span></span><br><span class="line">                            FractionalThreshold(<span class="number">0.5f</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    orientation = Orientation.Horizontal</span><br><span class="line">                )</span><br><span class="line">                .size(blockSize)</span><br><span class="line">                .clip(RoundedCornerShape(<span class="number">50</span>))</span><br><span class="line">                .background(Color.Red)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Modifier是链式执行的，因此这里<code>swipeable</code>修饰符应该放在<code>draggable</code>和<code>background</code>之前。</p>
</blockquote>
<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/cded93a7c120c241e0d930eaa9a59d8e.gif" alt="在这里插入图片描述"></p>
<blockquote>
<p>注意：<code>Modifier.swipeable</code> 这个修饰符在<code>compose.material</code>中可以正常使用，而在<code>compose.material3</code>库中被隐藏了。但是Cmpose提供了一个 <code>SwipeToDismiss</code> 这个Composable组件来专门做滑动删除的效果。</p>
</blockquote>
<h3 id="transformable多点触控"><a href="#transformable多点触控" class="headerlink" title="transformable多点触控"></a>transformable多点触控</h3><p><code>transformable</code>修饰符可以监听双指拖动、缩放或旋转手势</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TransformableExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> boxSize = <span class="number">200.</span>dp</span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">by</span> remember &#123; mutableStateOf(Offset.Zero) &#125;</span><br><span class="line">    <span class="keyword">var</span> rotationAngle <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> scale <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1f</span>) &#125;</span><br><span class="line">    <span class="comment">// 创建并获取一个TransformableState实例</span></span><br><span class="line">    <span class="keyword">val</span> transformableState = rememberTransformableState &#123; </span><br><span class="line">        zoomChange: <span class="built_in">Float</span>, panChange: Offset, rotationChange: <span class="built_in">Float</span> -&gt;</span><br><span class="line">        scale *= zoomChange</span><br><span class="line">        offset += panChange</span><br><span class="line">        rotationAngle += rotationChange</span><br><span class="line">    &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) &#123;</span><br><span class="line">        Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.ic_sky),</span><br><span class="line">            contentScale = ContentScale.Crop,</span><br><span class="line">            contentDescription = <span class="literal">null</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(boxSize)</span><br><span class="line">                .rotate(rotationAngle) <span class="comment">// 注意rotate的顺序应该先于offset</span></span><br><span class="line">                .offset &#123; IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) &#125;</span><br><span class="line">                .scale(scale)</span><br><span class="line">                .transformable(</span><br><span class="line">                    state = transformableState,</span><br><span class="line">                    <span class="comment">// 该值为true时，发生双指拖动或缩放时，不会同时监听旋转手势信息</span></span><br><span class="line">                    lockRotationOnZoomPan = <span class="literal">true</span> </span><br><span class="line">                )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里注意rotate的顺序应该先于offset，如果先调用了offset再调用rotate, 则组件会先偏移再旋转，这会导致组件最终位置不可预期。</p>
</blockquote>
<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4ce8ce697a803b50563a5120c79f81c7.gif" alt="在这里插入图片描述"></p>
<h3 id="Scrollable滚动"><a href="#Scrollable滚动" class="headerlink" title="Scrollable滚动"></a>Scrollable滚动</h3><p>主要用于列表场景，结合<code>LazyColumn</code>和<code>LazyRow</code>来使用</p>
<p><strong>horizontalScroll水平滚动</strong></p>
<p><code>horizontalScroll</code>主要结合<code>Row</code>组件来使用，使其支持水平滚动，<code>horizontalScroll</code>只需要传入一个 <strong><code>scrollState</code></strong> 即可。我们可以使用 <strong><code>rememberScrollState</code></strong> 快速创建一个 <code>scrollState</code> 实例并传入即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HorizontalScrollExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scrollState = rememberScrollState()</span><br><span class="line">    Row(</span><br><span class="line">        Modifier</span><br><span class="line">            .padding(<span class="number">10.</span>dp)</span><br><span class="line">            .border(BorderStroke(<span class="number">1.</span>dp, Color.Blue))</span><br><span class="line">            .height(<span class="number">50.</span>dp)</span><br><span class="line">            .horizontalScroll(scrollState)</span><br><span class="line">    ) &#123;</span><br><span class="line">        repeat(<span class="number">50</span>) &#123;</span><br><span class="line">            Text(<span class="string">&quot;item <span class="variable">$it</span>&quot;</span>, Modifier.padding(<span class="number">10.</span>dp))</span><br><span class="line">            Divider(Modifier.width(<span class="number">1.</span>dp).fillMaxHeight())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>verticalScroll</code>与<code>horizontalScroll</code>使用类似，主要结合<code>Column</code>组件使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">VerticalScrollExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scrollState = rememberScrollState()</span><br><span class="line">    Column(</span><br><span class="line">        Modifier</span><br><span class="line">            .height(<span class="number">300.</span>dp)</span><br><span class="line">            .verticalScroll(scrollState)</span><br><span class="line">    ) &#123;</span><br><span class="line">        repeat(<span class="number">50</span>) &#123;</span><br><span class="line">            Text(<span class="string">&quot;item <span class="variable">$it</span>&quot;</span>, Modifier.padding(<span class="number">10.</span>dp))</span><br><span class="line">            Divider()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>verticalScroll</code> 与 <code>horizontalScroll</code> 这两个修饰符除了在<code>Row</code>和<code>Column</code>组件上使用外，在其他组件上也可以应用，如 <code>Box</code> 组件等。</p>
<h3 id="低级别scrollable修饰符"><a href="#低级别scrollable修饰符" class="headerlink" title="低级别scrollable修饰符"></a>低级别scrollable修饰符</h3><p><code>horizontalScroll</code>和<code>verticalScroll</code>都是基于<code>scrollable</code>实现的， <code>scrollable</code>修饰符除了传入一个<code>scrollState</code>外，还需要传入<code>Orientation</code>(水平或垂直)</p>
<p>以下代码通过 <code>scrollable</code> 修饰符的滚动监听能力，自己来定制实现类似 <strong><code>horizontalScroll</code></strong> 修饰符的功能：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ScrollableExample1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(Modifier.padding(<span class="number">10.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">val</span> scrollState = rememberScrollState()</span><br><span class="line">        Row(</span><br><span class="line">            Modifier</span><br><span class="line">                .border(BorderStroke(<span class="number">1.</span>dp, Color.Blue))</span><br><span class="line">                .height(<span class="number">50.</span>dp)</span><br><span class="line">                .offset(x = -scrollState.value.toDp()) <span class="comment">// 滚动位置增大时应该向左偏移，所以这里设为负数</span></span><br><span class="line">                .scrollable(scrollState, Orientation.Horizontal, reverseDirection = <span class="literal">true</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            repeat(<span class="number">50</span>) &#123;</span><br><span class="line">                Text(<span class="string">&quot;item <span class="variable">$it</span>&quot;</span>, Modifier.padding(<span class="number">10.</span>dp))</span><br><span class="line">                Divider(Modifier.width(<span class="number">1.</span>dp).fillMaxHeight())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Text(text = <span class="string">&quot;scrollState.value: <span class="subst">$&#123;scrollState.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>scrollable</code>的滚动位置范围为<code>0~MAX_VALUE</code>, 默认当手指在组件上<strong>向右滑动</strong>时，<strong>滚动位置会增大</strong>，<strong>向左滑动</strong>时，<strong>滚动位置会减小</strong>，直到减小到<code>0</code>。 由于滚动位置默认初始值为<code>0</code>，所以默认我们只能向右滑来增大滚动位置。如果将<code>reverseDirection</code>参数设置为<code>true</code>时，那么此时手指向左滑滚动位置会增大，向右滑滚动位置会减小。</p>
<p>因此这里将<code>reverseDirection</code>设为<code>true</code>允许我们从初始位置向左滑以查看<code>Row</code>组件右侧超出屏幕的内容部分。</p>
<p><strong>补充提示</strong>: 在使用 <strong><code>rememberScrollState</code></strong> 创建 <strong><code>ScrollState</code></strong> 实例时我们是可以通过 <strong><code>initial</code></strong> 参数来指定组件初始滚动位置的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollState</span>(initial: <span class="built_in">Int</span>) : ScrollableState &#123;</span><br><span class="line">  <span class="keyword">var</span> value: <span class="built_in">Int</span> <span class="keyword">by</span> mutableStateOf(initial, structuralEqualityPolicy())</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">animateScrollTo</span><span class="params">(...)</span></span></span><br><span class="line">  <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(...)</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行后我们会发现，当进行左滑时，原本位于屏幕外的内容进入屏幕时右边出现一片空白，这是因为<code>Row</code>组件的默认测量策略导致超出屏幕的子组件宽度测量结果为零。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f3ea8f6ff0e9fed5caa4c76e3bec12c3.gif" alt="在这里插入图片描述"></p>
<p>此时需要使用<code>layout</code>修饰符来自定义布局，我们需要创建一个新的约束，用于测量组件的真实宽度，主动设置组件应有的宽高尺寸，并根据组件的滚动偏移量来摆放组件内容。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ScrollableExample2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(Modifier.padding(<span class="number">10.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">val</span> scrollState = rememberScrollState()</span><br><span class="line">        Row(</span><br><span class="line">            Modifier</span><br><span class="line">                .border(BorderStroke(<span class="number">1.</span>dp, Color.Blue))</span><br><span class="line">                .height(<span class="number">50.</span>dp)</span><br><span class="line">                .clipScrollableContainer(Orientation.Horizontal) <span class="comment">// 留出父组件设置的padding空间</span></span><br><span class="line">                .scrollable(scrollState, Orientation.Horizontal, reverseDirection = <span class="literal">true</span>)</span><br><span class="line">                .layout &#123; measurable, constraints -&gt;</span><br><span class="line">                    println(<span class="string">&quot;constraints: <span class="variable">$constraints</span>&quot;</span>)</span><br><span class="line">                    <span class="comment">// 约束中默认最大宽度为父组件所允许的最大宽度，此处为屏幕宽度</span></span><br><span class="line">                    <span class="comment">// 将最大宽度设置为无限大</span></span><br><span class="line">                    <span class="keyword">val</span> childConstraints = constraints.copy(</span><br><span class="line">                        maxWidth = Constraints.Infinity</span><br><span class="line">                    )</span><br><span class="line">                    println(<span class="string">&quot;childConstraints: <span class="variable">$childConstraints</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">val</span> placeable = measurable.measure(childConstraints) <span class="comment">// 使用新的约束进行组件测量</span></span><br><span class="line">                    <span class="comment">// 计算 当前组件宽度 与 父组件所允许的最大宽度 中取一个最小值</span></span><br><span class="line">                    <span class="comment">// 如果组件超出屏幕，此时width为屏幕宽度。如果没有超出，则为组件本身宽度</span></span><br><span class="line">                    <span class="keyword">val</span> width = placeable.width.coerceAtMost(constraints.maxWidth)</span><br><span class="line">                    <span class="comment">// 计算 当前组件高度 与 父组件所允许的最大高度 中取一个最小值</span></span><br><span class="line">                    <span class="keyword">val</span> height = placeable.height.coerceAtMost(constraints.maxHeight)</span><br><span class="line">                    <span class="keyword">val</span> scrollDistance = placeable.width - width <span class="comment">// 计算可滚动的最大距离</span></span><br><span class="line">                    layout(width, height) &#123; <span class="comment">// 主动设置组件的宽高</span></span><br><span class="line">                        <span class="comment">// 根据可滚动的最大距离来计算当前的滚动位置</span></span><br><span class="line">                        <span class="keyword">val</span> scroll = scrollState.value.coerceIn(<span class="number">0</span>, scrollDistance)</span><br><span class="line">                        <span class="keyword">val</span> offsetX = -scroll <span class="comment">// 根据滚动位置向左偏移</span></span><br><span class="line">                        placeable.placeRelativeWithLayer(offsetX, <span class="number">0</span>) <span class="comment">// 摆放组件内容</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        ) &#123;</span><br><span class="line">            repeat(<span class="number">50</span>) &#123;</span><br><span class="line">                Text(<span class="string">&quot;item <span class="variable">$it</span>&quot;</span>, Modifier.padding(<span class="number">10.</span>dp))</span><br><span class="line">                Divider(Modifier.width(<span class="number">1.</span>dp).fillMaxHeight())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Text(text = <span class="string">&quot;scrollState.value: <span class="subst">$&#123;scrollState.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0875be33d7d0e557eddf3ea9c40798ad.gif" alt="在这里插入图片描述"></p>
<h3 id="nestedScroll-嵌套滑动"><a href="#nestedScroll-嵌套滑动" class="headerlink" title="nestedScroll 嵌套滑动"></a>nestedScroll 嵌套滑动</h3><p><code>nestedScroll</code> 修饰符对标Android传统原生<code>View</code>体系中的<code>NestedScrollView</code>组件，主要用于处理嵌套滑动的场景，为父布局劫持消费子布局滑动手势提供了可能。</p>
<p>使用 <code>nestedScroll</code> 参数列表中有一个必选参数 <code>connection</code> 和一个可选参数 <code>dispatcher</code></p>
<ul>
<li><strong><code>connection</code></strong>：嵌套滑动手势处理的核心逻辑，内部回调可以在子布局获得滑动事件前预先消费掉部分或全部手势偏移量，也可以获取子布局消费后剩下的手势偏移量。</li>
<li><strong><code>dispatcher</code></strong>：调度器，内部包含用于父布局的 <code>NestedScrollConnection</code> , 可以调用 <strong><code>dispatch*</code></strong> 系列方法来通知父布局发生滑动</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">nestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    connection: <span class="type">NestedScrollConnection</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    dispatcher: <span class="type">NestedScrollDispatcher</span>? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>NestedScrollConnection</strong>提供了四个回调方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">说明</th>
<th align="left">参数</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>onPreScroll</code></td>
<td align="left">可以预先劫持滑动事件，消费后再交由子布局</td>
<td align="left"><code>available</code>：当前可用的滑动事件偏移量  <br><code>source</code>：滑动事件的类型</td>
<td align="left">当前组件消费的滑动事件偏移量，如果不想消费可返回Offset.Zero</td>
</tr>
<tr>
<td><code>onPostScroll</code></td>
<td align="left">可以获取子布局处理后剩下的滑动事件</td>
<td align="left"><code>consumed</code>：之前被消费的所有滑动事件偏移量  <br><code>available</code>：当前剩下还可用的滑动事件偏移量  <br><code>source</code>：滑动事件的类型</td>
<td align="left">当前组件消费的滑动事件偏移量，如果不想消费可返回 Offset.Zero ，则剩下偏移量会继续交由当前布局的父布局进行处理</td>
</tr>
<tr>
<td><code>onPreFling</code></td>
<td align="left">获取 Fling 动作开始时的速度</td>
<td align="left"><code>available</code>：Fling 开始时的速度</td>
<td align="left">当前组件消费的速度，如果不想消费可返回 Velocity.Zero</td>
</tr>
<tr>
<td><code>onPostFling</code></td>
<td align="left">获取 Fling 动作结束时的速度</td>
<td align="left"><code>consumed</code>：之前消费的所有速度  <br><code>available</code>：当前剩下还可用的速度</td>
<td align="left">当前组件消费的速度，如果不想消费可返回Velocity.Zero，剩下速度会继续交由当前布局的父布局进行处理</td>
</tr>
</tbody></table>
<p><strong>Fling</strong>含义：当我们手指在滑动列表时，如果是快速滑动并抬起，则列表会根据惯性继续飘一段距离后停下，这个行为就是 Fling 惯性滑动，<strong><code>onPreFling</code></strong> 在你手指刚抬起时便会回调，而 <strong><code>onPostFling</code></strong> 会在飘一段距离停下后回调。</p>
<h3 id="使用nestedScroll实现下拉刷新"><a href="#使用nestedScroll实现下拉刷新" class="headerlink" title="使用nestedScroll实现下拉刷新"></a>使用nestedScroll实现下拉刷新</h3><p>效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/179ed50b7d4b8168cd945115d122f09e.gif"></p>
<p>在这个示例中存在着加载动画和列表数据。当我们手指向下滑时，此时如果列表顶部没有数据则会逐渐出现加载动画。与之相反，当我们手指向上滑时，此时如果加载动画还在，则加载动画逐渐向上消失，直到加载动画完全消失后，列表才会被向上滑动。</p>
<p>为实现这个滑动刷新的需求，我们可以设计如下方案。我们首先需要将加载动画和列表数据放到一个父布局中统一管理。</p>
<ol>
<li>当我们手指向下滑时，我们希望滑动手势首先交给子布局中的列表进行处理，如果列表已经滑到顶部说明此时滑动手势事件没有被消费，此时再交由父布局进行消费。父布局可以消费列表消费剩下的滑动手势事件（增大加载指示器的偏移量）。</li>
<li>当我们手指向上滑时，我们希望滑动手势首先被父布局消费（为加载动画减小偏移），如果加载动画本身仍未出现时，则不进行消费。然后将剩下的滑动手势交给子布局列表进行消费。</li>
</ol>
<p>使用 nestedScroll 修饰符最重要的就是根据自己的业务场景来定制 <strong>NestedScrollConnection</strong> 的实现，接下来我们就逐个分析 <strong>NestedScrollConnection</strong> 中的每个接口该如何进行实现。</p>
<p><strong>实现 onPostScroll</strong></p>
<p>当我们手指向下滑时，我们希望滑动手势首先交给子布局中的列表进行处理，如果列表已经滑到顶部说明此时滑动手势事件没有被消费，此时再交由父布局进行消费。 <code>onPostScroll</code> 回调时机正好符合当前的需求。</p>
<p>首先需要判断该滑动事件是不是拖动事件，通过 <code>available.y &gt; 0</code> 判断是否是下滑手势，如果都没问题时，通知加载动画增加偏移量。返回值 <code>Offset(x = 0f, y = available.y)</code> 意味着将剩下的所有偏移量全部消费调，不再向外层父布局继续传播了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    consumed: <span class="type">Offset</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    available: <span class="type">Offset</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    source: <span class="type">NestedScrollSource</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Offset &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == NestedScrollSource.Drag &amp;&amp; available.y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        state.updateOffsetDelta(available.y)</span><br><span class="line">        <span class="keyword">return</span> Offset(x = <span class="number">0f</span>, y = available.y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Offset.Zero</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-onPreScroll"><a href="#实现-onPreScroll" class="headerlink" title="实现 onPreScroll"></a>实现 onPreScroll</h4><p>与上面相反，此时我们希望上滑收回加载动画，当我们手指向上滑时，我们希望滑动手势首先被父布局消费（减小加载指示器的偏移量），如果加载指示器还未出现，则不需要进行消费。剩余的滑动手势事件会交给子布局列表继续进行消费。<code>onPreScroll</code> 回调时机正好符合这个需求。</p>
<p>首先仍需要判断该滑动事件是不是拖动事件，通过 <code>available.y &lt; 0</code> 判断是否是上滑手势。此时可能加载指示器还未出现，所以需要额外进行判断。如果未出现，则返回 <code>Offset.Zero</code> 不消费，如果出现了则返回 <code>Offset(x = 0f, y = available.y)</code> 进行消费。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreScroll</span><span class="params">(available: <span class="type">Offset</span>, source: <span class="type">NestedScrollSource</span>)</span></span>: Offset &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == NestedScrollSource.Drag &amp;&amp; available.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        state.updateOffsetDelta(available.y)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (state.isSwipeInProgress) Offset(x = <span class="number">0f</span>, y = available.y) <span class="keyword">else</span> Offset.Zero</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Offset.Zero</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现-onPreFling"><a href="#实现-onPreFling" class="headerlink" title="实现 onPreFling"></a>实现 onPreFling</h4><p>接下来，我们需要一个松手时的吸附效果。如果加载指示器已经被拖动并超过一半，则应该吸附到加载状态，否则就收缩回初始状态。onPreFling 会在松手时发生惯性滑动前回调，符合我们当前这个的场景需求。</p>
<p>注意：即使你松手时速度很慢或静止，onPreFling 与 onPostFling都会回调，只是速度数值很小。</p>
<p>这里我们只需要吸引效果，并不希望消费速度，所以返回 <code>Velocity.Zero</code> 即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreFling</span><span class="params">(available: <span class="type">Velocity</span>)</span></span>: Velocity &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.indicatorOffset &gt; height / <span class="number">2</span>) &#123;</span><br><span class="line">        state.animateToOffset(height)</span><br><span class="line">        state.isRefreshing = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.animateToOffset(<span class="number">0.</span>dp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Velocity.Zero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.compose.animation.core.Animatable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.animation.core.VectorConverter</span><br><span class="line"><span class="keyword">import</span> androidx.compose.animation.core.tween</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.MutatePriority</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.MutatorMutex</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.Box</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.offset</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.CircularProgressIndicator</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.*</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Alignment</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.geometry.Offset</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.input.nestedscroll.NestedScrollConnection</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.input.nestedscroll.NestedScrollSource</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.input.nestedscroll.nestedScroll</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.layout.SubcomposeLayout</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.platform.LocalDensity</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.Flow</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.MutableStateFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartSwipeRefreshState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mutatorMutex = MutatorMutex()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> indicatorOffsetAnimatable = Animatable(<span class="number">0.</span>dp, Dp.VectorConverter)</span><br><span class="line">    <span class="keyword">val</span> indicatorOffset <span class="keyword">get</span>() = indicatorOffsetAnimatable.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _indicatorOffsetFlow  = MutableStateFlow(<span class="number">0f</span>)</span><br><span class="line">    <span class="keyword">val</span> indicatorOffsetFlow: Flow&lt;<span class="built_in">Float</span>&gt; <span class="keyword">get</span>() = _indicatorOffsetFlow</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isSwipeInProgress <span class="keyword">by</span> derivedStateOf &#123; indicatorOffset != <span class="number">0.</span>dp &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isRefreshing: <span class="built_in">Boolean</span> <span class="keyword">by</span> mutableStateOf(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateOffsetDelta</span><span class="params">(value: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">        _indicatorOffsetFlow.value = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">snapToOffset</span><span class="params">(value: <span class="type">Dp</span>)</span></span> &#123;</span><br><span class="line">        mutatorMutex.mutate(MutatePriority.UserInput) &#123;</span><br><span class="line">            indicatorOffsetAnimatable.snapTo(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">animateToOffset</span><span class="params">(value: <span class="type">Dp</span>)</span></span> &#123;</span><br><span class="line">        mutatorMutex.mutate &#123;</span><br><span class="line">            indicatorOffsetAnimatable.animateTo(value, tween(<span class="number">1000</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SwipeRefreshNestedScrollConnection</span>(</span><br><span class="line">    <span class="keyword">val</span> state: SmartSwipeRefreshState,</span><br><span class="line">    <span class="keyword">val</span> height: Dp</span><br><span class="line">): NestedScrollConnection &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreScroll</span><span class="params">(available: <span class="type">Offset</span>, source: <span class="type">NestedScrollSource</span>)</span></span>: Offset &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;NestedScrollConnection&quot;</span>, <span class="string">&quot;onPreScroll&quot;</span>)</span><br><span class="line">        <span class="comment">// 上滑时，我们希望滑动手势首先被父布局消费（减小加载指示器的偏移量），</span></span><br><span class="line">        <span class="comment">// 如果加载指示器还未出现，则不需要进行消费。剩余的滑动手势事件会交给子布局列表继续进行消费。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (source == NestedScrollSource.Drag &amp;&amp; available.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            state.updateOffsetDelta(available.y)</span><br><span class="line">            <span class="keyword">if</span> (state.isSwipeInProgress) Offset(x = <span class="number">0f</span>, y = available.y) <span class="keyword">else</span> Offset.Zero</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Offset.Zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostScroll</span><span class="params">(consumed: <span class="type">Offset</span>, available: <span class="type">Offset</span>, source: <span class="type">NestedScrollSource</span>)</span></span>: Offset &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;NestedScrollConnection&quot;</span>, <span class="string">&quot;onPostScroll&quot;</span>)</span><br><span class="line">        <span class="comment">// 指向下滑时，我们希望滑动手势首先交给子布局中的列表进行处理，</span></span><br><span class="line">        <span class="comment">// 如果列表已经滑到顶部说明此时滑动手势事件没有被消费，此时再交由父布局进行消费。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (source == NestedScrollSource.Drag &amp;&amp; available.y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state.updateOffsetDelta(available.y)</span><br><span class="line">            Offset(x = <span class="number">0f</span>, y = available.y)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Offset.Zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreFling</span><span class="params">(available: <span class="type">Velocity</span>)</span></span>: Velocity &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;NestedScrollConnection&quot;</span>, <span class="string">&quot;onPreFling&quot;</span>)</span><br><span class="line">        <span class="comment">// 如果加载指示器已经被拖动并超过一半，则应该吸附到加载状态，否则就收缩回初始状态。</span></span><br><span class="line">        <span class="keyword">if</span> (state.indicatorOffset &gt; height / <span class="number">2</span>) &#123;</span><br><span class="line">            state.animateToOffset(height)</span><br><span class="line">            state.isRefreshing = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state.animateToOffset(<span class="number">0.</span>dp)</span><br><span class="line">            state.isRefreshing = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onPreFling(available)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostFling</span><span class="params">(consumed: <span class="type">Velocity</span>, available: <span class="type">Velocity</span>)</span></span>: Velocity &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;NestedScrollConnection&quot;</span>, <span class="string">&quot;onPostFling&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (available.y &lt;= <span class="number">0</span> &amp;&amp; state.indicatorOffset &lt;= <span class="number">0.</span>dp &amp;&amp; state.isRefreshing) &#123;</span><br><span class="line">            state.isRefreshing = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onPostFling(consumed, available)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SubcomposeSmartSwipeRefresh</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    indicator: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> (<span class="type">Dp</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    SubcomposeLayout &#123; constraints: Constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> indicatorPlaceable = subcompose(<span class="string">&quot;indicator&quot;</span>, indicator).first().measure(constraints)</span><br><span class="line">        <span class="keyword">val</span> contentPlaceable = subcompose(<span class="string">&quot;content&quot;</span>) &#123;</span><br><span class="line">            content(indicatorPlaceable.height.toDp())</span><br><span class="line">        &#125;.map &#123;</span><br><span class="line">            it.measure(constraints)</span><br><span class="line">        &#125;.first()</span><br><span class="line">        Log.d(<span class="string">&quot;SmartSwipeRefresh&quot;</span>,<span class="string">&quot;dp: <span class="subst">$&#123;indicatorPlaceable.height.toDp()&#125;</span>&quot;</span>)</span><br><span class="line">        layout(contentPlaceable.width, contentPlaceable.height) &#123;</span><br><span class="line">            contentPlaceable.placeRelative(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A smart refresh component can customize your slide refresh animation component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onRefresh: Refreshing behavior of data when sliding down.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> state: The state contains some refresh state info.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadingIndicator: Specify the refresh animation component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content: Some slidable components need to be included here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SmartSwipeRefresh</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onRefresh: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    state: <span class="type">SmartSwipeRefreshState</span> = remember &#123; SmartSwipeRefreshState()</span></span> &#125;,</span><br><span class="line">    loadingIndicator: <span class="meta">@Composable</span> () -&gt; <span class="built_in">Unit</span> = &#123; CircularProgressIndicator() &#125;,</span><br><span class="line">    content: <span class="meta">@Composable</span> () -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line">    SubcomposeSmartSwipeRefresh(indicator = loadingIndicator) &#123; height -&gt;</span><br><span class="line">        <span class="keyword">val</span> connection = remember(state, height) &#123;</span><br><span class="line">            SwipeRefreshNestedScrollConnection(state, height)</span><br><span class="line">        &#125;</span><br><span class="line">        Box(</span><br><span class="line">            Modifier.nestedScroll(connection),</span><br><span class="line">            contentAlignment = Alignment.TopCenter</span><br><span class="line">        ) &#123;</span><br><span class="line">            Box(Modifier.offset(y = -height + state.indicatorOffset)) &#123;</span><br><span class="line">                loadingIndicator()</span><br><span class="line">            &#125;</span><br><span class="line">            Box(Modifier.offset(y = state.indicatorOffset)) &#123;</span><br><span class="line">                content()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> density = LocalDensity.current</span><br><span class="line">        LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">            state.indicatorOffsetFlow.collect &#123;</span><br><span class="line">                <span class="keyword">val</span> currentOffset = with(density) &#123; state.indicatorOffset + it.toDp() &#125;</span><br><span class="line">                state.snapToOffset(currentOffset.coerceAtLeast(<span class="number">0.</span>dp).coerceAtMost(height))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LaunchedEffect(state.isRefreshing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.isRefreshing) &#123;</span><br><span class="line">                onRefresh()</span><br><span class="line">                state.animateToOffset(<span class="number">0.</span>dp)</span><br><span class="line">                state.isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NestedScrollExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="keyword">by</span> remember &#123; mutableStateOf((<span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>).toList()) &#125;</span><br><span class="line">    <span class="keyword">val</span> lazyListState =  rememberLazyListState()</span><br><span class="line">    SmartSwipeRefresh(</span><br><span class="line">        onRefresh = &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            list = list.shuffled()</span><br><span class="line">            lazyListState.scrollToItem(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        LazyColumn(</span><br><span class="line">            contentPadding = PaddingValues(<span class="number">15.</span>dp),</span><br><span class="line">            verticalArrangement = Arrangement.spacedBy(<span class="number">10.</span>dp),</span><br><span class="line">            state = lazyListState</span><br><span class="line">        ) &#123;</span><br><span class="line">            items(list, key = &#123; it &#125;) &#123; item -&gt;</span><br><span class="line">                Card(</span><br><span class="line">                    elevation = <span class="number">8.</span>dp,</span><br><span class="line">                    modifier = Modifier.fillMaxWidth().height(<span class="number">100.</span>dp),</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Box(</span><br><span class="line">                        Modifier.fillMaxSize().padding(<span class="number">15.</span>dp),</span><br><span class="line">                        contentAlignment = Alignment.Center</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        Text(text = <span class="string">&quot;Item <span class="variable">$item</span>&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="低级事件处理-API"><a href="#低级事件处理-API" class="headerlink" title="低级事件处理 API"></a>低级事件处理 API</h2><p>以上介绍的所有高级事件处理 API 都是基于低级别的事件处理 API 实现的，下面是 Compose 中的低级别的事件处理 API 的分类概图：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1244b545d251f60d0c7de34ed442a79d.png" alt="在这里插入图片描述"></p>
<h3 id="PointerInput"><a href="#PointerInput" class="headerlink" title="PointerInput"></a>PointerInput</h3><p>前面 <code>Draggable</code> 修饰符、<code>Swipeable</code> 修饰符、<code>Transformable</code> 修饰符以及 <code>NestedScroll</code> 修饰符都是基于低级别的 <code>PointerInput</code> 修饰符进行封装实现的，所以弄清楚 <code>PointerInput</code> 修饰符的使用方法，有助于我们对高级别手势处理修饰符的理解，并且能够帮助我们更好的完成上层开发实现各种复杂的手势需求。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">pointerInput</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">vararg</span> keys: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">PointerInputScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Modifier = composed(</span><br><span class="line">    ...</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">    remember(density) &#123; SuspendingPointerInputFilter(viewConfiguration, density) &#125;.apply &#123;</span><br><span class="line">        LaunchedEffect(<span class="keyword">this</span>, *keys) &#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>PointerInput</code> 修饰符时我们需要传入两个参数，<code>keys</code> 与 <code>block</code>。</p>
<ul>
<li><strong><code>keys</code></strong>：当 <code>Composable</code> 组件发生重组时，如果传入的 <code>keys</code> 发生了变化，则手势事件处理过程会被中断。</li>
<li><strong><code>block</code></strong>：在这个 <code>PointerInputScope</code> 类型作用域代码块中，便可以声明手势事件处理逻辑了。通过 <code>suspend</code> 关键字可知这是一个挂起函数，这意味着在 <code>Compose</code> 中手势处理最终都发生在协程中。</li>
</ul>
<p>我们在 <code>PointerInputScope</code> 接口声明中能够找到所有可用的手势处理方法，我们可以通过这些方法获取到更加详细的手势信息以及更加细粒度的手势事件处理。</p>
<h3 id="拖动类型基础-API"><a href="#拖动类型基础-API" class="headerlink" title="拖动类型基础 API"></a><strong>拖动类型基础 API</strong></h3><table>
<thead>
<tr>
<th align="left">API名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>detectDragGestures</code></strong></td>
<td align="left"><strong>监听拖动手势</strong></td>
</tr>
<tr>
<td align="left"><strong><code>detectDragGesturesAfterLongPress</code></strong></td>
<td align="left"><strong>监听长按后的拖动手势</strong></td>
</tr>
<tr>
<td align="left"><strong><code>detectHorizontalDragGestures</code></strong></td>
<td align="left"><strong>监听水平拖动手势</strong></td>
</tr>
<tr>
<td align="left"><strong><code>detectVerticalDragGestures</code></strong></td>
<td align="left"><strong>监听垂直拖动手势</strong></td>
</tr>
</tbody></table>
<p>这类拖动监听 API 功能上相类似，使用时需要传入参数也比较相近。我们可以根据实际情况来选用不同 API。在使用这些 API 时，我们可以定制在不同时机的处理回调，以 <strong><code>detectDragGestures</code></strong> 为例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> PointerInputScope.<span class="title">detectDragGestures</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    onDragStart: (<span class="type">Offset</span>) -&gt; <span class="type">Unit</span> = &#123; &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onDragEnd: () -&gt; <span class="type">Unit</span> = &#123; &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onDragCancel: () -&gt; <span class="type">Unit</span> = &#123; &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onDrag: (<span class="type">change</span>: <span class="type">PointerInputChange</span>, <span class="type">dragAmount</span>: <span class="type">Offset</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>这里提供了4个回调时机，<code>onDragStart</code> 会在拖动开始时回调，<code>onDragEnd</code> 会在拖动结束时回调，<code>onDragCancel</code> 会在拖动取消时回调，而 <code>onDrag</code> 则会在拖动真正发生时回调。</p>
<blockquote>
<p>注意：<code>onDragCancel</code> 触发时机多发生于滑动冲突的场景，子组件可能最开始是可以获取到拖动事件的，当拖动手势事件达到莫个指定条件时可能会被父组件劫持消费，这种场景下便会执行 <code>onDragCancel</code> 回调。所以 <code>onDragCancel</code> 回调主要依赖于实际业务逻辑。</p>
</blockquote>
<p>我们可以利用 <code>detectDragGestures</code> 轻松的实现拖动手势监听：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DragGestureDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">by</span> remember &#123; mutableStateOf(Offset.Zero) &#125;</span><br><span class="line">    <span class="keyword">var</span> dragState <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">    Box(contentAlignment = Alignment.Center,</span><br><span class="line">        modifier = Modifier.fillMaxSize()</span><br><span class="line">    ) &#123;</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">100.</span>dp)</span><br><span class="line">            .offset &#123; IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) &#125;</span><br><span class="line">            .background(Color.Green)</span><br><span class="line">            .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                detectDragGestures(</span><br><span class="line">                    onDragStart = &#123; offset -&gt;</span><br><span class="line">                        dragState = <span class="string">&quot;拖动开始了～&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    onDragEnd = &#123;</span><br><span class="line">                        dragState = <span class="string">&quot;拖动结束了～&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    onDragCancel = &#123;</span><br><span class="line">                        dragState = <span class="string">&quot;拖动取消了～&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    onDrag = &#123; change: PointerInputChange, dragAmount: Offset -&gt;</span><br><span class="line">                        dragState = <span class="string">&quot;拖动中～<span class="variable">$dragAmount</span>&quot;</span></span><br><span class="line">                        offset += dragAmount</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        Text(text = dragState,</span><br><span class="line">            Modifier.align(Alignment.TopCenter).padding(top = <span class="number">35.</span>dp),</span><br><span class="line">            fontSize = <span class="number">22.</span>sp</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/5ee46b2603b4d600c4d931753d25067b.gif"></p>
<h3 id="点击类型基础-API"><a href="#点击类型基础-API" class="headerlink" title="点击类型基础 API"></a><strong>点击类型基础 API</strong></h3><table>
<thead>
<tr>
<th>API名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>detectTapGestures</code></strong></td>
<td><strong>监听点击手势</strong></td>
</tr>
</tbody></table>
<p>在 <code>PointerInputScope</code> 中，我们可以使用 <strong><code>detectTapGestures</code></strong> 设置更细粒度的点击监听回调。作为低级别点击监听 API，在发生点击时<strong>不会带有</strong>像 <code>Clickable</code> 修饰符与 <code>CombinedClickable</code> 修饰符那样会为所修饰的组件施加一个<strong>涟漪波纹效果</strong>动画的蒙层，我们能够根据需要进行更灵活的上层定制。</p>
<p><strong><code>detectTapGestures</code></strong> 提供了四个可选事件回调，可以根据需求来设置不同点击事件回调。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> PointerInputScope.<span class="title">detectTapGestures</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  onDoubleTap: ((<span class="type">Offset</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>, <span class="comment">// 双击时回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">  onLongPress: ((<span class="type">Offset</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>, <span class="comment">// 长按时回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">  onPress: <span class="type">suspend</span> <span class="type">PressGestureScope</span>.(<span class="type">Offset</span>) -&gt; <span class="type">Unit</span> = NoPressGesture, <span class="comment">// 按下时回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">  onTap: ((<span class="type">Offset</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span> <span class="comment">// 轻触时回调</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>这几种点击事件回调存在着先后次序的，并不是每次只会执行其中一个。<code>onPress</code> 是最普通的 <code>ACTION_DOWN</code> 事件，你的手指一旦按下便会回调。如果你连着按了两下，则会在执行两次 <code>onPress</code> 后执行 <code>onDoubleTap</code>。如果你的手指按下后不抬起，当达到长按的判定阈值 (<code>400ms</code>) 会执行 <code>onLongPress</code>。如果你的手指按下后快速抬起，在轻触的判定阈值内(<code>100ms</code>)会执行 <code>onTap</code> 回调。</p>
<p>总的来说， <code>onDoubleTap</code> 回调前必定会先回调 <code>2</code> 次 <code>onPress</code>，而 <code>onLongPress</code> 与 <code>onTap</code> 回调前必定会回调 <code>1</code> 次 <code>onPress</code>。</p>
<p><code>detectTapGestures</code> 使用起来非常简单，我们根据需求来设置不同点击事件回调即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TapGestureDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dragState <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) &#123;</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">100.</span>dp)</span><br><span class="line">            .background(Color.Green)</span><br><span class="line">            .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                detectTapGestures(</span><br><span class="line">                    onDoubleTap = &#123; offset: Offset -&gt;</span><br><span class="line">                        dragState = <span class="string">&quot;发生双击操作了～&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    onLongPress = &#123; offset: Offset -&gt;</span><br><span class="line">                        dragState = <span class="string">&quot;发生长按操作了～&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    onPress = &#123;  offset: Offset -&gt;</span><br><span class="line">                        dragState = <span class="string">&quot;发生按下操作了～&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    onTap = &#123;  offset: Offset -&gt;</span><br><span class="line">                        dragState = <span class="string">&quot;发生轻触操作了～&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        Text(text = dragState,</span><br><span class="line">            Modifier.align(Alignment.TopCenter).padding(top = <span class="number">35.</span>dp),</span><br><span class="line">            fontSize = <span class="number">22.</span>sp</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d889d97d6c9f5d8042048fff12d87752.gif" alt="在这里插入图片描述"></p>
<h3 id="变换类型基础-API"><a href="#变换类型基础-API" class="headerlink" title="变换类型基础 API"></a>变换类型基础 API</h3><table>
<thead>
<tr>
<th>API名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>detectTransformGestures</code></strong></td>
<td><strong>监听拖动、缩放与旋转手势</strong></td>
</tr>
</tbody></table>
<p>使用 <strong><code>detectTransformGestures</code></strong> 可以获取到双指拖动、缩放与旋转手势操作中更具体的手势信息，例如重心。</p>
<p>与 <code>Tranformable</code> 修饰符一样，<code>detectTransformGestures</code> 方法提供了两个参数。</p>
<ul>
<li><strong><code>panZoomLock</code></strong>(可选)： 当拖动或缩放手势发生时是否支持旋转</li>
<li><strong><code>onGesture</code></strong>(必须)：当拖动、缩放或旋转手势发生时回调</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> PointerInputScope.<span class="title">detectTransformGestures</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    panZoomLock: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onGesture: (<span class="type">centroid</span>: <span class="type">Offset</span>, <span class="type">pan</span>: <span class="type">Offset</span>, <span class="type">zoom</span>: <span class="type">Float</span>, <span class="type">rotation</span>: <span class="type">Float</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>与 <code>Tranformable</code> 修饰符不同的是，通过这个 API 可以监听单指的拖动手势，和拖动类型基础 API所提供的功能一样，除此之外还支持监听双指缩放与旋转手势。反观 <code>Tranformable</code> 修饰符只能监听到双指拖动手势，不知设计成这样的行为不一致是否是官方有意为之。</p>
<p>使用起来十分简单，我们仅需根据手势信息来更新状态就可以了。当我们处理旋转、缩放与拖动这类手势时，需要格外的注意 <code>Modifier</code> 调用次序，因为这会影响最终呈现效果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TransformGestureDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> boxSize = <span class="number">200.</span>dp</span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">by</span> remember &#123; mutableStateOf(Offset.Zero) &#125;</span><br><span class="line">    <span class="keyword">var</span> rotationAngle <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> scale <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">1f</span>) &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) &#123;</span><br><span class="line">        Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.ic_sky),</span><br><span class="line">            contentScale = ContentScale.Crop,</span><br><span class="line">            contentDescription = <span class="literal">null</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(boxSize)</span><br><span class="line">                .rotate(rotationAngle) <span class="comment">// 注意rotate的顺序应该先于offset</span></span><br><span class="line">                .offset &#123; IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) &#125;</span><br><span class="line">                .scale(scale)</span><br><span class="line">                .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                    detectTransformGestures(</span><br><span class="line">                        panZoomLock = <span class="literal">true</span>, <span class="comment">// 平移或放大时是否可以旋转</span></span><br><span class="line">                        onGesture = &#123; centroid: Offset, pan: Offset, zoom: <span class="built_in">Float</span>, rotation: <span class="built_in">Float</span> -&gt;</span><br><span class="line">                            offset += pan</span><br><span class="line">                            scale *= zoom</span><br><span class="line">                            rotationAngle += rotation</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a5462e8a608b54867bd59f3260b72256.gif"></p>
<blockquote>
<p>注意：</p>
<ul>
<li>关于<code>panZoomLock</code>参数，如果值为 <code>true</code> ，则仅当在平移或缩放运动之前检测到旋转时才允许旋转。如果没有，平移和缩放手势将被检测，但旋转手势将不会被检测。如果值为 <code>false</code> ，一旦触摸slop到达，所有三个手势都将被检测到。</li>
<li><code>onGesture</code> 方法的几个参数中，<code>centroid</code> 是多指触摸的中心点，而 <code>pan</code>、<code>zoom</code>、<code>rotation</code>都是针对上一次状态的增量，而不是相对原始状态的。另外，在一次回调中这几个参数是有可能同时发生变化的，即在缩放的同时可以平移旋转。</li>
</ul>
</blockquote>
<h3 id="手势事件作用域-awaitPointerEventScope"><a href="#手势事件作用域-awaitPointerEventScope" class="headerlink" title="手势事件作用域 awaitPointerEventScope"></a>手势事件作用域 awaitPointerEventScope</h3><p>我们前面介绍的 <code>GestureDetector</code> 系列 API 本质上仍然是一种封装，既然手势处理是在协程中完成的，所以<strong>手势监听必然是通过协程的挂起恢复实现的，以取代传统的回调监听方式</strong>。要想深入理解 Compose 手势处理，就需要学习更为底层的手势处理挂起方法。</p>
<p>在 <code>PointerInputScope</code> 中我们使用 <code>awaitPointerEventScope</code> 方法获得 <code>AwaitPointerEventScope</code> 作用域，在 <code>AwaitPointerEventScope</code> 作用域中我们可以使用 Compose 中所有低级别的手势处理挂起方法。当 <code>awaitPointerEventScope</code> 内所有手势事件都处理完成后 <code>awaitPointerEventScope</code> 便会恢复执行将 <code>Lambda</code> 中最后一行表达式的数值作为返回值返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">awaitPointerEventScope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">AwaitPointerEventScope</span>.() -&gt; <span class="type">R</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: R</span><br></pre></td></tr></table></figure>

<p>我们在 <strong>AwaitPointerEventScope</strong> 中发现了以下这些基础手势方法，可以发现这些 API 均是挂起函数</p>
<table>
<thead>
<tr>
<th align="left">API名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>awaitPointerEvent</code></strong></td>
<td align="left"><strong>手势事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitFirstDown</code></strong></td>
<td align="left"><strong>第一根手指的按下事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>drag</code></strong></td>
<td align="left"><strong>拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>horizontalDrag</code></strong></td>
<td align="left"><strong>水平拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>verticalDrag</code></strong></td>
<td align="left"><strong>垂直拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitDragOrCancellation</code></strong></td>
<td align="left"><strong>单次拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitHorizontalDragOrCancellation</code></strong></td>
<td align="left"><strong>单次水平拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitVerticalDragOrCancellation</code></strong></td>
<td align="left"><strong>单次垂直拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitTouchSlopOrCancellation</code></strong></td>
<td align="left"><strong>有效拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitHorizontalTouchSlopOrCancellation</code></strong></td>
<td align="left"><strong>有效水平拖动事件</strong></td>
</tr>
<tr>
<td align="left"><strong><code>awaitVerticalTouchSlopOrCancellation</code></strong></td>
<td align="left"><strong>有效垂直拖动事件</strong></td>
</tr>
</tbody></table>
<h3 id="事件之源-awaitPointerEvent"><a href="#事件之源-awaitPointerEvent" class="headerlink" title="事件之源 awaitPointerEvent"></a>事件之源 awaitPointerEvent</h3><p>之所以称这个 API 为<strong>事件之源</strong>，因为上层所有手势监听 API 都是基于这个 API 实现的，他的作用类似于传统 <code>View</code> 中的 <code>onTouchEvent()</code> 。无论用户是按下、移动或抬起都将视作一次手势事件，当手势事件发生时 <code>awaitPointerEvent</code> 便会恢复返回监听到的屏幕上所有手指的交互信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">forEachGesture &#123;</span><br><span class="line">    awaitPointerEventScope &#123;</span><br><span class="line">        <span class="keyword">var</span> event = awaitPointerEvent()</span><br><span class="line">        println(<span class="string">&quot;x: <span class="subst">$&#123;event.changes[<span class="number">0</span>].position.x&#125;</span>, y: <span class="subst">$&#123;event.changes[<span class="number">0</span>].position.y&#125;</span>, type: <span class="subst">$&#123;event.type&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>event.type</code>返回事件的类型，例如<code>PointerEventType.Press</code>、<code>PointerEventType.Move</code>、<code>PointerEventType.Release</code>它们分别对应传统 <code>View</code> 中的<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">awaitPointerEventScope &#123;</span><br><span class="line">     <span class="keyword">val</span> event = awaitPointerEvent()</span><br><span class="line">     <span class="keyword">if</span> (event.type == PointerEventType.Press) &#123;</span><br><span class="line">         println(<span class="string">&quot;按下&quot;</span>)</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == PointerEventType.Move) &#123;</span><br><span class="line">         println(<span class="string">&quot;移动&quot;</span>)</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == PointerEventType.Release) &#123;</span><br><span class="line">         println(<span class="string">&quot;抬起&quot;</span>)</span><br><span class="line">     &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>awaitPointerEvent()</code> 是挂起函数，因此可以在 <code>awaitPointerEventScope</code> 作用域内，每次调用完上一次的等待之后，继续等待下一次的手势到来：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awaitPointerEventScope &#123;</span><br><span class="line">     <span class="keyword">var</span> event = awaitPointerEvent()</span><br><span class="line">     println(<span class="string">&quot;当前事件类型type: <span class="subst">$&#123;event.type&#125;</span>&quot;</span>)</span><br><span class="line">     event = awaitPointerEvent()</span><br><span class="line">     println(<span class="string">&quot;当前事件类型type: <span class="subst">$&#123;event.type&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p>实际上 <strong>awaitPointerEvent</strong> 存在着一个可选参数 <strong><code>PointerEventPass</code></strong>，这个参数实际上是用来定制手势事件分发顺序的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">awaitPointerEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pass: <span class="type">PointerEventPass</span> = PointerEventPass.Main</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: PointerEvent</span><br></pre></td></tr></table></figure>

<p><strong>PointerEventPass</strong> 有 3 个枚举值，可以让我们来决定手势的处理阶段。在 Compose 中，手势处理共有3个阶段：</p>
<ul>
<li><strong>Initial 阶段</strong>：<strong>自上而下</strong>的分发手势事件</li>
<li><strong>Main 阶段</strong>：<strong>自下而上</strong>的分发手势事件</li>
<li><strong>Final 阶段</strong>：<strong>自上而下</strong>的分发手势事件</li>
</ul>
<p><strong>awaitPointerEvent</strong> 的<code>pass</code>参数默认值是<strong>Main</strong>，也就是该方法默认是捕获<strong>自下而上</strong>分发的手势事件。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4e7b578f68bbfb321ef37ab77e540a3a.png" alt="在这里插入图片描述"><br>（注：这里的上下其实是指嵌套的父子组件的关系，可以理解为UI组件树中的上下游）</p>
<p>在 <strong>Inital</strong> 阶段，手势事件会在所有使用 <strong>Inital</strong> 参数的组件间<strong>自上而下</strong>的完成首次分发。利用 <strong>Inital</strong> 可以使<strong>父组件能够预先劫持消费手势事件</strong>，这类似于传统 <strong>View</strong> 中 <strong>onInterceptTouchEvent</strong> 的作用。</p>
<p>在 <strong>Main</strong> 阶段，手势事件会在所有使用 <strong>Main</strong> 参数的组件间<strong>自下而上</strong>的完成第二次分发。利用 <strong>Main</strong> 可以使<strong>子组件能先于父组件完成手势事件的处理</strong>，这有些类似于传统 <strong>View</strong> 中 <strong>onTouchEvent</strong> 的作用。</p>
<p>在 <strong>Final</strong> 阶段，手势事件会在所有使用 <strong>Final</strong> 参数的组件间<strong>自上而下</strong>的完成最后一次分发。<strong>Final</strong> 阶段一般用来让组件了解经历过前面几个阶段后的手势事件消费情况，从而确定自身行为。例如按钮组件可以不用手指从按钮上移动开的事件，因为这个事件可能已被父组件滚动器用于滚动消费了。</p>
<p>接下来我们通过一个嵌套组件的手势监听来演示事件的分发过程。</p>
<p>当所有组件的手势监听均默认使用 <strong>Main</strong> 时，点击中间的Box，事件分发顺序为：<strong>第三层 –&gt; 第二层 –&gt; 第一层</strong></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8f97bc25dce493a52e1202a097538559.png" alt="在这里插入图片描述"></p>
<p>而如果第一层组件使用 <strong>Inital</strong>，第二层组件使用 <strong>Final</strong> ，第三层组件使用 <strong>Main</strong>，事件分发顺序为：<strong>第一层 –&gt; 第三层 –&gt; 第二层</strong></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/57615d0594db547c6841cbf7c5e3f877.png" alt="在这里插入图片描述"></p>
<p>接下来，我们换作四层嵌套来观察手势事件的分发，其中第一层与第三层使用 <strong>Initial</strong>，第二层使用 <strong>Final</strong>，第四层使用 <strong>Main</strong>，事件分发顺序为：<strong>第一层 –&gt; 第三层 –&gt; 第四层 –&gt; 第二层</strong></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/93a387eeefc862a6266d955683ad6aad.png" alt="在这里插入图片描述"></p>
<p>测试代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NestedBoxDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;执行顺序：\n&quot;</span>) &#125;</span><br><span class="line">    Box(Modifier.myBox(<span class="number">300.</span>dp, Color.Red, PointerEventPass.Initial) &#123;</span><br><span class="line">            result += <span class="string">&quot;第一层\n&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Box(Modifier.myBox(<span class="number">250.</span>dp, Color.Blue, PointerEventPass.Final) &#123;</span><br><span class="line">                result += <span class="string">&quot;第二层\n&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            contentAlignment = Alignment.Center</span><br><span class="line">        ) &#123;</span><br><span class="line">            Box(Modifier.myBox(<span class="number">200.</span>dp, Color.Green, PointerEventPass.Initial) &#123;</span><br><span class="line">                    result += <span class="string">&quot;第三层\n&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                contentAlignment = Alignment.Center</span><br><span class="line">            ) &#123;</span><br><span class="line">                Box(Modifier.myBox(<span class="number">150.</span>dp, Color.Yellow, PointerEventPass.Main) &#123;</span><br><span class="line">                        result += <span class="string">&quot;第四层\n&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    contentAlignment = Alignment.Center</span><br><span class="line">                ) &#123;</span><br><span class="line">                    Text(text = result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myBox</span><span class="params">(size: <span class="type">Dp</span>, color: <span class="type">Color</span>, pass: <span class="type">PointerEventPass</span>, block: ()-&gt;<span class="type">Unit</span>)</span></span>: Modifier &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size(size).background(color).pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">            awaitPointerEventScope &#123;</span><br><span class="line">                awaitPointerEvent(pass)</span><br><span class="line">                block()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/74f9b2ac6178f500eba8cbe5e1ad01e1.gif" alt="在这里插入图片描述"></p>
<h3 id="事件消费"><a href="#事件消费" class="headerlink" title="事件消费"></a>事件消费</h3><p>我们看到 <strong><code>awaitPointerEvent</code></strong> 返回了一个 <strong><code>PointerEvent</code></strong> 实例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actual</span> <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">PointerEvent</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">actual</span> <span class="keyword">val</span> changes: List&lt;PointerInputChange&gt;,</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> motionEvent: MotionEvent?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>从 <strong>PointerEvent</strong> 类的声明中可以看到包含了两个属性 <strong><code>changes</code></strong> 与 <strong><code>motionEvent</code></strong>。</p>
<ul>
<li><strong><code>motionEvent</code></strong>：实际上就是传统 <strong>View</strong> 系统中的 <strong>MotionEvent</strong>，由于被声明 <strong>internal</strong> ，说明官方并不希望我们直接拿来使用。</li>
<li><strong><code>changes</code></strong>：其中包含了一次手势交互中所有手指的交互信息。在多指操作时，利用 <strong>changes</strong> 可以轻松定制多指手势处理。</li>
</ul>
<p>可以看出<strong>单指交互的完整信息被封装在了一个 PointerInputChange 实例中</strong>，接下来看看 <strong>PointerInputChange</strong> 提供了哪些手势信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PointerInputChange</span>(</span><br><span class="line">    <span class="keyword">val</span> id: PointerId, <span class="comment">// 手指Id</span></span><br><span class="line">    <span class="keyword">val</span> uptimeMillis: <span class="built_in">Long</span>, <span class="comment">// 当前手势事件的时间戳</span></span><br><span class="line">    <span class="keyword">val</span> position: Offset, <span class="comment">// 当前手势事件相对组件左上角的位置</span></span><br><span class="line">    <span class="keyword">val</span> pressed: <span class="built_in">Boolean</span>, <span class="comment">// 当前手势是否按下</span></span><br><span class="line">    <span class="keyword">val</span> previousUptimeMillis: <span class="built_in">Long</span>, <span class="comment">// 上一次手势事件的时间戳</span></span><br><span class="line">    <span class="keyword">val</span> previousPosition: Offset, <span class="comment">// 上一次手势事件相对组件左上角的位置</span></span><br><span class="line">    <span class="keyword">val</span> previousPressed: <span class="built_in">Boolean</span>, <span class="comment">// 上一次手势是否按下</span></span><br><span class="line">    <span class="keyword">val</span> consumed: ConsumedData, <span class="comment">// 当前手势是否已被消费</span></span><br><span class="line">    <span class="keyword">val</span> type: PointerType = PointerType.Touch <span class="comment">// 手势类型(鼠标、手指、手写笔、橡皮) </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>利用这些丰富的手势信息，我们可以在上层定制实现各类复杂的交互手势。</p>
<p>可以看到其中的 <strong><code>consumed</code></strong> 成员记录着该事件是否已被消费，我们可以使用 <strong>PointerInputChange</strong> 提供的 <strong>consume</strong> 系列 API 来修改这个手势事件的消费标记。</p>
<table>
<thead>
<tr>
<th align="left">API名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>changedToDown</code></strong></td>
<td align="left"><strong>是否已经按下(按下手势已消费则返回false)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>changedToDownIgnoreConsumed</code></strong></td>
<td align="left"><strong>是否已经按下(忽略按下手势已消费标记)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>changedToUp</code></strong></td>
<td align="left"><strong>是否已经抬起(按下手势已消费则返回false)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>changedToUpIgnoreConsumed</code></strong></td>
<td align="left"><strong>是否已经抬起(忽略按下手势已消费标记)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>positionChanged</code></strong></td>
<td align="left"><strong>是否位置发生了改变(移动手势已消费则返回false)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>positionChangedIgnoreConsumed</code></strong></td>
<td align="left"><strong>是否位置发生了改变(忽略已消费标记)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>positionChange</code></strong></td>
<td align="left"><strong>位置改变量(移动手势已消费则返回Offset.Zero)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>positionChangeIgnoreConsumed</code></strong></td>
<td align="left"><strong>位置改变量(忽略移动手势已消费标记)</strong></td>
</tr>
<tr>
<td align="left"><strong><code>isConsumed</code></strong></td>
<td align="left"><strong>当前手势是否已被消费</strong></td>
</tr>
<tr>
<td align="left"><strong><code>consumeDownChange</code></strong></td>
<td align="left"><strong>消费按下手势</strong></td>
</tr>
<tr>
<td align="left"><strong><code>consumePositionChange</code></strong></td>
<td align="left"><strong>消费移动手势</strong></td>
</tr>
<tr>
<td align="left"><strong><code>consumeAllChanges</code></strong></td>
<td align="left"><strong>消费按下与移动手势</strong></td>
</tr>
<tr>
<td align="left"><strong><code>isOutOfBounds</code></strong></td>
<td align="left"><strong>当前手势是否在固定范围内</strong></td>
</tr>
</tbody></table>
<p>前面提到，我们可以通过设置 <strong>PointerEventPass</strong> 来定制嵌套组件间手势事件分发顺序。假设分发流程中组件 <strong>A</strong> 预先获取到了手势信息并进行消费，手势事件仍然会被之后的组件 <strong>B</strong> 获取得到。组件 <strong>B</strong> 在使用 <strong>positionChange</strong> 获取的偏移值时会返回 <strong>Offset.ZERO</strong>，这是因为此时该手势事件已被标记为已消费的状态。当然组件 <strong>B</strong> 也可以通过 <strong>IgnoreConsumed</strong> 系列 API 突破已消费标记的限制获取到手势信息。</p>
<p>我们仍然通过前面使用的嵌套组件示例子来看看手势事件的消费。我们的嵌套组件中第一层组件使用 <strong>Inital</strong>，第二层组件使用 <strong>Final</strong> ，第三层组件使用 <strong>Main</strong>。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7f868127c2cf78b14d4b121a372e8721.png" alt="在这里插入图片描述"><br>我们在第三层组件的手势事件监听中进行消费，因为我们知道手势事件会交由第一层, 再交由第三层，最后交由第二层。第三层组件处于本次手势分发流程的中间位置。</p>
<p>当我们在第三层组件消费了 <strong>ACTION_DOWN</strong> 后，之后处理的第二层组件接收的手势事件仍是被标记为消费状态的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ConsumeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;消费状态：\n&quot;</span>) &#125;</span><br><span class="line">    Box(Modifier.myBox(<span class="number">300.</span>dp, Color.Red, PointerEventPass.Initial) &#123; event -&gt;</span><br><span class="line">            result +=<span class="string">&quot;第一层 isConsumed: <span class="subst">$&#123;event.changes[<span class="number">0</span>].isConsumed&#125;</span>\n&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Box(Modifier.myBox(<span class="number">250.</span>dp, Color.Blue, PointerEventPass.Final) &#123; event -&gt;</span><br><span class="line">                result += <span class="string">&quot;第二层 isConsumed: <span class="subst">$&#123;event.changes[<span class="number">0</span>].isConsumed&#125;</span>\n&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            contentAlignment = Alignment.Center</span><br><span class="line">        ) &#123;</span><br><span class="line">            Box(Modifier.myBox(<span class="number">200.</span>dp, Color.Green, PointerEventPass.Main) &#123; event -&gt;</span><br><span class="line">                    <span class="keyword">val</span> change = event.changes[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> (change.pressed != change.previousPressed) change.consume() <span class="comment">// 消费事件</span></span><br><span class="line">                    result += <span class="string">&quot;第三层 isConsumed: <span class="subst">$&#123;change.isConsumed&#125;</span>\n&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                contentAlignment = Alignment.Center</span><br><span class="line">            ) &#123;</span><br><span class="line">                Text(text = result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myBox</span><span class="params">(size: <span class="type">Dp</span>, color: <span class="type">Color</span>, pass: <span class="type">PointerEventPass</span>, block: (<span class="type">PointerEvent</span>)-&gt;<span class="type">Unit</span>)</span></span>: Modifier &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size(size).background(color).pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        awaitPointerEventScope &#123;</span><br><span class="line">            <span class="keyword">val</span> event = awaitPointerEvent(pass)</span><br><span class="line">            block(event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/38af575338344a07d0739c04b0c1bec7.gif" alt="在这里插入图片描述"></p>
<p>另外，<strong>PointerEvent</strong> 对象除了可以消费事件和判断事件是否已消费外，还提供了一些列便利函数，如<code>event.calculatePan()</code>、<code>event.calculateZoom()</code>、<code>event.calculateRotation()</code>、<code>event.calculateCentroid()</code>等等，它们返回当前状态和上一次状态之间中心点位置的变化增量，以便开发者可以处理多重手势操作。可见利用这些API几乎可以实现前面 <code>detectTransformGestures</code> 的功能。</p>
<h3 id="awaitFirstDown"><a href="#awaitFirstDown" class="headerlink" title="awaitFirstDown"></a>awaitFirstDown</h3><p><strong><code>awaitFirstDown</code></strong> 将等待直到第一根手指 <strong>ACTION_DOWN</strong> 事件时恢复执行，并将手指按下事件返回。翻阅源码可以看出其内部实现原理并不复杂。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> AwaitPointerEventScope.<span class="title">awaitFirstDown</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    requireUnconsumed: <span class="type">Boolean</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: PointerInputChange &#123;</span><br><span class="line">    <span class="keyword">var</span> event: PointerEvent</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        event = awaitPointerEvent()  <span class="comment">// 监听手势事件</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (</span><br><span class="line">        <span class="comment">// 遍历每一根手指的事件信息</span></span><br><span class="line">        !event.changes.fastAll &#123;</span><br><span class="line">            <span class="comment">// 需要没有被消费过的手势事件</span></span><br><span class="line">            <span class="keyword">if</span> (requireUnconsumed) &#123;</span><br><span class="line">                <span class="comment">// 返回该事件是否是一个还没有被消费的DOWN事件</span></span><br><span class="line">                <span class="comment">// 当返回 false 时说明是不是DOWN事件或已被消费的DOWN事件</span></span><br><span class="line">                it.changedToDown()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回该事件是否是一个DOWN事件，忽略是否已被消费</span></span><br><span class="line">                <span class="comment">// 当返回 false 时说明是不是DOWN事件</span></span><br><span class="line">                it.changedToDownIgnoreConsumed()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 返回第一根手指的事件信息</span></span><br><span class="line">    <span class="keyword">return</span> event.changes[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEachGesture"><a href="#forEachGesture" class="headerlink" title="forEachGesture"></a>forEachGesture</h3><p>前面提到 Compose 手势操作实际上是在协程中监听处理的，当协程处理完一轮手势交互后便会结束，当进行第二次手势交互时由于负责手势监听的协程已经结束，手势事件便会被丢弃掉。那我们该怎样才能让手势监听协程能够持续不断地处理每一轮的手势交互呢。我们很容易想到可以在外层嵌套一个 <code>while(true)</code> 进行实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Modifier.pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        awaitPointerEventScope &#123;</span><br><span class="line">            <span class="keyword">val</span> downEvent = awaitFirstDown()  </span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这么做并不优雅，且也存在着一些问题。</p>
<p>当用户出现一连串手势操作时，很难保证各手势之间有清晰分界，即无法保证每一轮手势结束后，所有手指都是离开屏幕的。在传统 View 体系中，一次手指按下、移动到抬起过程中的所有手势事件可以看作是一个完整的手势交互序列。每当用户触摸屏幕交互时，我们可以根据这一次用户输入的手势交互序列中的手势信息进行相应的处理。</p>
<p>当第一轮手势处理结束或者被中断取消后，如果仍有手指留在屏幕。如果采用 <code>while(true)</code> 处理手势，则第二轮手势处理可能会使用第一轮手势交互序列中信息，导致出现不符预期的结果。</p>
<p>Compose 为我们提供了 <code>forEachGesture</code> 方法保证了每一轮手势处理逻辑的一致性。实际上前面我们所介绍的 <code>GestureDetect</code> 系列 API，其内部实现都使用了 <code>forEachGesture</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Modifier.pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">    forEachGesture &#123;</span><br><span class="line">        awaitPointerEventScope &#123;</span><br><span class="line">            <span class="keyword">val</span> downEvent = awaitFirstDown()  </span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过 <code>forEachGesture</code> 的源码可知，每一轮手势处理结束后或本次手势处理被取消时，都会使用 <code>awaitAllPointersUp()</code> 保证所有手指均已抬起。并且同时也会与当前组件的生命周期对齐，当组件离开视图树时，手势监听也会随之结束。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> PointerInputScope.<span class="title">forEachGesture</span><span class="params">(block: <span class="type">suspend</span> <span class="type">PointerInputScope</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> currentContext = currentCoroutineContext()</span><br><span class="line">    <span class="keyword">while</span> (currentContext.isActive) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          block()</span><br><span class="line">          <span class="comment">// 挂起等待所有手指抬起</span></span><br><span class="line">          awaitAllPointersUp()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentContext.isActive) &#123;</span><br><span class="line">                <span class="comment">// 手势事件取消时，如果协程还存活则等待手指抬起再进行下一轮监听</span></span><br><span class="line">                awaitAllPointersUp()</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="awaitEachGesture"><a href="#awaitEachGesture" class="headerlink" title="awaitEachGesture"></a>awaitEachGesture</h3><p><strong>注意：</strong> <code>forEachGesture</code> 这个API现在已经被标记为<code>Deprecated</code>（但是你目前仍然可以使用），目前官方推荐的是使用 <strong><code>awaitEachGesture(block)</code></strong> 这个Api来代替它，<code>awaitEachGesture</code>的内部在 <code>awaitPointerEventScope</code> 内直接调用了传入的<code>block</code>，因此相比 <code>forEachGesture</code> 使用更加方便，不用在<code>forEachGesture</code> 内再套<code>awaitPointerEventScope</code> 了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> PointerInputScope.<span class="title">awaitEachGesture</span><span class="params">(block: <span class="type">suspend</span> <span class="type">AwaitPointerEventScope</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> currentContext = currentCoroutineContext()</span><br><span class="line">    awaitPointerEventScope &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentContext.isActive) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                block()</span><br><span class="line">                <span class="comment">// Wait for all pointers to be up. Gestures start when a finger goes down.</span></span><br><span class="line">                awaitAllPointersUp()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: CancellationException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentContext.isActive) &#123;</span><br><span class="line">                    <span class="comment">// The current gesture was canceled. Wait for all fingers to be &quot;up&quot; before</span></span><br><span class="line">                    <span class="comment">// looping again.</span></span><br><span class="line">                    awaitAllPointersUp()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// detectGesture was cancelled externally. Rethrow the cancellation exception to</span></span><br><span class="line">                    <span class="comment">// propagate it upwards.</span></span><br><span class="line">                    <span class="keyword">throw</span> e</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以更加常规的优雅用法是使用<code>awaitEachGesture</code>来持续不断地监听每一轮的手势变化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Modifier.pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">    awaitEachGesture &#123;</span><br><span class="line">        <span class="keyword">val</span> downEvent = awaitFirstDown() </span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>例如利用 <code>awaitEachGesture</code> 实现一个简单的点击事件处理逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myClick</span><span class="params">(onClick: ()-&gt;<span class="type">Unit</span>)</span></span>: Modifier &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">            awaitEachGesture &#123;</span><br><span class="line">                awaitFirstDown() <span class="comment">// 等待第一根手指按下</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">val</span> event = awaitPointerEvent()</span><br><span class="line">                    <span class="keyword">if</span> (event.type == PointerEventType.Move) &#123; </span><br><span class="line">                        <span class="keyword">val</span> pos = event.changes[<span class="number">0</span>].position</span><br><span class="line">                        <span class="keyword">if</span> (pos.x &lt; <span class="number">0</span> || pos.x &gt; size.width || pos.y &lt; <span class="number">0</span> || pos.y &gt; size.height) &#123;</span><br><span class="line">                            <span class="comment">// 按下状态时，手指滑动超出边界，不处理</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == PointerEventType.Release &amp;&amp; event.changes.size == <span class="number">1</span>) &#123;    </span><br><span class="line">                    <span class="comment">// &#125; else if (event.changes.fastAll &#123; it.changedToUp() &#125;) &#123;  // 源码中判断所有手指都抬起的用法(可参考waitForUpOrCancellation()的实现)</span></span><br><span class="line">                        <span class="comment">// 因为每个手指抬起都会触发PointerEventType.Release（而原生中后面手指的抬起是ACTION_POINTER_UP, Compose这点与原生不同）</span></span><br><span class="line">                        <span class="comment">// 判断changes.size==1是判断只有一根手指抬起即最后一根手指抬起</span></span><br><span class="line">                        onClick()</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="drag"><a href="#drag" class="headerlink" title="drag"></a>drag</h3><p>前面提到的 <strong><code>detectDragGestures</code></strong>，以及更为上层的 <strong><code>Draggable</code></strong> 修饰符内部都是使用 <strong><code>drag</code></strong> 挂起方法来实现拖动监听的。通过函数签名可以看到我们不仅需要手指拖动的监听回调，还需传入手指的标识信息，表示监听具体哪根手指的拖动手势。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> AwaitPointerEventScope.<span class="title">drag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pointerId: <span class="type">PointerId</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onDrag: (<span class="type">PointerInputChange</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以先利用 <strong><code>awaitFirstDown</code></strong> 获取到记录着交互信息的 <strong><code>PointerInputChange</code></strong> 实例，其中 <strong><code>id</code></strong> 字段记录着发生 <strong><code>ACTION_DOWN</code></strong> 事件的手指标识信息。通过结合 <strong><code>awaitEachGesture</code></strong>、<strong><code>awaitFirstDown</code></strong> 与 <strong><code>drag</code></strong>，我们便可以实现一个简单的拖动手势监听了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BaseDragGestureDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">by</span> remember &#123; mutableStateOf(Offset.Zero) &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize(), Alignment.Center) &#123;</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">100.</span>dp)</span><br><span class="line">            .offset &#123; IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) &#125;</span><br><span class="line">            .background(Color.Green)</span><br><span class="line">            .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                awaitEachGesture &#123;</span><br><span class="line">                    <span class="keyword">val</span> downEvent = awaitFirstDown() <span class="comment">// 获取第一根手指的DOWN事件</span></span><br><span class="line">                    <span class="comment">// 根据手指标识符跟踪多种手势</span></span><br><span class="line">                    drag(downEvent.id) &#123;</span><br><span class="line">                        offset += it.positionChange() <span class="comment">// 根据手势位置的变化更新偏移量</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/13b2a4b792c8b5f2116747deb6aa307f.gif" alt="在这里插入图片描述"></p>
<h3 id="awaitDragOrCancellation"><a href="#awaitDragOrCancellation" class="headerlink" title="awaitDragOrCancellation"></a>awaitDragOrCancellation</h3><p>与 <strong><code>drag</code></strong> 不同的是，<strong><code>awaitDragOrCancellation</code></strong> 负责监听 <strong>单次拖动事件</strong>。当该手指抬起时，如果有其他手指还在屏幕上，则会选择其中一根手指来继续追踪手势。当最后一根手指离开屏幕时则会返回抬起事件。</p>
<p>当手指拖动事件已经在 <strong>Main</strong> 阶段被消费，拖动行为会被认为已经取消，此时会返回 <strong><code>null</code></strong>。如果在调用 <strong><code>awaitDragOrCancellation</code></strong> 前，<strong><code>pointId</code></strong> 对应手指没有产生 <strong><code>ACTION_DOWN</code></strong> 事件则也会返回 <strong><code>null</code></strong>。</p>
<p>当然我们也可以使用 <code>awaitDragOrCancellation</code> 来完成 UI 拖动手势处理流程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BaseDragGestureDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">by</span> remember &#123; mutableStateOf(Offset.Zero) &#125;</span><br><span class="line">    Box(Modifier.fillMaxSize(), Alignment.Center) &#123;</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">100.</span>dp)</span><br><span class="line">            .offset &#123; IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) &#125;</span><br><span class="line">            .background(Color.Green)</span><br><span class="line">            .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                awaitEachGesture &#123;</span><br><span class="line">                    <span class="keyword">val</span> downPointer = awaitFirstDown() <span class="comment">// 获取第一根手指的DOWN事件</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// 根据手指标识符跟踪拖动手势，手指抬起或拖动事件被消费时返回null</span></span><br><span class="line">                        <span class="keyword">val</span> event = awaitDragOrCancellation(downPointer.id)</span><br><span class="line">                        <span class="keyword">if</span> (event == <span class="literal">null</span>) <span class="keyword">break</span> <span class="comment">// 拖动事件被取消</span></span><br><span class="line">                        <span class="keyword">if</span> (event.changedToUp()) <span class="keyword">break</span> <span class="comment">// 所有手指均已抬起</span></span><br><span class="line">                        offset += event.positionChange() <span class="comment">// 根据手势位置改变量更新偏移量状态</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="awaitTouchSlopOrCancellation"><a href="#awaitTouchSlopOrCancellation" class="headerlink" title="awaitTouchSlopOrCancellation"></a>awaitTouchSlopOrCancellation</h3><p><strong><code>awaitTouchSlopOrCancellation</code></strong> 用于定制监听一次有效的拖动行为，这里的有效是开发者自己来定制的。在使用时，我们需要设置一个 <strong><code>pointId</code></strong> ，表示我们希望追踪手势事件的手指标识符。当该手指抬起时，如果有其他手指还在屏幕上，则会选择其中一根手指来继续追踪手势，而如果已经没有手指在屏幕上了则返回 <strong><code>null</code></strong>。如果在调用 <strong><code>awaitTouchSlopOrCancellation</code></strong> 前，<strong><code>pointId</code></strong> 对应手指没有产生 <strong><code>ACTION_DOWN</code></strong> 事件则也会返回 <strong><code>null</code></strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> AwaitPointerEventScope.<span class="title">awaitTouchSlopOrCancellation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  pointerId: <span class="type">PointerId</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  onTouchSlopReached: (<span class="type">change</span>: <span class="type">PointerInputChange</span>, <span class="type">overSlop</span>: <span class="type">Offset</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <strong><code>onTouchSlopReached</code></strong> 回调方法会在超过 <strong><code>ViewConfiguration</code></strong> 中所设定的阈值 <strong><code>touchSlop</code></strong> 时回调。如果根据事件信息我们希望接收这次手势事件，则应该通过 <strong><code>change</code></strong> 调用 <strong><code>consumePositionChange</code></strong> 进行消费，此时 <strong><code>awaitTouchSlopOrCancellation</code></strong> 会恢复执行，并返回当前 <strong><code>PointerInputChange</code></strong>。如果不消费，则会继续挂起检测滑动位移。</p>
<h3 id="利用awaitTouchSlopOrCancellation实现惯性滑动"><a href="#利用awaitTouchSlopOrCancellation实现惯性滑动" class="headerlink" title="利用awaitTouchSlopOrCancellation实现惯性滑动"></a>利用awaitTouchSlopOrCancellation实现惯性滑动</h3><p>如果当手指拖动离开屏幕存在初速度时，被拖动的组件会惯性滑动一段距离后停下，这种交互效果被称作 Fling。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/752697d99c61e27de5472e7181e68bb7.png" alt="在这里插入图片描述"><br>既然我们是要拖动组件，当发生拖动手势时组件我们可以设置 offset 移动组件位置。当发生 Fling 时组件会惯性朝着某一方向滑动一段距离后停下，实际上在手指离开屏幕时我们可以根据当前手势速度与组件位置来预先计算出组件最终停留的位置，所以 Fling 本质上只是以种交互动画。既然是动画，我们便可以使用 <code>Animatable</code> 包装组件偏移量信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offset = remember &#123;</span><br><span class="line">  Animatable(Offset.Zero, Offset.VectorConverter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于拖动手势，我们首先需要使用 <strong><code>awaitFirstDown</code></strong> 获取 <strong><code>ACTION_DOWN</code></strong> 手势事件信息。值得注意的是，当上一轮 <strong>Fling</strong> 未结束本轮手势便开始时。我们可以使用 <strong><code>Animatable</code></strong> 提供的 <strong><code>stop</code></strong> 方法来中断结束上一轮动画。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forEachGesture &#123;</span><br><span class="line">  <span class="keyword">val</span> down =  awaitPointerEventScope &#123; awaitFirstDown() &#125;</span><br><span class="line">  offset.stop()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们可以利用 <strong><code>awaitTouchSlopOrCancellation</code></strong> 检测当前是否为有效拖动手势，当检测成功后便可以使用 <strong><code>drag</code></strong> 来监听具体的拖动手势事件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">forEachGesture &#123;</span><br><span class="line">  <span class="keyword">val</span> down =  awaitPointerEventScope &#123; awaitFirstDown() &#125;</span><br><span class="line">  offset.stop()</span><br><span class="line">  awaitPointerEventScope &#123;</span><br><span class="line">    <span class="keyword">var</span> validDrag: PointerInputChange?</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      validDrag = awaitTouchSlopOrCancellation(down.id) &#123; change, _ -&gt;</span><br><span class="line">        change.consumePositionChange() <span class="comment">// 消费位置变化表示接受</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (validDrag != <span class="literal">null</span> &amp;&amp; !validDrag.isConsumed)</span><br><span class="line">    <span class="keyword">if</span> (validDrag != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 拖动手势监听</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们提到过当手指离开屏幕时，我们需要根据离屏时的位置信息与速度信息来计算组件最终会停留的位置。位置信息我们可以利用 <code>offset</code> 获取得到，而速度信息的获取则需要使用速度追踪器 <strong><code>VelocityTracker</code></strong>。</p>
<p>当发生拖动时，我们首先使用 <strong><code>snapTo</code></strong> 移动组件偏移位置。既然追踪手势速度，我们就需要将手势信息告知 <strong><code>VelocityTracker</code></strong>，通过 <strong><code>addPosition</code></strong> 实时告知 <strong><code>VelocityTracker</code></strong> 当前的手势位置，<strong><code>VelocityTracker</code></strong> 便可以实时计算出当前的手势速度了。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drag(validDrag.id) &#123;</span><br><span class="line">  launch &#123;</span><br><span class="line">    offset.snapTo(offset.value + it.positionChange())</span><br><span class="line">    velocityTracker.addPosition(it.uptimeMillis, it.position)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当手指离开屏幕时，我们可以利用 <strong><code>VelocityTracker</code></strong> 与 <strong><code>Offset</code></strong> 获取到实时速度信息与位置信息。之后，我们可以利用 <strong><code>splineBasedDecay</code></strong> 创建一个衰值推算器，这可以帮助我们根据当前速度与位置信息推算出组件 <strong>Fling</strong> 后停留的位置。由于最终位置可能会超出屏幕，所以我们还需设置数值上下界，并采用 <strong><code>animateTo</code></strong> 进行 <strong>Fling</strong> 动画。由于我们希望的是组件最终会缓缓的停下，所以这里采用的是 <strong><code>LinearOutSlowInEasing</code></strong> 插值器。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> decay = splineBasedDecay&lt;Offset&gt;(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">var</span> targetOffset = decay.calculateTargetValue(Offset.VectorConverter, offset.value, </span><br><span class="line">            Offset(horizontalVelocity, verticalVelocity)).run &#123;</span><br><span class="line">  Offset(x.coerceIn(<span class="number">0f</span>, <span class="number">320.</span>dp.toPx()), y.coerceIn(<span class="number">0f</span>, <span class="number">320.</span>dp.toPx()))</span><br><span class="line">&#125;</span><br><span class="line">launch &#123; offset.animateTo(targetOffset, tween(<span class="number">2000</span>, easing = LinearOutSlowInEasing)) &#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DragFlingDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.fillMaxSize(),Alignment.Center) &#123;</span><br><span class="line">        Column(horizontalAlignment = Alignment.CenterHorizontally) &#123;</span><br><span class="line">            <span class="keyword">var</span> horizontalVelocity <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">            <span class="keyword">var</span> verticalVelocity <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">            Box(Modifier.fillMaxWidth().height(<span class="number">50.</span>dp), Alignment.Center) &#123;</span><br><span class="line">                Text(<span class="string">&quot;Velocity&quot;</span>, fontSize = <span class="number">42.</span>sp, fontWeight = FontWeight.Bold)</span><br><span class="line">            &#125;</span><br><span class="line">            Spacer(Modifier.height(<span class="number">10.</span>dp))</span><br><span class="line">            Box(Modifier.fillMaxWidth().height(<span class="number">50.</span>dp), Alignment.Center) &#123;</span><br><span class="line">                <span class="keyword">val</span> text = <span class="string">&quot;Horizontal: %.2f Vertical: %.2f&quot;</span>.format(horizontalVelocity, verticalVelocity)</span><br><span class="line">                Text(text, fontSize = <span class="number">20.</span>sp, fontWeight = FontWeight.Bold)</span><br><span class="line">            &#125;</span><br><span class="line">            Spacer(Modifier.height(<span class="number">20.</span>dp))</span><br><span class="line">            <span class="keyword">val</span> offset = remember &#123; Animatable(Offset.Zero, Offset.VectorConverter) &#125;</span><br><span class="line">            Box(Modifier.size(<span class="number">350.</span>dp).background(Color.Gray)</span><br><span class="line">                    .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                        offset.updateBounds(</span><br><span class="line">                            lowerBound = Offset.Zero,</span><br><span class="line">                            upperBound = Offset(<span class="number">320.</span>dp.toPx(), <span class="number">320.</span>dp.toPx())</span><br><span class="line">                        )</span><br><span class="line">                        coroutineScope &#123; </span><br><span class="line">                            awaitEachGesture &#123;</span><br><span class="line">                                <span class="keyword">val</span> down = awaitFirstDown()</span><br><span class="line">                                launch &#123; offset.stop() &#125;</span><br><span class="line">                                <span class="keyword">var</span> validDrag: PointerInputChange?</span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                    validDrag = awaitTouchSlopOrCancellation(down.id) &#123; change, _ -&gt;</span><br><span class="line">                                        <span class="keyword">if</span> (change.positionChange() != Offset.Zero) change.consume()</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">while</span> (validDrag != <span class="literal">null</span> &amp;&amp; !validDrag.isConsumed)</span><br><span class="line">                                <span class="keyword">if</span> (validDrag != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">val</span> velocityTracker = VelocityTracker()</span><br><span class="line">                                    <span class="keyword">var</span> dragAnimJob: Job? = <span class="literal">null</span></span><br><span class="line">                                    drag(validDrag.id) &#123;</span><br><span class="line">                                        dragAnimJob = launch &#123;</span><br><span class="line">                                            offset.snapTo(offset.value + it.positionChange())</span><br><span class="line">                                            velocityTracker.addPosition(it.uptimeMillis, it.position)</span><br><span class="line">                                            horizontalVelocity = velocityTracker.calculateVelocity().x</span><br><span class="line">                                            verticalVelocity = velocityTracker.calculateVelocity().y</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    horizontalVelocity = velocityTracker.calculateVelocity().x</span><br><span class="line">                                    verticalVelocity = velocityTracker.calculateVelocity().y</span><br><span class="line">                                    <span class="keyword">val</span> decay = splineBasedDecay&lt;Offset&gt;(<span class="keyword">this</span>)</span><br><span class="line">                                    <span class="keyword">val</span> targetOffset = decay.calculateTargetValue(Offset.VectorConverter, </span><br><span class="line">                                            offset.value, Offset(horizontalVelocity, verticalVelocity)).run &#123;</span><br><span class="line">                                            Offset(x.coerceIn(<span class="number">0f</span>, <span class="number">320.</span>dp.toPx()), y.coerceIn(<span class="number">0f</span>, <span class="number">320.</span>dp.toPx()))</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    dragAnimJob?.cancel()</span><br><span class="line">                                    launch &#123;</span><br><span class="line">                                        offset.animateTo(targetOffset, tween(<span class="number">2000</span>, easing = LinearOutSlowInEasing))</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            ) &#123;</span><br><span class="line">                Box(Modifier</span><br><span class="line">                        .offset &#123; IntOffset(offset.value.x.roundToInt(), offset.value.y.roundToInt()) &#125;</span><br><span class="line">                        .size(<span class="number">30.</span>dp).clip(CircleShape).background(Color.Green)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/aa0023cd60e68147060d457d7d7ef0ee.gif" alt="在这里插入图片描述"></p>
<hr>
<p>参考资料：</p>
<ul>
<li>《Jetpack Compose从入门到实战》- 机械工业出版社 - 2022年9月</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E7%9A%84%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">https://bravestsnail.github.io/2025/05/29/note/Android/compose/Compose%E7%9A%84%E6%89%8B%E5%8A%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Compose/">Compose</a><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%8A%BF/">手势</a><a class="post-meta__tags" href="/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/">事件处理</a></div><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E7%9A%84%E5%8A%A8%E7%94%BB/" title="Compose的动画"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose的动画</div></div><div class="info-2"><div class="info-item-1"> 乍一看Jetpack Compose中的动画Api，尼玛是真的多呀，我C了，简直令人眼花缭乱、云里雾里、天马行空、小兔乱撞、手脚慌乱、头冒虚汗、四肢抓狂、不知所措呀 。。。😭 但是我们可以对其进行分一下类，如果按照使用的方便程度划分，大概可以分为两大类：高级动画API和低级动画API（这里类比高级开发语言的分类，并不是指效果多高级）。 其中高级动画API使用比较简单方便，封装度高，更加适用于日常业务开发，而低级动画API则使用起来较为麻烦，因为其配置项或流程较多，但是却更加灵活，能对动画效果做出更加精细的控制，适合自定义要求度较高的业务场景。 我们还可以按照功能类型进行一个大概的分类，也就是上图中的划分，这里再用表格归类一下：    功能需求点 可能符合的API类型    单个组件的显示隐藏转场动画  每个子组件需要不同的入场&#x2F;出场效果 AnimatedVisibility   根据组件内容状态变化的动画(数据、尺寸等)  不同组件间的切换动画 AnimatedContent ...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/ASM/" title="ASM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ASM</div></div><div class="info-2"><div class="info-item-1">ASM架构ASM是围绕事件生产者（class parser）、事件消费者（class writer）和各种预定义的事件过滤器的架构。架构图如下所示： 导入ASM库123456dependencies &#123;       //ASM相关依赖      implementation &#x27;org.ow2.asm:asm:9.4&#x27;      implementation &#x27;org.ow2.asm:asm-commons:9.4&#x27;      implementation &#x27;org.ow2.asm:asm-util:9.4&#x27; ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84Accompanist/" title="Compose中的Accompanist"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的Accompanist</div></div><div class="info-2"><div class="info-item-1">  权限依赖配置： 1234567repositories &#123;    mavenCentral()&#125;dependencies &#123;    implementation &quot;com.google.accompanist:accompanist-permissions:0.28.0&quot;&#125;  单个权限申请例如，我们需要获取相机权限，可以通过rememberPermissionState(Manifest.permission.CAMERA)创建一个 PermissionState对象，然后通过PermissionState.status.isGranted判断权限是否已获取，并通过调用permissionState.launchPermissionRequest()来申请权限。 12345&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;!-- 别忘了在清单文件中添加权限声明 --&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84startActivityForResult%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/" title="Compose中的startActivityForResult的正确姿势"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的startActivityForResult的正确姿势</div></div><div class="info-2"><div class="info-item-1">  后来研究了一下，在Compose 中startActivityForResult也有了新的姿势，要理解Compose 中startActivityForResult的姿势，这还得从androidx的startActivityForResult的姿势说起，因为Compose 就是在androidx的基础上利用其API简单封装了一下而已。 倒也不是说以前的不能用了，毕竟有系统自带的，谁还去用第三方的呀，用第三方的还得导入一个依赖库不是，能少依赖三方的就尽量少依赖吧。 androidx之后如何正确的startActivityForResult如何使用如果是在Activity或Fragment内部使用的话，直接调用registerForActivityResult方法即可。 例如，选择文件： 12345val launcher = registerForActivityResult(ActivityResultContracts.GetContent()) &#123; uri -&gt;    uri?.apply &#123; showToast(uri.toString())...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E8%B7%AF%E7%94%B1/" title="Compose中的导航路由"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的导航路由</div></div><div class="info-2"><div class="info-item-1">  1implementation &quot;androidx.navigation:navigation-compose:$nav_version&quot;   Jetpack库中的Navigation使用起来还是比较麻烦的，首先需要在xml中进行导航图的配置，然后在代码中使用NavController.navigate(id)进行跳转到指定的id的fragment页面，个人感觉这种方式还是不够灵活，需要预先定义，假如某个fragment没有在xml中定义就无法使用NavController进行跳转，另外还需要在xml和java&#x2F;kotlin文件来回折腾修改。 Jetpack...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80/" title="Compose中的绘制流程和自定义布局"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose中的绘制流程和自定义布局</div></div><div class="info-2"><div class="info-item-1">  与大多数其他界面工具包一样，Compose 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 Android View 系统，就会发现它有 3 个主要阶段：测量、布局和绘制。Compose 和它非常相似，但开头多了一个叫做“组合”的重要阶段。 Compose 有 3 个主要的阶段：  组合：要显示什么样的界面。Compose 运行Composable可组合函数并创建LayoutNode视图树。 布局：要放置界面的位置。该阶段包含两个步骤：测量和放置。对于视图树中的每个LayoutNode节点进行宽高尺寸测量并完成位置摆放，布局元素都会根据 2D 坐标来测量并放置自己及其所有子元素。 绘制：渲染的方式。将所有LayoutNode界面元素会绘制到画布（通常是设备屏幕）之上。   这些阶段的顺序通常是相同的，从而让数据能够沿一个方向（从组合到布局，再到绘制）生成帧（也称为单向数据流）。 您可以放心地假设每个帧都会以虚拟方式经历这 3 个阶段，但为了保障性能，Compose...</div></div></div></a><a class="pagination-related" href="/2025/05/29/note/Android/compose/Compose%E7%9A%84%E5%8A%A8%E7%94%BB/" title="Compose的动画"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-30</div><div class="info-item-2">Compose的动画</div></div><div class="info-2"><div class="info-item-1"> 乍一看Jetpack Compose中的动画Api，尼玛是真的多呀，我C了，简直令人眼花缭乱、云里雾里、天马行空、小兔乱撞、手脚慌乱、头冒虚汗、四肢抓狂、不知所措呀 。。。😭 但是我们可以对其进行分一下类，如果按照使用的方便程度划分，大概可以分为两大类：高级动画API和低级动画API（这里类比高级开发语言的分类，并不是指效果多高级）。 其中高级动画API使用比较简单方便，封装度高，更加适用于日常业务开发，而低级动画API则使用起来较为麻烦，因为其配置项或流程较多，但是却更加灵活，能对动画效果做出更加精细的控制，适合自定义要求度较高的业务场景。 我们还可以按照功能类型进行一个大概的分类，也就是上图中的划分，这里再用表格归类一下：    功能需求点 可能符合的API类型    单个组件的显示隐藏转场动画  每个子组件需要不同的入场&#x2F;出场效果 AnimatedVisibility   根据组件内容状态变化的动画(数据、尺寸等)  不同组件间的切换动画 AnimatedContent ...</div></div></div></a><a class="pagination-related" href="/2022/08/22/posts/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="Activity的启动流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-22</div><div class="info-item-2">Activity的启动流程</div></div><div class="info-2"><div class="info-item-1">Application的初始化从应用进程到系统进程ActivityThread在创建的时候，会将自己的ApplicationThread绑定到AMS中。  ActivityThread.main() ActivityThread.attach() IActivityManager.attachApplication(mAppThread) Binder.transact()        应用程序通过IActivityManager接口发起系统调用，调用attachApplication并传递IApplicationThread，执行流程从应用进程到了系统进程。  ActivityManagerService.onTransact() ActivityManagerService.attachApplication(IApplicationThread thread)AMS作为IActivityService的接口的服务端实现，会响应客户端的请求，最终attachApplication(IApplicationThread...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">点击事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Draggable%E6%8B%96%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">Draggable拖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swipeable%E6%BB%91%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">Swipeable滑动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transformable%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7"><span class="toc-number">4.</span> <span class="toc-text">transformable多点触控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scrollable%E6%BB%9A%E5%8A%A8"><span class="toc-number">5.</span> <span class="toc-text">Scrollable滚动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E5%88%ABscrollable%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">低级别scrollable修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nestedScroll-%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8"><span class="toc-number">7.</span> <span class="toc-text">nestedScroll 嵌套滑动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nestedScroll%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-number">8.</span> <span class="toc-text">使用nestedScroll实现下拉刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-onPreScroll"><span class="toc-number">8.1.</span> <span class="toc-text">实现 onPreScroll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-onPreFling"><span class="toc-number">8.2.</span> <span class="toc-text">实现 onPreFling</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-API"><span class="toc-number"></span> <span class="toc-text">低级事件处理 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PointerInput"><span class="toc-number">1.</span> <span class="toc-text">PointerInput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%96%E5%8A%A8%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80-API"><span class="toc-number">2.</span> <span class="toc-text">拖动类型基础 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80-API"><span class="toc-number">3.</span> <span class="toc-text">点击类型基础 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80-API"><span class="toc-number">4.</span> <span class="toc-text">变换类型基础 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F-awaitPointerEventScope"><span class="toc-number">5.</span> <span class="toc-text">手势事件作用域 awaitPointerEventScope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B9%8B%E6%BA%90-awaitPointerEvent"><span class="toc-number">6.</span> <span class="toc-text">事件之源 awaitPointerEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="toc-number">7.</span> <span class="toc-text">事件分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9"><span class="toc-number">8.</span> <span class="toc-text">事件消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitFirstDown"><span class="toc-number">9.</span> <span class="toc-text">awaitFirstDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEachGesture"><span class="toc-number">10.</span> <span class="toc-text">forEachGesture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitEachGesture"><span class="toc-number">11.</span> <span class="toc-text">awaitEachGesture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drag"><span class="toc-number">12.</span> <span class="toc-text">drag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitDragOrCancellation"><span class="toc-number">13.</span> <span class="toc-text">awaitDragOrCancellation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awaitTouchSlopOrCancellation"><span class="toc-number">14.</span> <span class="toc-text">awaitTouchSlopOrCancellation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8awaitTouchSlopOrCancellation%E5%AE%9E%E7%8E%B0%E6%83%AF%E6%80%A7%E6%BB%91%E5%8A%A8"><span class="toc-number">15.</span> <span class="toc-text">利用awaitTouchSlopOrCancellation实现惯性滑动</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>