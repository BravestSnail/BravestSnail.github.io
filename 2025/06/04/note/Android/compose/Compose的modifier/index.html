<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose的modifier | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Modifier的基本使用Modifier修饰符是Jetpack Compose中用来修饰组件的，提供常用的属性，写布局时几乎所有Composable组件的大部分属性都可以用Modifier 来修饰。官方在开发Compose UI时，最初尝试过将所有属性全部以函数参数的形式提供，但是那样太多了，他们也尝试过像Flutter那样的方式，将属性也作为一个组件进行嵌套，但这样又很容易让人感到困惑，所以才">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose的modifier">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E7%9A%84modifier/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="Modifier的基本使用Modifier修饰符是Jetpack Compose中用来修饰组件的，提供常用的属性，写布局时几乎所有Composable组件的大部分属性都可以用Modifier 来修饰。官方在开发Compose UI时，最初尝试过将所有属性全部以函数参数的形式提供，但是那样太多了，他们也尝试过像Flutter那样的方式，将属性也作为一个组件进行嵌套，但这样又很容易让人感到困惑，所以才">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.124Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.125Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose的modifier",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E7%9A%84modifier/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.124Z",
  "dateModified": "2025-06-04T12:46:35.125Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E7%9A%84modifier/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose的modifier',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose的modifier</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose的modifier</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.124Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.125Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Modifier的基本使用"><a href="#Modifier的基本使用" class="headerlink" title="Modifier的基本使用"></a>Modifier的基本使用</h3><p>Modifier修饰符是Jetpack Compose中用来修饰组件的，提供常用的属性，写布局时几乎所有Composable组件的大部分属性都可以用Modifier 来修饰。官方在开发Compose UI时，最初尝试过将所有属性全部以函数参数的形式提供，但是那样太多了，他们也尝试过像<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Flutter&spm=1001.2101.3001.7020">Flutter</a>那样的方式，将属性也作为一个组件进行嵌套，但这样又很容易让人感到困惑，所以才诞生了Modifier，将大部分组件常用属性封装成Modifier的形式来提供，哪个组件需要就在哪个组件上应用。我认为Modifier是Compose中最优秀的设计点之一。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(modifier = Modifier.size(<span class="number">200.</span>dp)) &#123; <span class="comment">// size同时指定宽高大小</span></span><br><span class="line">        Box(Modifier.fillMaxSize()  <span class="comment">// 填满父空间</span></span><br><span class="line">            .background(Color.Red))</span><br><span class="line">        Box(Modifier.fillMaxHeight() <span class="comment">// 高度填满父空间</span></span><br><span class="line">            .width(<span class="number">60.</span>dp) </span><br><span class="line">            .background(Color.Blue))</span><br><span class="line">        Box(Modifier.fillMaxWidth() <span class="comment">// 宽度填满父空间</span></span><br><span class="line">            .height(<span class="number">60.</span>dp)</span><br><span class="line">            .background(Color.Green)</span><br><span class="line">            .align(Alignment.Center))</span><br><span class="line">        Column(Modifier.clickable &#123; &#125; <span class="comment">// 点击事件 </span></span><br><span class="line">                .padding(<span class="number">15.</span>dp) <span class="comment">// 外间距</span></span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .background(MaterialTheme.colorScheme.primary) <span class="comment">// 背景</span></span><br><span class="line">            	.border(<span class="number">2.</span>dp, Color.Red, RoundedCornerShape(<span class="number">2.</span>dp)) <span class="comment">// 边框</span></span><br><span class="line">            	.padding(<span class="number">8.</span>dp) <span class="comment">// 内间距</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;从基线到顶部保持特定距离&quot;</span>,</span><br><span class="line">                modifier = Modifier.paddingFromBaseline(top = <span class="number">35.</span>dp))</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;offset设置偏移量&quot;</span>, </span><br><span class="line">                modifier = Modifier.offset(x = <span class="number">14.</span>dp) <span class="comment">// 正offset会将元素向右移</span></span><br><span class="line">            )</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分Modifier属性只能在特定组件的作用域范围内才能使用，避免了像传统xml布局中的属性那样对自身没有用的属性也能被写出来造成污染。例如 <strong>Modifier.matchParentSize()</strong> 只有在 <strong>Box</strong> 组件范围内才能使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Box(modifier = Modifier.size(<span class="number">200.</span>dp)) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">            .align(Alignment.Center)</span><br><span class="line">            .matchParentSize() <span class="comment">// matchParentSize 仅在 BoxScope 中可用</span></span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察源码发现 <strong>Modifier.matchParentSize()</strong> 与 <strong>Modifier.align()</strong> 被定义在了<strong>BoxScope</strong>接口的内部，所以只能在<strong>Box</strong>的<strong>lambda</strong>中使用，该<strong>lambda</strong>函数的类型是 <strong>@Composable BoxScope.() -&gt; Unit</strong>，可见其定义了<strong>Receiver</strong>是<strong>BoxScope</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BoxScope</span> &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">align</span><span class="params">(alignment: <span class="type">Alignment</span>)</span></span>: Modifier</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">matchParentSize</span><span class="params">()</span></span>: Modifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 <strong>Row</strong> 和 <strong>Column</strong> 中使用<strong>Modifier.weight</strong>，类比传统线性布局中的layout_weight属性，并且仅可在 <strong>RowScope</strong> 和 <strong>ColumnScope</strong> 中使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ArtistCard</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Row(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .size(<span class="number">150.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.ic_sky),</span><br><span class="line">            contentDescription = <span class="literal">null</span>,</span><br><span class="line">            contentScale = ContentScale.Crop,</span><br><span class="line">            modifier = Modifier.weight(<span class="number">2f</span>) <span class="comment">// 占比2/3</span></span><br><span class="line">        )</span><br><span class="line">        Column(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>) <span class="comment">// 占比1/3</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Hello&quot;</span>, style = MaterialTheme.typography.titleSmall)</span><br><span class="line">            Text(text = <span class="string">&quot;Compose&quot;</span>, style = MaterialTheme.typography.bodyMedium)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击事件相关的Modifier属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Column&#123;</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .clickable &#123; println(<span class="string">&quot;clickable&quot;</span>) &#125;</span><br><span class="line">            .size(<span class="number">30.</span>dp)</span><br><span class="line">            .background(Color.Red))</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">50.</span>dp)</span><br><span class="line">            .background(Color.Blue)</span><br><span class="line">            .combinedClickable(</span><br><span class="line">                onLongClick = &#123; println(<span class="string">&quot;onLongClick&quot;</span>) &#125;,</span><br><span class="line">                onDoubleClick = &#123; println(<span class="string">&quot;onDoubleClick&quot;</span>) &#125;,</span><br><span class="line">                onClick = &#123; println(<span class="string">&quot;onClick&quot;</span>) &#125;</span><br><span class="line">            ))</span><br><span class="line">        Box(Modifier</span><br><span class="line">            .size(<span class="number">50.</span>dp)</span><br><span class="line">            .background(Color.Green)</span><br><span class="line">            .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                detectTapGestures(</span><br><span class="line">                    onDoubleTap = &#123; &#125;,</span><br><span class="line">                    onLongPress = &#123; &#125;,</span><br><span class="line">                    onPress = &#123; &#125;,</span><br><span class="line">                    onTap = &#123;&#125;)</span><br><span class="line">                detectDragGestures(</span><br><span class="line">                    onDragStart = &#123; &#125;,</span><br><span class="line">                    onDragEnd = &#123; &#125;,</span><br><span class="line">                    onDragCancel = &#123; &#125;,</span><br><span class="line">                    onDrag = &#123; change, dragAmount -&gt; &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Modifier的复用"><a href="#Modifier的复用" class="headerlink" title="Modifier的复用"></a>Modifier的复用</h3><p>可以通过定义<strong>扩展函数</strong>复用常用的Modifier属性配置：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">redCircle</span><span class="params">()</span></span>: Modifier = clip(CircleShape).background(Color.Red)</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Column &#123;</span><br><span class="line">       Box(Modifier.size(<span class="number">80.</span>dp).redCircle()) </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以<strong>提取和复用同一修饰符实例</strong>，并将其传递给可组合项，避免在每一帧重组中创建大量对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reusableModifier = Modifier</span><br><span class="line">    .padding(<span class="number">12.</span>dp)</span><br><span class="line">    .background(Color.Gray)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoadingWheelAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> animatedState = animateFloatAsState(...)</span><br><span class="line"></span><br><span class="line">    LoadingWheel(</span><br><span class="line">        <span class="comment">// No allocation, as we&#x27;re just reusing the same instance</span></span><br><span class="line">        modifier = reusableModifier,</span><br><span class="line">        animatedState = animatedState.value</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取和复用未限定作用域的修饰符</strong><br>修饰符可以不限定作用域，也可以将作用域限定为特定可组合项。对于未限定作用域的修饰符，可以从任何可组合项之外提取它们作为简单变量：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reusableModifier = Modifier</span><br><span class="line">    .fillMaxWidth()</span><br><span class="line">    .background(Color.Red)</span><br><span class="line">    .padding(<span class="number">12.</span>dp)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">AuthorField</span><span class="params">()</span></span> &#123;</span><br><span class="line">    HeaderText(</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        modifier = reusableModifier</span><br><span class="line">    )</span><br><span class="line">    SubtitleText(</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        modifier = reusableModifier</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与延迟布局结合使用时，这尤为有用。在大多数情况下，建议对所有潜在的重要项目使用完全相同的修饰符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reusableItemModifier = Modifier</span><br><span class="line">    .padding(bottom = <span class="number">12.</span>dp)</span><br><span class="line">    .size(<span class="number">216.</span>dp)</span><br><span class="line">    .clip(CircleShape)</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">AuthorList</span><span class="params">(authors: <span class="type">List</span>&lt;<span class="type">Author</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyColumn &#123;</span><br><span class="line">        items(authors) &#123;</span><br><span class="line">            AsyncImage(</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                modifier = reusableItemModifier,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提取和复用限定作用域的修饰符</strong><br>在处理作用域限定为特定可组合项的修饰符时，您可以将其提取到尽可能高的级别，并在适当的情况下重复使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Column(...) &#123;</span><br><span class="line">    <span class="keyword">val</span> reusableItemModifier = Modifier</span><br><span class="line">        .padding(bottom = <span class="number">12.</span>dp)</span><br><span class="line">        .align(Alignment.CenterHorizontally)</span><br><span class="line">        .weight(<span class="number">1f</span>)</span><br><span class="line">    Text1(</span><br><span class="line">        modifier = reusableItemModifier,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )</span><br><span class="line">    Text2(</span><br><span class="line">        modifier = reusableItemModifier</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>只能将提取的限定作用域的修饰符传递给限定相同作用域的直接子项</strong><br>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Column(modifier = Modifier.fillMaxWidth()) &#123;</span><br><span class="line">    <span class="comment">// Weight modifier is scoped to the Column composable</span></span><br><span class="line">    <span class="keyword">val</span> reusableItemModifier =  Modifier.weight(<span class="number">1f</span>)</span><br><span class="line">    <span class="comment">// Weight 可以在这里正常应用因为 Text 是 Column 的一个直接子项</span></span><br><span class="line">    Text(modifier = reusableItemModifier</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    )</span><br><span class="line">    Box &#123;</span><br><span class="line">         <span class="comment">// Weight 在这里不起作用，因为当前 Text 不是 Column 的直接子项</span></span><br><span class="line">        Text(modifier = reusableItemModifier</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>延长提取Modifier链</strong><br>您可以通过调用 <strong>.then()</strong> 函数进一步链接或附加提取的Modifier链：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reusableModifier = Modifier</span><br><span class="line">    .fillMaxWidth()</span><br><span class="line">    .background(Color.Red)</span><br><span class="line">    .padding(<span class="number">12.</span>dp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append to your reusableModifier</span></span><br><span class="line">reusableModifier.clickable &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append your reusableModifier</span></span><br><span class="line">otherModifier.then(reusableModifier)</span><br></pre></td></tr></table></figure>

<h3 id="Modifier的分类"><a href="#Modifier的分类" class="headerlink" title="Modifier的分类"></a>Modifier的分类</h3><p>Modifier有很多属性，这些属性属于不同类型的Modifier，每种类型的Modifier负责处理一类的功能，就常用的属性而言可以分成<strong>LayoutModifier</strong>和<strong>DrawModifier</strong>，如<strong>size、padding</strong>等背后的实现是基于<strong>LayoutModifier</strong>，而<strong>background、border</strong>等背后的实现是基于<strong>DrawModifier</strong>。</p>
<p>Modifier的分类如下：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/609f87aaf124979bb01fd82a276fcf67.png"></p>
<h3 id="Modifier的自定义"><a href="#Modifier的自定义" class="headerlink" title="Modifier的自定义"></a>Modifier的自定义</h3><h4 id="Modifier-composed-自定义"><a href="#Modifier-composed-自定义" class="headerlink" title="Modifier.composed 自定义"></a>Modifier.composed 自定义</h4><p><strong>Modifier.composed 是一种可以支持有状态的 Modifier</strong>，可以将很多行为延时到重组后执行，而不是状态变化后立即执行，例如:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击的时候添加一个边框</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">addBorderOnClicked</span><span class="params">()</span></span> = composed &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0.</span>dp) &#125;</span><br><span class="line">    <span class="keyword">when</span>(width) &#123;</span><br><span class="line">        <span class="number">0.</span>dp -&gt; Modifier</span><br><span class="line">        <span class="keyword">else</span> -&gt; Modifier.border(width, Color.Red)</span><br><span class="line">    &#125;.then(</span><br><span class="line">        Modifier</span><br><span class="line">        .padding(<span class="number">5.</span>dp)</span><br><span class="line">        .clickable &#123; width = <span class="number">1.</span>dp &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Column &#123; </span><br><span class="line">     Text(<span class="string">&quot;ccccccccccccc&quot;</span>, Modifier.addBorderOnClicked())</span><br><span class="line">     Text(<span class="string">&quot;ddddddd&quot;</span>, Modifier.addBorderOnClicked())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a48daf6484cb8863afe4b0dab0436963.gif" alt="在这里插入图片描述"></p>
<p><strong>composed{…}</strong> 会使用 <strong>工厂函数 创建一个新的 Modifier 对象</strong> , 它会在重组的时候被调用， <strong>composed</strong>与普通Modifier属性的区别是<strong>其状态是独享的</strong>，<strong>在重组运行时才生效</strong>，因为其<strong>factory</strong>参数是一个<strong>Composable</strong>函数 <strong>@Composable Modifier.() -&gt; Modifier</strong>，所以在{…}中可以使用<strong>remember</strong>，可以把它当成一个<strong>Composable</strong>组件。</p>
<p>可以运行下面的例子，来感受它和普通Modifier的不同：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposedBackgroundExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .padding(horizontal = <span class="number">8.</span>dp)</span><br><span class="line">            .fillMaxWidth(),</span><br><span class="line">        verticalArrangement = Arrangement.spacedBy((<span class="number">8.</span>dp))</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">var</span> counter <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">        Button(</span><br><span class="line">            onClick = &#123; counter++ &#125;,</span><br><span class="line">            modifier = Modifier.fillMaxWidth()</span><br><span class="line">        ) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Increase <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Text(<span class="string">&quot;Modifier.composed&quot;</span>)</span><br><span class="line">        Row(</span><br><span class="line">            modifier = Modifier.fillMaxWidth(),</span><br><span class="line">            horizontalArrangement = Arrangement.SpaceEvenly</span><br><span class="line">        ) &#123;</span><br><span class="line">            Box(Modifier</span><br><span class="line">                .composedBackground(<span class="number">150.</span>dp, <span class="number">20.</span>dp, <span class="number">0</span>)</span><br><span class="line">                .width(<span class="number">150.</span>dp)) &#123;</span><br><span class="line">                Text(text = <span class="string">&quot;Recomposed <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            Box(Modifier</span><br><span class="line">                .composedBackground(<span class="number">150.</span>dp, <span class="number">20.</span>dp, <span class="number">1</span>)</span><br><span class="line">                .width(<span class="number">150.</span>dp)) &#123;</span><br><span class="line">                Text(text = <span class="string">&quot;Recomposed <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Text(<span class="string">&quot;Modifier that is not composed&quot;</span>)</span><br><span class="line">        Row(</span><br><span class="line">            modifier = Modifier.fillMaxWidth(),</span><br><span class="line">            horizontalArrangement = Arrangement.SpaceEvenly</span><br><span class="line">        ) &#123;</span><br><span class="line">            Box(Modifier</span><br><span class="line">                .nonComposedBackground(<span class="number">150.</span>dp, <span class="number">20.</span>dp)</span><br><span class="line">                .width(<span class="number">150.</span>dp)) &#123;</span><br><span class="line">                Text(text = <span class="string">&quot;Recomposed <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            Box(Modifier</span><br><span class="line">                .nonComposedBackground(<span class="number">150.</span>dp, <span class="number">20.</span>dp)</span><br><span class="line">                .width(<span class="number">150.</span>dp)) &#123;</span><br><span class="line">                Text(text = <span class="string">&quot;Recomposed <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates stateful modifier with multiple arguments</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">composedBackground</span><span class="params">(width: <span class="type">Dp</span>, height: <span class="type">Dp</span>, index: <span class="type">Int</span>)</span></span> = composed(</span><br><span class="line">    <span class="comment">// pass inspector information for debug</span></span><br><span class="line">    inspectorInfo = debugInspectorInfo &#123;</span><br><span class="line">        <span class="comment">// name should match the name of the modifier</span></span><br><span class="line">        name = <span class="string">&quot;myModifier&quot;</span></span><br><span class="line">        <span class="comment">// add name and value of each argument</span></span><br><span class="line">        properties[<span class="string">&quot;width&quot;</span>] = width</span><br><span class="line">        properties[<span class="string">&quot;height&quot;</span>] = height</span><br><span class="line">        properties[<span class="string">&quot;index&quot;</span>] = index</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在factory中返回实现的Modifier对象</span></span><br><span class="line">    factory = &#123;</span><br><span class="line">        <span class="keyword">val</span> density = LocalDensity.current</span><br><span class="line">        <span class="keyword">val</span> color = remember(index) &#123;</span><br><span class="line">            Color(</span><br><span class="line">                red = Random.nextInt(<span class="number">256</span>),</span><br><span class="line">                green = Random.nextInt(<span class="number">256</span>),</span><br><span class="line">                blue = Random.nextInt(<span class="number">256</span>),</span><br><span class="line">                alpha = <span class="number">255</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add your modifier implementation here</span></span><br><span class="line">        Modifier.drawBehind &#123;</span><br><span class="line">            <span class="keyword">val</span> widthInPx = with(density) &#123; width.toPx() &#125;</span><br><span class="line">            <span class="keyword">val</span> heightInPx = with(density) &#123; height.toPx() &#125;</span><br><span class="line">            drawRect(color = color, topLeft = Offset.Zero, size = Size(widthInPx, heightInPx))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">nonComposedBackground</span><span class="params">(width: <span class="type">Dp</span>, height: <span class="type">Dp</span>)</span></span> = <span class="keyword">this</span>.then(</span><br><span class="line">    Modifier.drawBehind &#123;</span><br><span class="line">        <span class="comment">// Without remember this color is created every time item using this modifier composed</span></span><br><span class="line">        <span class="keyword">val</span> color = Color(</span><br><span class="line">            red = Random.nextInt(<span class="number">256</span>),</span><br><span class="line">            green = Random.nextInt(<span class="number">256</span>),</span><br><span class="line">            blue = Random.nextInt(<span class="number">256</span>),</span><br><span class="line">            alpha = <span class="number">255</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> widthInPx = width.toPx()</span><br><span class="line">        <span class="keyword">val</span> heightInPx = height.toPx()</span><br><span class="line">        drawRect(color = color, topLeft = Offset.Zero, size = Size(widthInPx, heightInPx))</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2105d16dc3d327f5f67f9fdfb7510b5d.gif" alt="在这里插入图片描述"></p>
<p>可以看到使用 <code>composed</code> 定义的背景属性，可以记住状态，而非 <code>composed</code> 定义的背景属性在每次观察的状态值变化时，都会立即触发背景色改变。</p>
<p>下面的例子使用 <code>composed</code> 自定义了一个应用分段标题栏效果的<code>Modifier</code>属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">BorderPosition</span> &#123; Start, Center, End &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">segmentedBorder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    strokeWidth: <span class="type">Dp</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    color: <span class="type">Color</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    borderPos: <span class="type">BorderPosition</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    cornerPercent: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    divider: <span class="type">Boolean</span> = <span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = composed &#123;</span><br><span class="line">    <span class="keyword">val</span> density = LocalDensity.current</span><br><span class="line">    <span class="keyword">val</span> strokeWidthPx = density.run &#123; strokeWidth.toPx() &#125;</span><br><span class="line">    Modifier.drawWithContent &#123;</span><br><span class="line">        <span class="keyword">val</span> width = size.width</span><br><span class="line">        <span class="keyword">val</span> height = size.height</span><br><span class="line">        <span class="keyword">val</span> cornerRadius = height * cornerPercent / <span class="number">100</span></span><br><span class="line">        drawContent()</span><br><span class="line">        <span class="keyword">when</span> (borderPos) &#123;</span><br><span class="line">            BorderPosition.Start -&gt; &#123;</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = width, y = <span class="number">0f</span>),</span><br><span class="line">                    end = Offset(x = cornerRadius, y = <span class="number">0f</span>),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// Top left arc</span></span><br><span class="line">                drawArc(</span><br><span class="line">                    color = color,</span><br><span class="line">                    startAngle = <span class="number">180f</span>,</span><br><span class="line">                    sweepAngle = <span class="number">90f</span>,</span><br><span class="line">                    useCenter = <span class="literal">false</span>,</span><br><span class="line">                    topLeft = Offset.Zero,</span><br><span class="line">                    size = Size(cornerRadius * <span class="number">2</span>, cornerRadius * <span class="number">2</span>),</span><br><span class="line">                    style = Stroke(width = strokeWidthPx)</span><br><span class="line">                )</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = <span class="number">0f</span>, y = cornerRadius),</span><br><span class="line">                    end = Offset(x = <span class="number">0f</span>, y = height - cornerRadius),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// Bottom left arc</span></span><br><span class="line">                drawArc(</span><br><span class="line">                    color = color,</span><br><span class="line">                    startAngle = <span class="number">90f</span>,</span><br><span class="line">                    sweepAngle = <span class="number">90f</span>,</span><br><span class="line">                    useCenter = <span class="literal">false</span>,</span><br><span class="line">                    topLeft = Offset(x = <span class="number">0f</span>, y = height - <span class="number">2</span> * cornerRadius),</span><br><span class="line">                    size = Size(cornerRadius * <span class="number">2</span>, cornerRadius * <span class="number">2</span>),</span><br><span class="line">                    style = Stroke(width = strokeWidthPx)</span><br><span class="line">                )</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = cornerRadius, y = height),</span><br><span class="line">                    end = Offset(x = width, y = height),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            BorderPosition.Center -&gt; &#123;</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = <span class="number">0f</span>, y = <span class="number">0f</span>),</span><br><span class="line">                    end = Offset(x = width, y = <span class="number">0f</span>),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = <span class="number">0f</span>, y = height),</span><br><span class="line">                    end = Offset(x = width, y = height),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">if</span> (divider) &#123;</span><br><span class="line">                    drawLine(</span><br><span class="line">                        color = color,</span><br><span class="line">                        start = Offset(x = <span class="number">0f</span>, y = <span class="number">0f</span>),</span><br><span class="line">                        end = Offset(x = <span class="number">0f</span>, y = height),</span><br><span class="line">                        strokeWidth = strokeWidthPx</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (divider) &#123;</span><br><span class="line">                    drawLine(</span><br><span class="line">                        color = color,</span><br><span class="line">                        start = Offset(x = <span class="number">0f</span>, y = <span class="number">0f</span>),</span><br><span class="line">                        end = Offset(x = <span class="number">0f</span>, y = height),</span><br><span class="line">                        strokeWidth = strokeWidthPx</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = <span class="number">0f</span>, y = <span class="number">0f</span>),</span><br><span class="line">                    end = Offset(x = width - cornerRadius, y = <span class="number">0f</span>),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// Top right arc</span></span><br><span class="line">                drawArc(</span><br><span class="line">                    color = color,</span><br><span class="line">                    startAngle = <span class="number">270f</span>,</span><br><span class="line">                    sweepAngle = <span class="number">90f</span>,</span><br><span class="line">                    useCenter = <span class="literal">false</span>,</span><br><span class="line">                    topLeft = Offset(x = width - cornerRadius * <span class="number">2</span>, y = <span class="number">0f</span>),</span><br><span class="line">                    size = Size(cornerRadius * <span class="number">2</span>, cornerRadius * <span class="number">2</span>),</span><br><span class="line">                    style = Stroke(width = strokeWidthPx)</span><br><span class="line">                )</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = width, y = cornerRadius),</span><br><span class="line">                    end = Offset(x = width, y = height - cornerRadius),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// Bottom right arc</span></span><br><span class="line">                drawArc(</span><br><span class="line">                    color = color,</span><br><span class="line">                    startAngle = <span class="number">0f</span>,</span><br><span class="line">                    sweepAngle = <span class="number">90f</span>,</span><br><span class="line">                    useCenter = <span class="literal">false</span>,</span><br><span class="line">                    topLeft = Offset(</span><br><span class="line">                        x = width - <span class="number">2</span> * cornerRadius,</span><br><span class="line">                        y = height - <span class="number">2</span> * cornerRadius</span><br><span class="line">                    ),</span><br><span class="line">                    size = Size(cornerRadius * <span class="number">2</span>, cornerRadius * <span class="number">2</span>),</span><br><span class="line">                    style = Stroke(width = strokeWidthPx)</span><br><span class="line">                )</span><br><span class="line">                drawLine(</span><br><span class="line">                    color = color,</span><br><span class="line">                    start = Offset(x = <span class="number">0f</span>, y = height),</span><br><span class="line">                    end = Offset(x = width - cornerRadius, y = height),</span><br><span class="line">                    strokeWidth = strokeWidthPx</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">segmentedClip</span><span class="params">(borderPos: <span class="type">BorderPosition</span>, cornerPercent: <span class="type">Int</span> = <span class="number">0</span>)</span></span> = composed &#123;</span><br><span class="line">    <span class="keyword">val</span> shape = remember &#123;</span><br><span class="line">        <span class="keyword">when</span> (borderPos) &#123;</span><br><span class="line">            BorderPosition.Start -&gt;</span><br><span class="line">                RoundedCornerShape(topStartPercent = cornerPercent, bottomStartPercent = cornerPercent)</span><br><span class="line">            BorderPosition.End -&gt;</span><br><span class="line">                RoundedCornerShape(topEndPercent = cornerPercent, bottomEndPercent = cornerPercent)</span><br><span class="line">            <span class="keyword">else</span> -&gt; RectangleShape</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Modifier.clip(shape)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SegmentBorderExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> titles = listOf(<span class="string">&quot;歌曲&quot;</span>, <span class="string">&quot;专辑&quot;</span>, <span class="string">&quot;电台&quot;</span>, <span class="string">&quot;热门&quot;</span>)</span><br><span class="line">    Row(Modifier.padding(horizontal = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">        titles.forEachIndexed &#123; index, title -&gt;</span><br><span class="line">            <span class="keyword">val</span> borderPos = <span class="keyword">when</span> (index) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; BorderPosition.Start</span><br><span class="line">                titles.size - <span class="number">1</span> -&gt; BorderPosition.End</span><br><span class="line">                <span class="keyword">else</span> -&gt; BorderPosition.Center</span><br><span class="line">            &#125;</span><br><span class="line">            Box(</span><br><span class="line">                contentAlignment = Alignment.Center,</span><br><span class="line">                modifier = Modifier.weight(<span class="number">1f</span>).height(<span class="number">48.</span>dp)</span><br><span class="line">                    .segmentedClip(borderPos = borderPos, cornerPercent = <span class="number">50</span>)</span><br><span class="line">                    .segmentedBorder(</span><br><span class="line">                        strokeWidth = <span class="number">3.</span>dp,</span><br><span class="line">                        color = Color.Magenta,</span><br><span class="line">                        borderPos = borderPos,</span><br><span class="line">                        cornerPercent = <span class="number">50</span>,</span><br><span class="line">                        divider = <span class="literal">true</span></span><br><span class="line">                    )</span><br><span class="line">                    .clickable &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                    .padding(<span class="number">4.</span>dp)</span><br><span class="line">            ) &#123;</span><br><span class="line">                Text(text = title, fontSize = <span class="number">18.</span>sp)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7675f2ab937fc054c1cb2841ea39fb4e.png" alt="在这里插入图片描述"></p>
<h4 id="Modifier-layout-自定义"><a href="#Modifier-layout-自定义" class="headerlink" title="Modifier.layout() 自定义"></a>Modifier.layout() 自定义</h4><p>可以利用 <strong>Modifier.layout()</strong> 自定义一些布局相关的属性，如组件的位置偏移、大小限制、或者padding等。</p>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类似Modifier.offset()类似的效果</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myOffset</span><span class="params">(x : <span class="type">Dp</span> = <span class="number">0.</span>dp, y : <span class="type">Dp</span> = <span class="number">0.</span>dp)</span></span> = layout &#123; measurable, constraints -&gt;</span><br><span class="line">    <span class="keyword">val</span> placeable = measurable.measure(constraints)</span><br><span class="line">    layout(placeable.width, placeable.height) &#123;</span><br><span class="line">        placeable.placeRelative(x.roundToPx(), y.roundToPx()) <span class="comment">//设置偏移 支持RTL</span></span><br><span class="line">        <span class="comment">// placeable.place(0, 0) // 不支持RTL使用这个即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LayoutModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.background(Color.Red)) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;Offset&quot;</span>, Modifier.myOffset(<span class="number">5.</span>dp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义和Modifier.padding()类似的效果</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">myPadding</span><span class="params">(myPadding : <span class="type">Dp</span>)</span></span> = layout &#123; measurable, constraints -&gt;</span><br><span class="line">    <span class="keyword">val</span> padding = myPadding.roundToPx()</span><br><span class="line">    <span class="keyword">val</span> placeable = measurable.measure(constraints.copy(</span><br><span class="line">        maxWidth = constraints.maxWidth - padding * <span class="number">2</span>,</span><br><span class="line">        maxHeight = constraints.maxHeight - padding * <span class="number">2</span></span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> width =  placeable.width + padding * <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> height = placeable.height + padding * <span class="number">2</span></span><br><span class="line">    layout(width, height) &#123;</span><br><span class="line">        placeable.placeRelative(padding, padding)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LayoutModifierExample3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.background(Color.Green))&#123; </span><br><span class="line">        Text(text = <span class="string">&quot;padding&quot;</span>, Modifier.myPadding(<span class="number">10.</span>dp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类似的我们也可以尝试模仿DrawModifier的相关属性自己写出类似的东西。</p>
<h4 id="modifier-ElementOf-自定义"><a href="#modifier-ElementOf-自定义" class="headerlink" title="modifier.ElementOf 自定义"></a>modifier.ElementOf 自定义</h4><blockquote>
<p>暂时不知道使用compose版本，在1.2.0版本似乎已经移除。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="keyword">var</span> color: Color) : DrawModifierNode, Modifier.Node() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> ContentDrawScope.<span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        drawCircle(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">circle</span><span class="params">(color: <span class="type">Color</span>)</span></span> = <span class="keyword">this</span> then modifierElementOf(</span><br><span class="line">    key = color,</span><br><span class="line">    create = &#123; Circle(color) &#125;,</span><br><span class="line">    update = &#123; it.color = color &#125;,</span><br><span class="line">    definitions = &#123;</span><br><span class="line">        name = <span class="string">&quot;circle&quot;</span></span><br><span class="line">        properties[<span class="string">&quot;color&quot;</span>] = color</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ModifierElementOfExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.size(<span class="number">100.</span>dp).circle(Color.Red))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExperimentalComposeUiApi</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VerticalOffset</span>(<span class="keyword">var</span> padding: Dp) : LayoutModifierNode, Modifier.Node() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: MeasureResult &#123;</span><br><span class="line">        <span class="keyword">val</span> paddingPx = padding.roundToPx()</span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(constraints.offset(vertical = -paddingPx))</span><br><span class="line">        <span class="keyword">return</span> layout(placeable.width, placeable.height + paddingPx) &#123;</span><br><span class="line">            placeable.placeRelative(<span class="number">0</span>, paddingPx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">verticalOffset</span><span class="params">(padding: <span class="type">Dp</span>)</span></span> = <span class="keyword">this</span> then modifierElementOf(</span><br><span class="line">    key = padding,</span><br><span class="line">    create = &#123; VerticalOffset(padding) &#125;,</span><br><span class="line">    update = &#123; it.padding = padding &#125;,</span><br><span class="line">    definitions = &#123;</span><br><span class="line">        name = <span class="string">&quot;verticalPadding&quot;</span></span><br><span class="line">        properties[<span class="string">&quot;padding&quot;</span>] = padding</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">VerticalOffsetExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.size(<span class="number">100.</span>dp).background(Color.Gray).verticalOffset(<span class="number">20.</span>dp)) &#123;</span><br><span class="line">        Box(Modifier.fillMaxSize().background(Color.DarkGray))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SizeLoggerNode</span>(<span class="keyword">var</span> id: String) : LayoutAwareModifierNode, Modifier.Node() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRemeasured</span><span class="params">(size: <span class="type">IntSize</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;The size of <span class="variable">$id</span> was <span class="variable">$size</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalComposeUiApi::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">logSize</span><span class="params">(id: <span class="type">String</span>)</span></span> = <span class="keyword">this</span> then modifierElementOf(</span><br><span class="line">    key = id,</span><br><span class="line">    create = &#123; SizeLoggerNode(id) &#125;,</span><br><span class="line">    update = &#123; it.id = id &#125;,</span><br><span class="line">    definitions = &#123;</span><br><span class="line">        name = <span class="string">&quot;logSize&quot;</span></span><br><span class="line">        properties[<span class="string">&quot;id&quot;</span>] = id</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">PositionLoggerPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(Modifier.size(<span class="number">100.</span>dp).logSize(<span class="string">&quot;box&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modifierElementOf主要用于创建一个ModifierNodeElement对象，它用于绑定到Modifier.Node实例上面。</p>
<h3 id="Modifier在Compose模块中所处的位置"><a href="#Modifier在Compose模块中所处的位置" class="headerlink" title="Modifier在Compose模块中所处的位置"></a>Modifier在Compose模块中所处的位置</h3><p>Compose的库分为好几个模块，从上到下总共分为4层，上层依赖下层的，而每一层都可以单独使用。</p>
<table>
<thead>
<tr>
<th>Compose模块</th>
<th>package</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>Material</td>
<td>androidx.compose.material</td>
<td align="left">提供基于Material Design设计主题的内置组件，如Button、Text、Icon等</td>
</tr>
<tr>
<td>Foundation</td>
<td>androidx.compose.foundation</td>
<td align="left">为下面的UI层提供一些基础的Composable组件，如Row、Column、Box等布局类的组件，以及特定手势识别等，这些Composable可以支持跨平台通用</td>
</tr>
<tr>
<td>UI</td>
<td>androidx.compose.ui</td>
<td align="left">包含很多模块如ui-text、ui-graphics、ui-tooling等，该层为上层的Composable提供运行基础，Composable的测量、布局、绘制、事件处理等都是在该层，而Modifier的管理就是位于该层</td>
</tr>
<tr>
<td>Runtime</td>
<td>androidx.compose.runtime</td>
<td align="left">提供对Compose的UI树的管理能力，自动重组UI，通过diff驱动界面刷新等</td>
</tr>
</tbody></table>
<h3 id="Modifier链的构建过程"><a href="#Modifier链的构建过程" class="headerlink" title="Modifier链的构建过程"></a>Modifier链的构建过程</h3><p>Modifier 实际上是个接口，它有三个直接子类：</p>
<ul>
<li><strong>Modifier伴生对象：</strong> 我们在代码中使用 Modifier.xxx() 时，第一个开头的Modifier就是这个伴生对象， 当第一次调用Modifier的属性时，都是调用的这个伴生对象的then函数，它的then直接返回传入的Modifier对象。Modifier伴生对象默认没有任何效果，相当于提供一个白板，然后你再往上面加效果。</li>
<li><strong>CombinedModifier：</strong> 用于合成 Modifier 链中的每个 Modifier 结点，如果在伴生对象Modifier后面连续调用，则第二个开始的then函数会返回一个CombinedModifier对象，它将左边的Modifier对象作为outer（即当前调用者），右边的Modifie对象作为inner（即新设置的属性）进行合并。</li>
<li><strong>Modifier.Element内部子接口：</strong> 所有的其他类型的Modifier都是实现了该接口的子类（为方便合成CombinedModifier而存在）。</li>
</ul>
<p><strong>CombinedModifier</strong> 定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CombinedModifier</span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> outer: Modifier,</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> <span class="keyword">inner</span>: Modifier</span><br><span class="line">) : Modifier &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>then</strong>函数如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Modifier</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">then</span><span class="params">(other: <span class="type">Modifier</span>)</span></span>: Modifier =</span><br><span class="line">    	<span class="keyword">if</span> (other === Modifier) <span class="keyword">this</span> <span class="keyword">else</span> CombinedModifier(<span class="keyword">this</span>, other)</span><br><span class="line">   	...</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Modifier &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 伴生对象的then返回传入的Modifier对象</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">then</span><span class="params">(other: <span class="type">Modifier</span>)</span></span>: Modifier = other</span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到<strong>Modifier</strong> 接口的<strong>then</strong>返回的是<strong>CombinedModifier</strong>，其<strong>伴生对象</strong>的<strong>then</strong>返回的是<strong>传入的Modifier</strong> 。</p>
<p>例如 <strong>Modifier.size()</strong> 返回的是一个 <strong>SizeModifier</strong>，它是 <strong>LayoutModifier</strong> 的子类，而 <strong>LayoutModifier</strong> 实现了 <strong>Modifier.Element</strong> 接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">size</span><span class="params">(size: <span class="type">Dp</span>)</span></span> = <span class="keyword">this</span>.then(</span><br><span class="line">    SizeModifier(</span><br><span class="line">       ...</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SizeModifier</span>( ...) : LayoutModifier &#123;</span><br><span class="line"> 	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LayoutModifier</span> : <span class="type">Modifier.Element</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对 Modifier 连续调用<strong>then</strong>函数就会形成一个 Modifier 链条，例如如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Modifier</span><br><span class="line">    .size(<span class="number">100.</span>dp)</span><br><span class="line">    .background(Color.Red)</span><br><span class="line">    .padding(<span class="number">10.</span>dp)</span><br><span class="line">    .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>会形成如下的链条：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a0758f9e6d1b33e74d168d096dc44c3d.png"><br>所以<strong>Modifier</strong> 链条本质上是一个通过<strong>CombinedModifier</strong>连接起来的<strong>Modifier.Element</strong>链表：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f3912cf633f1166f20b4f8cba8467168.png"></p>
<p>另外，在Modifier接口中有两个重要的操作方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Modifier</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">foldIn</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">foldOut</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">Element</span>, <span class="type">R</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compose就是通过 <strong>foldIn()</strong> 与 <strong>foldOut()</strong> 专门来遍历 Modifier 链的，例如对于上面链条的代码执行 foldIn() 和 foldOut() ：</p>
<ul>
<li><strong>foldIn()： 正向遍历 Modifier 链</strong>，SizeModifier-&gt; Background -&gt; PaddingModifier -&gt; ComposedModifier</li>
<li><strong>foldOut()： 反向遍历 Modifier 链,</strong> ComposedModifier -&gt; PaddingModifier -&gt; Background -&gt;SizeModifier</li>
</ul>
<p>通过跟踪源码可以发现，我们调用的所有Composable组件最终都是调用了一个叫<strong>Layout</strong>的Composable:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="meta">@UiComposable</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Layout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> materialized = currentComposer.materialize(modifier) <span class="comment">// 重点</span></span><br><span class="line">    ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(</span><br><span class="line">        factory = ComposeUiNode.Constructor,</span><br><span class="line">        update = &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进 <strong>Composer.materialize()</strong> 可以发现源码中使用了 <strong>foldIn()</strong> 方法进行遍历：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Composer.<span class="title">materialize</span><span class="params">(modifier: <span class="type">Modifier</span>)</span></span>: Modifier &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">val</span> result = modifier.foldIn&lt;Modifier&gt;(Modifier) &#123; acc, element -&gt;</span><br><span class="line">        acc.then(</span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">is</span> ComposedModifier) &#123; </span><br><span class="line">                <span class="keyword">val</span> factory = element.factory <span class="keyword">as</span> Modifier.(Composer, <span class="built_in">Int</span>) -&gt; Modifier</span><br><span class="line">                <span class="keyword">val</span> composedMod = factory(Modifier, <span class="keyword">this</span>, <span class="number">0</span>) <span class="comment">// 生产 Modifier</span></span><br><span class="line">                materialize(composedMod) <span class="comment">// 递归处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> element</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里对 ComposedModifier 进行了特殊判断，因为 composed() 返回的 ComposedModifier 包含一个 可以构建 Modifier 的工厂函数 ，而这里想做的是将 Modifier 链中的所有 ComposedModifier 摊平，让其 factory 内部产生的 Modifier 也能加入到 Modifier 链中。</p>
<h3 id="Modifier测量绘制原理初探"><a href="#Modifier测量绘制原理初探" class="headerlink" title="Modifier测量绘制原理初探"></a>Modifier测量绘制原理初探</h3><p>Compose通过<strong>ComposeView</strong>挂接到传统View视图体系中，ComposeView是一个ViewGroup，它的直接子View是一个<strong>AndroidComposeView</strong>对象（它也是一个ViewGroup），然后在AndroidComposeView中管理着一棵由<strong>LayoutNode</strong>组成的UI树，每个Composable最终都对应着<strong>LayoutNode</strong>树中的一个节点。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/60d7436a30d249b87c3fc77064aab564.png" alt="在这里插入图片描述"><br>在Activity的onCreate方法中调用的<strong>setContent</strong>方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">setContent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    parent: <span class="type">CompositionContext</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> existingComposeView = window.decorView</span><br><span class="line">        .findViewById&lt;ViewGroup&gt;(android.R.id.content)</span><br><span class="line">        .getChildAt(<span class="number">0</span>) <span class="keyword">as</span>? ComposeView</span><br><span class="line">    <span class="comment">// 已存在ComposeView就直接调用其setContent方法，否则就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (existingComposeView != <span class="literal">null</span>) with(existingComposeView) &#123;</span><br><span class="line">        setParentCompositionContext(parent)</span><br><span class="line">        setContent(content)</span><br><span class="line">    &#125; <span class="keyword">else</span> ComposeView(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">        ...</span><br><span class="line">        setContent(content) <span class="comment">// 重点</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 调用Activity的setContentView方法将自身添加进去</span></span><br><span class="line">        setContentView(<span class="keyword">this</span>, DefaultActivityContentLayoutParams) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<strong>setContent</strong>方法，其中调用<strong>createComposition</strong>方法创建一个Composition对象来管理Compose的UI树：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComposeView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line"> 	...</span><br><span class="line">) : AbstractComposeView(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the Jetpack Compose UI content for this view.</span></span><br><span class="line"><span class="comment">     * Initial composition will occur when the view becomes attached to a window or when</span></span><br><span class="line"><span class="comment">     * [createComposition] is called, whichever comes first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setContent</span><span class="params">(content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">        shouldCreateCompositionOnAttachedToWindow = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">this</span>.content.value = content <span class="comment">// 保存onCreate中setContent的lambda返回的Composable组件</span></span><br><span class="line">        <span class="keyword">if</span> (isAttachedToWindow) &#123;</span><br><span class="line">            createComposition() <span class="comment">// 重点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在createComposition()方法中会调用ensureCompositionCreated()方法，实际上当ComposeView被首次创建时，并不会直接调用createComposition()方法，而是在onAttachedToWindow()方法中调用了ensureCompositionCreated()方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractComposeView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line">    ...</span><br><span class="line">) : ViewGroup(context, attrs, defStyleAttr) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttachedToWindow</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToWindow()</span><br><span class="line">        previousAttachedWindowToken = windowToken</span><br><span class="line">        <span class="keyword">if</span> (shouldCreateCompositionOnAttachedToWindow) &#123;</span><br><span class="line">            ensureCompositionCreated()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">fun</span> <span class="title">createComposition</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ensureCompositionCreated()</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ensureCompositionCreated</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (composition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                creatingComposition = <span class="literal">true</span></span><br><span class="line">                composition = setContent(resolveParentCompositionContext()) &#123;</span><br><span class="line">                    Content() <span class="comment">// 返回保存的onCreate中填写的Composable组件</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                creatingComposition = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进这个在onAttachedToWindow()方法中的setContent方法，发现它是一个扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrapper.android.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> AbstractComposeView.<span class="title">setContent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    parent: <span class="type">CompositionContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Composition &#123;</span><br><span class="line">    GlobalSnapshotManager.ensureStarted()</span><br><span class="line">    <span class="comment">// 创建AndroidComposeView添加到ComposeView当中，且AbstractComposeView只能有一个child</span></span><br><span class="line">    <span class="keyword">val</span> composeView =</span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            getChildAt(<span class="number">0</span>) <span class="keyword">as</span>? AndroidComposeView</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllViews(); <span class="literal">null</span></span><br><span class="line">        &#125; ?: AndroidComposeView(context).also &#123; addView(it.view, DefaultLayoutParams) &#125; </span><br><span class="line">    <span class="keyword">return</span> doSetContent(composeView, parent, content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetContent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    owner: <span class="type">AndroidComposeView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    parent: <span class="type">CompositionContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Composition &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> original = Composition(UiApplier(owner.root), parent) <span class="comment">// 创建Composition用来管理UI树</span></span><br><span class="line">    <span class="keyword">val</span> wrapped = ...</span><br><span class="line">    wrapped.setContent(content)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到，这里创建Composition时，传入了一个<strong>owner.root</strong>参数，从名字就可以猜出来，它就是整棵LayoutNode树的根节点：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AndroidComoseView.android.kt</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> root = LayoutNode().also &#123;</span><br><span class="line">       it.measurePolicy = RootMeasurePolicy</span><br><span class="line">       it.density = density</span><br><span class="line">       <span class="comment">// Composed modifiers cannot be added here directly</span></span><br><span class="line">       it.modifier = Modifier</span><br><span class="line">           .then(semanticsModifier)</span><br><span class="line">           .then(rotaryInputModifier)</span><br><span class="line">           .then(_focusManager.modifier)</span><br><span class="line">           .then(keyInputModifier)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AndroidComoseView.android.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> measureAndLayoutDelegate = MeasureAndLayoutDelegate(root)</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">     ...</span><br><span class="line">	 measureAndLayoutDelegate.updateRootConstraints(constraints) <span class="comment">// 更新根节点的约束条件，同时会将root添加到relayoutNodes中</span></span><br><span class="line">        measureAndLayoutDelegate.measureOnly()</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="type">Boolean</span>, l: <span class="type">Int</span>, t: <span class="type">Int</span>, r: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">       measureAndLayoutDelegate.measureAndLayout(resendMotionEventOnLayout) <span class="comment">// 遍历relayoutNodes中的节点执行measureAndLayout</span></span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>代理类的<strong>measureAndLayout</strong>方法会遍历保存在其<strong>relayoutNodes</strong>集合中的每个节点（该集合保存了所有需要进行测量和布局的LayoutNode节点，包括root在内），然后执行其<strong>doRemeasure</strong>和<strong>place</strong>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// MeasureAndLayoutDelegate.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">measureAndLayout</span><span class="params">(onLayout: (() -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span>)</span></span>: <span class="built_in">Boolean</span> &#123; </span><br><span class="line">    performMeasureAndLayout &#123;</span><br><span class="line">        <span class="keyword">if</span> (relayoutNodes.isNotEmpty()) &#123;</span><br><span class="line">            relayoutNodes.popEach &#123; layoutNode -&gt;</span><br><span class="line">                <span class="keyword">val</span> sizeChanged = remeasureAndRelayoutIfNeeded(layoutNode)</span><br><span class="line">                ...</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">remeasureAndRelayoutIfNeeded</span><span class="params">(layoutNode: <span class="type">LayoutNode</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sizeChanged = <span class="literal">false</span></span><br><span class="line">    ...</span><br><span class="line">    sizeChanged = doRemeasure(layoutNode, constraints)</span><br><span class="line">   	...</span><br><span class="line">   	layoutNode.replace()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compose的测量绘制分为三个阶段：重组、布局、绘制</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/794332105b3d17ba302094fea52d5719.png"></p>
<p>其中Layout阶段包含了我们在传统View中的测量和布局的概念，最后一步就是用Canvas进行绘制。</p>
<p>看一下 <strong>doRemeasure()</strong> 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MeasureAndLayoutDelegate.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRemeasure</span><span class="params">(layoutNode: <span class="type">LayoutNode</span>, constraints: <span class="type">Constraints</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sizeChanged = <span class="keyword">if</span> (constraints != <span class="literal">null</span>) &#123;</span><br><span class="line">        layoutNode.remeasure(constraints) <span class="comment">// 重点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutNode.remeasure()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里将约束条件传给了 <strong>layoutNode</strong> 中的 <strong>remeasure()</strong> 方法中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutNode.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> measurePassDelegate</span><br><span class="line">       <span class="keyword">get</span>() = layoutDelegate.measurePassDelegate</span><br><span class="line">   <span class="keyword">internal</span> <span class="keyword">val</span> layoutDelegate = LayoutNodeLayoutDelegate(<span class="keyword">this</span>)</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       constraints: <span class="type">Constraints</span>? = layoutDelegate.lastConstraints</span></span></span><br><span class="line"><span class="params"><span class="function">   )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">if</span> (constraints != <span class="literal">null</span>) &#123;</span><br><span class="line">           ... </span><br><span class="line">           measurePassDelegate.remeasure(constraints) <span class="comment">// 重点</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// LayoutNodeLayoutDelegate.kt</span></span><br><span class="line"> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">MeasurePassDelegate</span> : <span class="type">Measurable</span>, <span class="type">Placeable</span>(), AlignmentLinesOwner &#123;</span><br><span class="line"> 	...</span><br><span class="line"> 	remeasure(constraints)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">remeasure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     performMeasure(constraints)</span><br><span class="line">     ...        </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">performMeasure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     layoutNode.requireOwner().snapshotObserver.observeMeasureSnapshotReads(</span><br><span class="line">         layoutNode,</span><br><span class="line">         affectsLookahead = <span class="literal">false</span></span><br><span class="line">     ) &#123;</span><br><span class="line">         outerCoordinator.measure(constraints) <span class="comment">// 重点</span></span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">if</span> (layoutState == LayoutState.Measuring) &#123;</span><br><span class="line">         markLayoutPending() </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的outerCoordinator是LayoutNode中NodeChain中的对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LayoutNodeLayoutDelegate</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layoutNode: LayoutNode,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> outerCoordinator: NodeCoordinator</span><br><span class="line">        <span class="keyword">get</span>() = layoutNode.nodes.outerCoordinator</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LayoutNode.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> nodes = NodeChain(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>NodeChain是一个链表结构，其中的head和tail分别是Modifier.Node类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeChain.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">NodeChain</span>(<span class="keyword">val</span> layoutNode: LayoutNode) &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> innerCoordinator = InnerNodeCoordinator(layoutNode)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> outerCoordinator: NodeCoordinator = innerCoordinator </span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> tail: Modifier.Node = innerCoordinator.tail</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> head: Modifier.Node = tail </span><br><span class="line">    ....    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 NodeCoordinator 是用来辅助Node节点处理测量和布局的，其中包含measure和placeAt的方法逻辑。NodeChain链表上的每一个Node都会对应的绑定一个NodeCoordinator 对象来辅助处理。</p>
<p>那么NodeChain这个链表什么时候会被更新呢，我们可以在LayoutNode中看到其成员对象modifier的set方法被覆写了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayoutNode.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> modifier: Modifier = Modifier</span><br><span class="line">    <span class="keyword">set</span>(value) &#123; </span><br><span class="line">        ...</span><br><span class="line">        field = value</span><br><span class="line">        nodes.updateFrom(value)</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<strong>NodeChain</strong>的<strong>updateFrom</strong>方法，该方法将根据<strong>Modifier链</strong>来更新对应的<strong>NodeChain</strong>，也就是说每当有Modifier对象被设置到LayoutNode上面时，都会调用updateFrom方法进行更新对应的NodeChain。</p>
<p>在<strong>updateFrom</strong>方法中，会调用<strong>Modifier.fillVector</strong>方法先将嵌套的Modifier按顺序进行展平成一个数组，随后根据展平结果将Modifier封装成Modifier.Node再串成一个双向链表。每个Composable对应的LayoutNode都拥有一个NodeChain链表，而NodeChain链表中的每个Modifier.Node节点都持有一个NodeCoordinator辅助对象。每当Modifier链更新时，会同步更新该链表，同时会同步每个Modifier.Node对应的NodeCoordinator。</p>
<p><strong>Modifier.fillVector</strong>方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">fillVector</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">MutableVector</span>&lt;<span class="type">Modifier</span>.<span class="type">Element</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MutableVector&lt;Modifier.Element&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = MutableVector&lt;Modifier&gt;(result.size).also &#123; it.add(<span class="keyword">this</span>) &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">val</span> next = stack.removeAt(stack.size - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">is</span> CombinedModifier -&gt; &#123;</span><br><span class="line">                stack.add(next.<span class="keyword">inner</span>)</span><br><span class="line">                stack.add(next.outer)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> Modifier.Element -&gt; result.add(next)</span><br><span class="line">            <span class="keyword">else</span> -&gt; next.all &#123;</span><br><span class="line">                result.add(it)</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，从1.3.0+版本开始，Compose中不再使用foldIn foldOut方法对Modifier进行遍历了，在1.3.0之前的版本LayoutNode源码中是通过foldOut遍历+头插法处理，而现在是通过fillVecto<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=r%E6%96%B9&spm=1001.2101.3001.7020">r方</a>法处理达到类似的效果。</p>
</blockquote>
<p>在进行测量时，Compose会遍历处理这个链表的每个Node对应的NodeCoordinator 的measure方法，对于布局也是类似，会调用placeAt方法。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/30e24b9b6166e379d5dbe44cc302cf06.png" alt="在这里插入图片描述"></p>
<p>所以我们可以得到的结论是每个 Composable 组件最终对应一个 LayoutNode 节点，而每个 LayoutNode 节点则关联了一连串的 Modifier.Node 节点。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/41121551cc4d5d68dda39007dae2c6e9.png" alt="在这里插入图片描述"></p>
<p>而 Modifier.Node 节点具体是以双向链表的形式挂到每一个 LayoutNode 节点上面的。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2df2dc6c94ab09ebc041271e8850ad7f.png" alt="在这里插入图片描述"></p>
<p>由于Modifier是以NodeChain链表的形式挂到LayoutNode上面的，所以在重组时，如果只是更改了Modifier属性，将只会更新该Modifier对应在NodeChain链表中的某个Node节点，而不是重建整个Node链。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a8075b7da8080e29c7a3cf378b592f8a.png"></p>
<h3 id="Modifier链的顺序对结果的影响"><a href="#Modifier链的顺序对结果的影响" class="headerlink" title="Modifier链的顺序对结果的影响"></a>Modifier链的顺序对结果的影响</h3><p>首先我们要明确的一点是所有跟尺寸相关的Modifier修饰符只会影响 Compose 的布局阶段，而跟颜色背景形状相关的Modifier修饰符则只会影响 Compose 绘制阶段。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/290e7df05bc5ef60fa370d2b5fd3ddfd.png" alt="在这里插入图片描述"><br>也就是说，我们可以将Modifier修饰符主要分成两类来看，LayoutModifier 和 DrawModifier （当然可以是其他的类型，这里以这两类为例）。前者影响尺寸大小，后者影响背景形状等。</p>
<p>对于 LayoutModifier 来说Modifier的执行顺序是按照从左到右，左边修饰符的尺寸将影响右边的修饰符。可组合对象的最终大小取决于作为参数传递的所有修饰符。修饰符将从左到右更新约束，然后从右到左返回大小。（如果左边的约束条件更加严格的话，则右边的尺寸将受到左边的约束）</p>
<p>例如来看如下代码的执行结果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(Modifier.border(<span class="number">1.</span>dp, Color.Red).size(<span class="number">32.</span>dp).padding(<span class="number">8.</span>dp).border(<span class="number">1.</span>dp, Color.Blue))</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f7f85c7c2be438a54a76b34549e1a9f9.png" alt="在这里插入图片描述"><br>首先会绘制一个32dp大小的红色边框，接着会将【32dp大小的约束】向右边传递，然后会在32dp的内部添加8dp的边距，接着将【32dp大小且8dp内边距的约束】继续传给Box组件，并在上面绘制出一个32dp-8dp*2&#x3D;16dp大小的蓝色边框。</p>
<p>如果现在把 <strong>.size()</strong> 和 <strong>.padding()</strong> 的顺序交换一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(Modifier.border(<span class="number">1.</span>dp, Color.Red).padding(<span class="number">8.</span>dp).size(<span class="number">32.</span>dp).border(<span class="number">1.</span>dp, Color.Blue))</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8dc21e444aa998fc6534959b67c7b98d.png" alt="在这里插入图片描述"><br>可以看到，结果是先应用了8dp的间距，在8dp的内部再显示了32dp大小的蓝色边框，或者可以理解为在32dp大小的基础之上添加了8dp的外间距，所以红色边框的大小是32dp+8dp*2&#x3D;48dp。</p>
<p>对于 DrawModifier 来说，从执行顺序上看是从左到右，但生效结果的顺序是从右到左，是逆序的，即后执行的先生效。</p>
<p>但这样的顺序也有好处，来看下面这个例子:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyFancyButton</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line"> Text(</span><br><span class="line">   text = <span class="string">&quot;Ok&quot;</span>,</span><br><span class="line">   modifier = modifier</span><br><span class="line">     .clickable(onClick = &#123; <span class="comment">/*do something*/</span> &#125;)</span><br><span class="line">     .background(Color.Blue, RoundedCornerShape(<span class="number">4.</span>dp))</span><br><span class="line">     .padding(<span class="number">8.</span>dp)</span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要将modifier作为Composable的参数传入，当前组件就允许其父组件对其添加额外的Modifier属性来修饰，例如父组件额外设置一个padding，因为最后添加的Modifier属性会先生效，因此组件内部的边框不会受到外部的影响。</p>
<p>再来看几个例子，以加深理解</p>
<p>下面的调用链会先绘制红色背景，后绘制蓝色背景，因此后绘制的蓝色会盖住红色背景，所以最终效果是一个50dp大小的蓝色块：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(Modifier.background(Color.Red).background(Color.Blue).size(<span class="number">50.</span>dp))</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/06430bff428ed81457e952a359e69abc.png"></p>
<p>而下面的代码调用链的结果会是40dp的蓝色块盖在80dp的红色块之上：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(Modifier.background(Color.Red).requiredSize(<span class="number">80.</span>dp).background(Color.Blue).requiredSize(<span class="number">40.</span>dp))</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/967b4f374e33970474013654f2f014e5.png"></p>
<p>如果将上面代码中的 <strong>requiredSize(80.dp)</strong> 和 <strong>requiredSize(40.dp)</strong> 对换位置：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Box(</span><br><span class="line">    Modifier.background(Color.Gray).fillMaxSize(), <span class="comment">// 规定父组件的大小才能看出效果</span></span><br><span class="line">    contentAlignment = Alignment.Center</span><br><span class="line">) &#123;   	</span><br><span class="line">	Box(Modifier.background(Color.Red).requiredSize(<span class="number">40.</span>dp).background(Color.Blue).requiredSize(<span class="number">80.</span>dp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ad6b027edd2b2f10a1faf4b802b39da7.png"></p>
<p>这将会得到一个80dp的蓝色块，这是因为<strong>requiredSize</strong>属性不会使用左边传入的constraints约束条件进行约束，该多大就是多大，因此是80dp的蓝色块盖在40dp的红色块之上。</p>
<p>如果此时再将<strong>requiredSize</strong>换成<strong>size</strong>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box(Modifier.background(Color.Red).size(<span class="number">40.</span>dp).background(Color.Blue).size(<span class="number">80.</span>dp))</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4d76760116d26e80f2e943c39773a4d5.png"></p>
<p>这将会得到一个40dp的蓝色块，因为此时左边的约束条件会传递给右边，而左边的约束条件更严格。或者从效果上也可以理解为是80dp的蓝色块上裁剪出一块40dp的大小。</p>
<h3 id="OnRemeasuredModifier-和-OnPlacedModifier"><a href="#OnRemeasuredModifier-和-OnPlacedModifier" class="headerlink" title="OnRemeasuredModifier 和 OnPlacedModifier"></a>OnRemeasuredModifier 和 OnPlacedModifier</h3><p><strong>OnRemeasuredModifier</strong>: Composable的<strong>remeasure</strong>方法执行完毕被回调，每次测量之后调用，可以用来获取测量后的尺寸大小。类比原生View的onMeasure()。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">OnRemeasuredModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(</span><br><span class="line">        Modifier.background(Color.Gray).size(<span class="number">200.</span>dp),</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;AAAAAAAAAAAAdddddddddddddddddddddddddddddddddddddd&quot;</span>,</span><br><span class="line">            Modifier.then(<span class="keyword">object</span> : OnRemeasuredModifier &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRemeasured</span><span class="params">(size: <span class="type">IntSize</span>)</span></span> &#123;</span><br><span class="line">                    println(size)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<strong>Modifier.onSizeChanged</strong>来达到同样的效果，因为其内部就是基于OnRemeasuredModifier 封装实现的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">OnRemeasuredModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(</span><br><span class="line">        Modifier.background(Color.Gray).size(<span class="number">200.</span>dp),</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;BBBBBBBBBBBhhhhhhhhhhhhhh&quot;</span>,</span><br><span class="line">             Modifier.onSizeChanged &#123; size -&gt;</span><br><span class="line">                  println(size)</span><br><span class="line">             &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OnPlacedModifier:</strong> 可以拿到坐标、尺寸等信息，类比原生View的onLayout()。它与OnRemeasuredModifier相比，它获得的信息更全，但是OnRemeasuredModifier发生的更早。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">OnPlacedModifierExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Box(</span><br><span class="line">        Modifier.background(Color.Gray).size(<span class="number">200.</span>dp),</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;AAA&quot;</span>,</span><br><span class="line">            Modifier.onPlaced &#123; layoutCoordinates -&gt;</span><br><span class="line">                <span class="keyword">val</span> posInParent = layoutCoordinates.positionInParent()</span><br><span class="line">                <span class="keyword">val</span> posInWindow = layoutCoordinates.positionInWindow()</span><br><span class="line">                <span class="keyword">val</span> posInRoot = layoutCoordinates.positionInRoot()</span><br><span class="line">                <span class="keyword">val</span> size = layoutCoordinates.size</span><br><span class="line">                <span class="keyword">val</span> parentLayCoordinates = layoutCoordinates.parentLayoutCoordinates</span><br><span class="line">                println(<span class="string">&quot;posInParent: <span class="variable">$posInParent</span>&quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;posInWindow: <span class="variable">$posInWindow</span>&quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;posInRoot: <span class="variable">$posInRoot</span>&quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;size: <span class="variable">$size</span>&quot;</span>)</span><br><span class="line">                println(<span class="string">&quot;parentLayCoordinates.size: <span class="subst">$&#123;parentLayCoordinates?.size&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<strong>OnRemeasuredModifier</strong>和<strong>OnPlacedModifier</strong>都是用来获取通知的，并不是用来执行<strong>measure</strong>或<strong>layout</strong>操作，而是在这些操作执行完毕后被通知的。</p>
<h3 id="OnGloballyPositionedModifier"><a href="#OnGloballyPositionedModifier" class="headerlink" title="OnGloballyPositionedModifier"></a>OnGloballyPositionedModifier</h3><p>当内容的全局位置可能发生变化时，会回调<code>Modifier</code>的 <code>onGloballyPositioned</code> 方法，并回传<code>LayoutCoordinates</code> 对象。注意，当坐标最终确定时，它将在组合之后被调用。</p>
<p>使用方式也很简单：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyComposable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">    Column(modifier = Modifier</span><br><span class="line">        .fillMaxWidth()</span><br><span class="line">        .height(<span class="number">300.</span>dp)</span><br><span class="line">        .border(<span class="number">2.</span>dp, Color.Red)</span><br><span class="line">        .onGloballyPositioned &#123;</span><br><span class="line">            <span class="keyword">val</span> positionInParent: Offset = it.positionInParent()</span><br><span class="line">            <span class="keyword">val</span> positionInRoot: Offset = it.positionInRoot()</span><br><span class="line">            <span class="keyword">val</span> positionInWindow: Offset = it.positionInWindow()</span><br><span class="line">            text = <span class="string">&quot;positionInParent: <span class="variable">$positionInParent</span>\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;positionInRoot: <span class="variable">$positionInRoot</span>\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;positionInWindow: <span class="variable">$positionInWindow</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(text = text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>LayoutCoordinates</code>可用时，这个回调将至少被调用一次，并且每次元素在窗口中的位置发生变化时都会被调用。但是，不能保证在每次修改元素相对于屏幕的位置发生变化时都调用它。例如，系统可以在不触发回调的情况下移动窗口内的内容。如果您正在使用<code>LayoutCoordinates</code>来计算屏幕上的位置，而不仅仅是在窗口内，则可能不会收到回调。</p>
<h3 id="ParentDataModifier"><a href="#ParentDataModifier" class="headerlink" title="ParentDataModifier"></a>ParentDataModifier</h3><p><strong>ParentDataModifier：</strong> 一个继承自Modifier.Element的接口，它是一个可以为父布局提供数据的修饰符。可以在测量和布局期间通过IntrinsicMeasurable.parentData 读取到设置的数据值。parentData 通常用于通知父类如何测量和定位子类布局。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ParentDataModifier</span> : <span class="type">Modifier.Element</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span>: Any?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，以下代码利用ParentDataModifier实现了一个简易版的Row&#x2F;Column中的<strong>weight</strong>属性效果：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义weight</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">VerticalScope</span> &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">weight</span><span class="params">(weight: <span class="type">Float</span>)</span></span> : Modifier</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeightParentData</span>(<span class="keyword">val</span> weight: <span class="built_in">Float</span>=<span class="number">0f</span>) : ParentDataModifier &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Density.<span class="title">modifyParentData</span><span class="params">(parentData: <span class="type">Any</span>?)</span></span> = <span class="keyword">this</span><span class="symbol">@WeightParentData</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">object</span> VerticalScopeInstance : VerticalScope &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> Modifier.<span class="title">weight</span><span class="params">(weight: <span class="type">Float</span>)</span></span>: Modifier = <span class="keyword">this</span>.then(</span><br><span class="line">        WeightParentData(weight)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WeightedVerticalLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> <span class="type">VerticalScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> measurePolicy = MeasurePolicy &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123;it.measure(constraints)&#125;</span><br><span class="line">        <span class="comment">// 获取各weight值</span></span><br><span class="line">        <span class="keyword">val</span> weights = measurables.map &#123;</span><br><span class="line">            (it.parentData <span class="keyword">as</span> WeightParentData).weight</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> totalHeight = constraints.maxHeight</span><br><span class="line">        <span class="keyword">val</span> totalWeight = weights.sum()</span><br><span class="line">        <span class="comment">// 宽度：最宽的一项</span></span><br><span class="line">        <span class="keyword">val</span> width = placeables.maxOf &#123; it.width &#125;</span><br><span class="line">        layout(width, totalHeight) &#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">            placeables.forEachIndexed() &#123; i, placeable -&gt;</span><br><span class="line">                placeable.placeRelative(<span class="number">0</span>, y)</span><br><span class="line">                <span class="comment">// 按比例设置大小</span></span><br><span class="line">                y += (totalHeight * weights[i] / totalWeight).toInt()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Layout(&#123; VerticalScopeInstance.content() &#125;, modifier, measurePolicy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WeightedVerticalLayoutExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    WeightedVerticalLayout(Modifier.padding(<span class="number">16.</span>dp).height(<span class="number">200.</span>dp)) &#123;</span><br><span class="line">        Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">1f</span>).background(Color.Red))</span><br><span class="line">        Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">2f</span>).background(Color.Green))</span><br><span class="line">        Box(modifier = Modifier.width(<span class="number">40.</span>dp).weight(<span class="number">7f</span>).background(Color.Blue))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WeightedVerticalLayoutExamplePreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    WeightedVerticalLayoutExample()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fe901788644032700cb17b2107989e59.png"></p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jetpackcompose.cn/docs/principle/modifierStructure">图解Modifier</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=BjGX2RftXsU">Compose Modifiers deep dive</a></li>
<li><a target="_blank" rel="noopener" href="https://jetpackcompose.cn/docs/layout/parent_data">ParentData</a></li>
<li>《Jetpack Compose从入门到实战》- 机械工业出版社 - 2022年9月</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E7%9A%84modifier/">https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E7%9A%84modifier/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime%20%E9%AB%98%E7%BA%A7%E7%94%A8%E4%BE%8B/" title="Compose runtime 高级用例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose runtime 高级用例</div></div><div class="info-2"><div class="info-item-1">Compose runtime vs Compose UI在深入讨论之前，非常重要的一点是要区分 Compose UI 和 Compose runtime。Compose UI 是 Android 的新 UI 工具包，具有 LayoutNodes 的树形结构，它们稍后在画布上绘制其内容。Compose runtime 提供底层机制和许多状态&#x2F;组合相关的原语。 随着 Compose 编译器 支持完整的 Kotlin 平台谱系，现在可以在几乎任何地方（只要它运行Kotlin）使用 runtime来管理 UI 或任何其他树形结构。注意“其他树形结构”部分：Compose runtime 中几乎没有直接提到 UI（或Android）。虽然该运行时肯定是为了支持该用例而创建和优化的，但它仍然足够通用，可以构建任何类型的树结构。事实上，它在这方面与 React JS 非常相似，React JS 的主要用途是在 Web上创建 UI，但它在合成器或 3D 渲染器等领域找到了更广泛的用途。大多数自定义渲染器重用 React...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20%E7%BC%96%E8%AF%91%E5%99%A8/" title="Compose 编译器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Compose 编译器</div></div><div class="info-2"><div class="info-item-1">Jetpack Compose由一系列的库组成，但我们需要重点关注三个特定的库：Compose compiler、Compose runtime 和 Compose UI。 其中 Compose编译器 和 Compose runtime 是Jetpack Compose的支柱。从技术上讲，Compose UI 不是Compose体系结构的一部分，因为运行时和编译器被设计为通用的，并由符合其需求的任何客户端库使用。Compose UI 只是其中一个可用的客户端。还有其他的客户端库正在开发中，比如JetBrains为桌面和Web开发的客户端库。也就是说，浏览Compose UI将帮助我们理解Compose如何提供可组合树的运行时内存表示，以及它最终如何从其中物化真正的元素。  到目前为止，我们已经了解到Compose编译器和Compose...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">Modifier的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Modifier的复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">Modifier的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">4.</span> <span class="toc-text">Modifier的自定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Modifier-composed-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">Modifier.composed 自定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Modifier-layout-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.</span> <span class="toc-text">Modifier.layout() 自定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#modifier-ElementOf-%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.</span> <span class="toc-text">modifier.ElementOf 自定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E5%9C%A8Compose%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%89%80%E5%A4%84%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">Modifier在Compose模块中所处的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E9%93%BE%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">Modifier链的构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E6%B5%8B%E9%87%8F%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2"><span class="toc-number">7.</span> <span class="toc-text">Modifier测量绘制原理初探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier%E9%93%BE%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AF%B9%E7%BB%93%E6%9E%9C%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">8.</span> <span class="toc-text">Modifier链的顺序对结果的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnRemeasuredModifier-%E5%92%8C-OnPlacedModifier"><span class="toc-number">9.</span> <span class="toc-text">OnRemeasuredModifier 和 OnPlacedModifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnGloballyPositionedModifier"><span class="toc-number">10.</span> <span class="toc-text">OnGloballyPositionedModifier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParentDataModifier"><span class="toc-number">11.</span> <span class="toc-text">ParentDataModifier</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>