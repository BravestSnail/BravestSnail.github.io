<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose中的state核心思想 | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Compose 中的状态应用的“状态”是指可以随时间变化的任何值。这是一个非常宽泛的定义，从 Room 数据库到类的变量，全部涵盖在内。 所有 Android 应用都会向用户显示状态。下面是 Android 应用中的一些状态示例：  聊天应用中最新收到的消息。 用户的个人资料照片。 在项列表中的滚动位置。   关键提示：状态决定界面在任何特定时间的显示内容。  下面的示例通过构建一个健康App应用">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose中的state核心思想">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84state%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="Compose 中的状态应用的“状态”是指可以随时间变化的任何值。这是一个非常宽泛的定义，从 Room 数据库到类的变量，全部涵盖在内。 所有 Android 应用都会向用户显示状态。下面是 Android 应用中的一些状态示例：  聊天应用中最新收到的消息。 用户的个人资料照片。 在项列表中的滚动位置。   关键提示：状态决定界面在任何特定时间的显示内容。  下面的示例通过构建一个健康App应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.121Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.121Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose中的state核心思想",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84state%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.121Z",
  "dateModified": "2025-06-04T12:46:35.121Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84state%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose中的state核心思想',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose中的state核心思想</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose中的state核心思想</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.121Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.121Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="Compose-中的状态"><a href="#Compose-中的状态" class="headerlink" title="Compose 中的状态"></a>Compose 中的状态</h3><p>应用的“状态”是指可以随时间变化的任何值。这是一个非常宽泛的定义，从 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Room&spm=1001.2101.3001.7020">Room</a> 数据库到类的变量，全部涵盖在内。</p>
<p>所有 Android 应用都会向用户显示状态。下面是 Android 应用中的一些状态示例：</p>
<ul>
<li>聊天应用中最新收到的消息。</li>
<li>用户的个人资料照片。</li>
<li>在项列表中的滚动位置。</li>
</ul>
<blockquote>
<p>关键提示：状态决定界面在任何特定时间的显示内容。</p>
</blockquote>
<p>下面的示例通过构建一个健康App应用来展示如何正确的使用Compose中的状态。</p>
<p>构建的第一项功能是饮水计数器，用于记录您一天饮用了多少杯水。</p>
<p>创建一个名为 WaterCounter 的可组合函数，其中包含一个 Text 可组合项，用于显示饮水杯数。饮水杯数应存储在名为 count 的值中。</p>
<p>创建一个包含 WaterCounter 可组合函数的新文件 WaterCounter.kt，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.padding</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.Text</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.dp</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> count = <span class="number">0</span></span><br><span class="line">   Text(</span><br><span class="line">       text = <span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>,</span><br><span class="line">       modifier = modifier.padding(<span class="number">16.</span>dp)</span><br><span class="line">   )</span><br><span class="line">   Button(onClick = &#123; count++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">       Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个代表主屏幕的文件 WellnessScreen.kt，然后调用 WaterCounter 函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessScreen</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   WaterCounter(modifier)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开 MainActivity.kt，在 activity 的 setContent 块内调用新创建的 WellnessScreen 可组合项，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ComponentActivity</span>() &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       setContent &#123;</span><br><span class="line">           BasicStateCodelabTheme &#123;</span><br><span class="line">               <span class="comment">// A surface container using the &#x27;background&#x27; color from the theme</span></span><br><span class="line">               Surface(</span><br><span class="line">                   modifier = Modifier.fillMaxSize(),</span><br><span class="line">                   color = MaterialTheme.colors.background</span><br><span class="line">               ) &#123;</span><br><span class="line">                   WellnessScreen()</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：setContent 内部的 MainActivity 中使用的应用主题取决于项目名称。此处假定项目名为 BasicStateCodelab。</p>
</blockquote>
<p>如果现在运行应用，您会看到我们的基本饮水计数器屏幕，其中包含<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%A1%AC%E7%BC%96%E7%A0%81&spm=1001.2101.3001.7020">硬编码</a>的饮水杯数。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6f8755d763f3a2581d79709b44e43c16.png"></p>
<p>WaterCounter 可组合函数的状态为变量 count。但是，点击按钮时，您会发现没有任何反应。为 count 变量设置不同的值不会使 Compose 将其检测为状态更改，因此不会产生任何效果。这是因为，当状态发生变化时，您尚未指示 Compose 应重新绘制屏幕（即“重组”可组合函数）。</p>
<h3 id="可组合函数中的记忆功能"><a href="#可组合函数中的记忆功能" class="headerlink" title="可组合函数中的记忆功能"></a>可组合函数中的记忆功能</h3><p>Compose 应用通过调用可组合函数将<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">数据转换</a>为界面。<strong>组合</strong>是指 Compose 在执行可组合项时构建的界面描述。如果发生状态更改，Compose 会使用新状态重新执行受影响的可组合函数，从而创建更新后的界面。这一过程称为<strong>重组</strong>。Compose 还会查看各个可组合项需要哪些数据，以便仅重组数据发生了变化的组件，而避免重组未受影响的组件。</p>
<ul>
<li><strong>组合</strong>：Jetpack Compose 在执行可组合项时构建的界面描述。</li>
<li><strong>初始组合</strong>：通过首次运行可组合项创建组合。</li>
<li><strong>重组</strong>：在数据发生变化时重新运行可组合项以更新组合。</li>
</ul>
<p>为此，<strong>Compose 需要知道要跟踪的状态</strong>，以便在收到更新时安排重组。</p>
<p><strong>Compose 采用特殊的状态跟踪系统，可以为读取特定状态的任何可组合项安排重组。</strong> 这让Compose 能够实现精细控制，并且仅重组需要更改的可组合函数，而不是重组整个界面。这将通过同时跟踪针对状态的“写入”（即状态变化）和针对状态的“读取”来实现。</p>
<p>使用 Compose 的 <strong><code>State</code></strong> 和 <strong><code>MutableState</code></strong> 类型让 Compose 能够观察到状态。</p>
<p>Compose 会跟踪每个读取状态 <strong>value</strong> 属性的可组合项，并在其 <strong>value</strong> 更改时触发重组。您可以使用 <strong>mutableStateOf</strong> 函数来创建可观察的 <strong>MutableState</strong>。它接受初始值作为封装在 <strong>State</strong> 对象中的参数，这样便可使其 <strong>value</strong> 变为可观察。</p>
<p>现在修改代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.MutableState</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.mutableStateOf</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">      <span class="comment">// Changes to count are now tracked by Compose</span></span><br><span class="line">       <span class="keyword">val</span> count: MutableState&lt;<span class="built_in">Int</span>&gt; = mutableStateOf(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">       Text(<span class="string">&quot;You&#x27;ve had <span class="subst">$&#123;count.value&#125;</span> glasses.&quot;</span>)</span><br><span class="line">        Button(onClick = &#123; count.value++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">           Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述，对 count 所做的任何更改都会安排对自动重组读取 count 的 value 的所有可组合函数进行重组。在此情况下，点击按钮即会触发重组 WaterCounter。</p>
<p>如果现在运行应用，您会再次发现没有发生任何变化！</p>
<p>安排重组的过程没有问题。不过，当重组发生时，变量 count 会重新初始化为 0，因此我们需要通过某种方式在重组后保留此值。</p>
<p>为此，我们可以使用 <strong>remember</strong> 可组合内嵌函数。系统会在初始组合期间将由 <strong>remember</strong> 计算的值存储在组合中，并在重组期间一直保持存储的值。</p>
<p>现在继续修改代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.remember</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">val</span> count: MutableState&lt;<span class="built_in">Int</span>&gt; = remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">        Text(<span class="string">&quot;You&#x27;ve had <span class="subst">$&#123;count.value&#125;</span> glasses.&quot;</span>)</span><br><span class="line">        Button(onClick = &#123; count.value++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">            Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remember 和 mutableStateOf 通常在可组合函数中一起使用。您可以将 remember 视为一种在组合中存储单个对象的机制，就像私有 val 属性在对象中执行的操作一样。</p>
<p>这里还可以使用 Kotlin 的委托属性来简化 count 的使用，通过关键字 by 将 count 定义为 var。通过添加委托的 getter 和 setter 导入内容，我们可以间接读取 count 并将其设置为可变，而无需每次都显式引用 MutableState 的 value 属性。</p>
<p>修改代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.getValue</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.setValue</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">       <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">       Text(<span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>)</span><br><span class="line">       Button(onClick = &#123; count++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">           Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行应用，您的计数器已就绪且可正常运行！</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fb3421e91e1f1756d0b8109728d250cf.gif"></p>
<p>这种安排可与用户形成数据流反馈循环：</p>
<ul>
<li>界面向用户显示状态（当前计数显示为文本）。</li>
<li>用户生成的事件会与现有状态合并以生成新状态（点击按钮会为当前计数加一）</li>
</ul>
<h3 id="状态驱动型界面"><a href="#状态驱动型界面" class="headerlink" title="状态驱动型界面"></a>状态驱动型界面</h3><p>Compose 是一个声明性界面框架。它描述界面在特定状况下的状态，而不是在状态发生变化时移除界面组件或更改其可见性。调用重组并更新界面后，可组合项最终可能会进入或退出组合。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/079fb20ac62eda6673a728dcbf0da09f.png"></p>
<p>此方法可避免像针对视图系统那样手动更新视图的复杂性。这也不太容易出错，因为您不会忘记根据新状态更新视图，因为系统会自动执行此过程。</p>
<p>如果在初始组合期间或重组期间调用了可组合函数，则认为其<strong>存在</strong>于组合中。未调用的可组合函数（例如，由于该函数在 <strong>if</strong> 语句内调用且未满足条件）<strong>不存在</strong>于组合中。</p>
<blockquote>
<p>关键提示：如果界面是相对用户而言的，那么界面状态就是相对应用而言的。这就像同一枚硬币的两面，界面是界面状态的直观呈现。对界面状态所做的任何更改都会立即反映在界面中。</p>
</blockquote>
<p>组合的输出是描述界面的树结构。</p>
<p>Android Studio 的布局检查器工具可用于检查 Compose 生成的应用布局。我们接下来将执行此操作。</p>
<p>为了演示此过程，请修改代码，以根据状态显示界面。打开 WaterCounter，如果 count 大于 0，则显示 Text：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">       <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// This text is present if the button has been clicked</span></span><br><span class="line">           <span class="comment">// at least once; absent otherwise</span></span><br><span class="line">           Text(<span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       Button(onClick = &#123; count++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">           Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行应用，然后依次选择 Tools &gt; Layout Inspector，打开 Android Studio 的布局检查器工具。</p>
<blockquote>
<p>提醒：如需在检查器中查看 Compose 节点，请使用 API 大于或等于 29 的设备</p>
</blockquote>
<p>您会看到一个分屏：左侧是组件树，右侧是应用预览。</p>
<p>点按屏幕左侧的根元素 BasicStateCodelabTheme 可浏览树。点击 Expand all 按钮，展开整个组件树。</p>
<p>点击屏幕右侧的某个元素即可访问树的相应元素。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a729c025d4ac742c82358e29b415071f.png" alt="在这里插入图片描述"><br>此时如果点击应用上的 Add one 按钮：</p>
<ul>
<li>计数增加到 1 且状态发生变化。</li>
<li>系统调用重组。</li>
<li>屏幕使用新元素重组。</li>
</ul>
<p>现在，再次使用 Android Studio 的布局检查器工具检查组件树，您还会看到 Text 可组合项：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/36ec2d0fca01c5750dcbdf5d4f2227b4.png" alt="在这里插入图片描述"><br><strong>状态驱动界面在给定时刻显示哪些元素。</strong></p>
<p>界面的不同部分可以依赖于相同的状态。修改 Button，使其在 count 达到 10 之前处于启用状态，并在达到 10 之后停用（即您达到当天的目标）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        Button(onClick = &#123; count++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp), enabled = count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行应用。对 count 状态的更改决定是否显示 Text，以及是启用还是停用 Button。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0b96e01efbc463d77a9017ecb26cdb2d.gif"></p>
<h3 id="组合中的记忆功能"><a href="#组合中的记忆功能" class="headerlink" title="组合中的记忆功能"></a>组合中的记忆功能</h3><p><strong><code>remember</code></strong> 会将对象存储在组合中，而如果在重组期间未再次调用之前调用 <strong><code>remember</code></strong> 的来源位置，则会忘记对象。</p>
<p>为了直观呈现这种行为，我们将在应用中实现以下功能：当用户至少饮用了一杯水时，向用户显示有一项待执行的健康任务，同时用户也可以关闭此任务。由于可组合项应较小并可重复使用，因此请创建一个名为 <strong>WellnessTaskItem</strong> 的新可组合项，该可组合项根据以参数形式接收的字符串来显示健康任务，并显示一个 Close 图标按钮。</p>
<p>创建一个新文件 WellnessTaskItem.kt，并添加以下代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.Row</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.Icon</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.IconButton</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.Text</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.icons.Icons</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.icons.filled.Close</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Alignment</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.unit.dp</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.padding</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTaskItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    taskName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onClose: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Row(</span><br><span class="line">        modifier = modifier, verticalAlignment = Alignment.CenterVertically</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>).padding(start = <span class="number">16.</span>dp),</span><br><span class="line">            text = taskName</span><br><span class="line">        )</span><br><span class="line">        IconButton(onClick = onClose) &#123;</span><br><span class="line">            Icon(Icons.Filled.Close, contentDescription = <span class="string">&quot;Close&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WellnessTaskItem 函数会接收任务说明和 onClose lambda 函数（就像内置 Button 可组合项接收 onClick 一样）。</p>
<p>WellnessTaskItem 如下所示：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e92b4590b885336ce03330ce5e4e7d71.png" alt="在这里插入图片描述"><br>接下来为应用添加更多功能，请更新 WaterCounter，以在 count &gt; 0 时显示 WellnessTaskItem。</p>
<p>当 count 大于 0 时，定义一个变量 showTask，用于确定是否显示 WellnessTaskItem 并将其初始化为 true。</p>
<p>添加新的 if 语句，以在 showTask 为 true 时显示 WellnessTaskItem。使用前面介绍的 remember 来确保 showTask 值在重组后继续有效。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">   Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">       <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> showTask <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">true</span>) &#125;</span><br><span class="line">           <span class="keyword">if</span> (showTask) &#123;</span><br><span class="line">               WellnessTaskItem(</span><br><span class="line">                   onClose = &#123; &#125;,</span><br><span class="line">                   taskName = <span class="string">&quot;Have you taken your 15 minute walk today?&quot;</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br><span class="line">           Text(<span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Button(onClick = &#123; count++ &#125;, enabled = count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">           Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 WellnessTaskItem 的 onClose lambda 函数实现：在按下 X 按钮时，变量 showTask 更改为 false，且不再显示任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">WellnessTaskItem(</span><br><span class="line">   onClose = &#123; showTask = <span class="literal">false</span> &#125;,</span><br><span class="line">   taskName = <span class="string">&quot;Have you taken your 15 minute walk today?&quot;</span></span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来，添加一个带“Clear water count”文本的新 Button，并将其放置在“Add one”Button 旁边。按下“Clear water count”按钮后，变量 count 会重置为 0。</p>
<p>WaterCounter 可组合函数应如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.Row</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">       <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> showTask <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">true</span>) &#125;</span><br><span class="line">           <span class="keyword">if</span> (showTask) &#123;</span><br><span class="line">               WellnessTaskItem(</span><br><span class="line">                   onClose = &#123; showTask = <span class="literal">false</span> &#125;,</span><br><span class="line">                   taskName = <span class="string">&quot;Have you taken your 15 minute walk today?&quot;</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br><span class="line">           Text(<span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Row(Modifier.padding(top = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">           Button(onClick = &#123; count++ &#125;, enabled = count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">               Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">           Button(onClick = &#123; count = <span class="number">0</span> &#125;, Modifier.padding(start = <span class="number">8.</span>dp)) &#123;</span><br><span class="line">               Text(<span class="string">&quot;Clear water count&quot;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行应用时，屏幕会显示初始状态：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/245f3a20839a0f61995775e0dbc56c49.png" alt="在这里插入图片描述"><br>右侧是简化版组件树，可帮助您分析状态发生变化时会发生什么情况。count 和 showTask 是记住的值。</p>
<p>现在，您可以在应用中按以下步骤操作：</p>
<p>按下 Add one 按钮。此操作会递增 count（这会导致重组），并同时显示 WellnessTaskItem 和计数器 Text。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/611bbd87a2d4682c2c3a3eb11a244603.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8ae9aa69db710b549823cd53001321ff.png"><br>此时点击 WellnessTaskItem 组件的 X（这会导致另一项重组）。showTask 现在为 false，这意味着不再显示 WellnessTaskItem。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b543bfa5677fe92df50808b518865f05.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e16888f3d5eda2d74190c27df7403d9a.png"></p>
<p>此时点击 Add one 按钮（另一项重组）。如果您继续增加杯数，showTask 会记住您在下一次重组时关闭了 WellnessTaskItem。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fd1a535fd45ac6fcd4504f1d9d6c04d1.png" alt="在这里插入图片描述"><br>此时点击 Clear water count 按钮可将 count 重置为 0 并导致重组。系统不会调用显示 count 的 Text 以及与 WellnessTaskItem 相关的所有代码，并且会退出组合。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/67141338235490310305c17de076f9eb.png" alt="在这里插入图片描述"><br>由于系统未调用之前调用 showTask 的代码位置，因此会忘记 showTask。这将返回第一步。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a0ba58d85b65e9d6e42f7cfd71bcd4b3.png" alt="在这里插入图片描述"><br>此时点击 Add one 按钮，使 count 大于 0（重组）。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a30dd06f6a2a035ec64f700da9144d5f.png"></p>
<p>系统再次显示 WellnessTaskItem 可组合项，因为在退出上述组合时，之前的 showTask 值已被忘记。</p>
<p>如果我们要求 showTask 在 count 重置为 0 之后持续保留超过 remember 允许的时间（也就是说，即使重组期间未调用之前调用 remember 的代码位置），会发生什么？在接下来的部分中，我们将探讨如何修正这些问题以及更多示例。</p>
<p>现在，您已经了解了界面和状态在退出组合后的重置过程，请清除代码并返回到本部分开头的 WaterCounter：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">    Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Text(<span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Button(onClick = &#123; count++ &#125;, Modifier.padding(top = <span class="number">8.</span>dp), enabled = count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-Compose-中恢复状态"><a href="#在-Compose-中恢复状态" class="headerlink" title="在 Compose 中恢复状态"></a>在 Compose 中恢复状态</h3><p>运行应用，为计数器增加一些饮水杯数，然后旋转设备。请确保已为设备启用自动屏幕旋转设置。</p>
<p>由于系统会在配置更改后（在本例中，即改变屏幕方向）重新创建 activity，因此已保存状态会被忘记：计数器会在重置为 0 后消失。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/25b2afda6a7046ea060118bcae686ef4.gif" alt="在这里插入图片描述"><br>如果您更改语言、在深色模式与浅色模式之间切换，或者执行任何导致 Android 重新创建运行中 activity 的其他配置更改时，也会发生相同的情况。</p>
<p>虽然 <strong>remember</strong> 可帮助您在重组后保持状态，但不会帮助您在配置更改后保持状态。为此，您必须使用 <strong><code>rememberSaveable</code></strong>，而不是 <strong>remember</strong>。</p>
<p><strong><code>rememberSaveable</code></strong> 会自动保存可保存在 <strong>Bundle</strong> 中的任何值。对于其他值，您可以将其传入自定义 <strong>Saver</strong> 对象。（如需了解详细请参考<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/state#restore-ui-state">如何在 Compose 中恢复状态</a>文档。）</p>
<p>在 WaterCounter 中，将 <strong>remember</strong> 替换为 <strong>rememberSaveable</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.saveable.rememberSaveable</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WaterCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行应用并尝试进行一些配置更改。您应该会看到计数器已正确保存。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2270f5bcd85f0f781617ccf51135a45f.gif" alt="在这里插入图片描述"><br>重新创建 activity 只是 rememberSaveable 的用例之一。我们稍后会在使用列表时探索另一个用例。</p>
<blockquote>
<p>在重新创建 activity 或进程后，您可以使用 <strong>rememberSaveable</strong> 恢复界面状态。除了在重组后保持状态之外，<strong>rememberSaveable</strong> 还会在重新创建 activity 和进程之后保留状态。</p>
</blockquote>
<p>请根据应用的状态和用户体验需求来考虑是使用 remember 还是 rememberSaveable。</p>
<h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>使用 <strong>remember</strong> 存储对象的可组合项包含内部状态，这会使该可组合项<strong>有状态</strong>。在调用方不需要控制状态，并且不必自行管理状态便可使用状态的情况下，“有状态”会非常有用。但是，<strong>具有内部状态的可组合项往往不易重复使用，也更难测试。</strong></p>
<p><strong>不保存任何状态的可组合项称为无状态可组合项</strong>。如需创建<strong>无状态</strong>可组合项，一种简单的方法是使用<strong>状态提升</strong>。</p>
<p>Compose 中的状态提升是一种<strong>将状态移至可组合项的调用方</strong>以使可组合项无状态的模式。Jetpack Compose 中的常规状态提升模式是将状态变量替换为两个参数：</p>
<ul>
<li><strong>value: T</strong>：要显示的当前值</li>
<li><strong>onValueChange: (T) -&gt; Unit</strong>：请求更改值的事件，其中 T 是建议的新值</li>
</ul>
<p>其中，value值表示任何可修改的状态。</p>
<blockquote>
<p>状态下降、事件上升的这种模式称为单向数据流 (Unidirectional Data Flow, UDF)，而状态提升就是我们在 Compose 中实现此架构的方式。如需了解相关详情，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/architecture#udf-compose">Compose 架构文档</a>。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4b4547c4afe7426204e3b6c705c09035.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>以这种方式提升的状态具有一些重要的属性：</p>
<ul>
<li><strong>单一可信来源</strong>：通过移动状态，而不是复制状态，我们可确保只有一个可信来源。这有助于避免 bug。</li>
<li><strong>可共享</strong>：可与多个可组合项共享提升的状态。</li>
<li><strong>可拦截</strong>：无状态可组合项的调用方可以在更改状态之前决定忽略或修改事件。</li>
<li><strong>解耦</strong>：无状态可组合函数的状态可以存储在任何位置。例如，存储在 ViewModel 中。</li>
<li><strong>封装</strong>：只有有状态可组合项能够修改其状态。这完全是内部的。</li>
</ul>
<p>请尝试为 WaterCounter 实现状态提升，以便从以上所有方法中受益。</p>
<h4 id="有状态与无状态"><a href="#有状态与无状态" class="headerlink" title="有状态与无状态"></a>有状态与无状态</h4><p>当所有状态都可以从可组合函数中提取出来时，生成的可组合函数称为无状态函数。</p>
<blockquote>
<p><strong>无状态可组合项</strong>是指不具有任何状态的可组合项，这意味着它不会存储、定义或修改新状态。<br><strong>有状态可组合项</strong>是一种具有可以随时间变化的状态的可组合项。<br>在实际应用中，让可组合项 100% 完全无状态可能很难实现，具体取决于可组合项的职责。在设计可组合项时，您应该让可组合项拥有尽可能少的状态，并能够在必要时通过在可组合项的 API 中公开状态来提升状态。</p>
</blockquote>
<p>重构 WaterCounter 可组合项，将其拆分为两部分：有状态和无状态计数器。</p>
<p>StatelessCounter 的作用是显示 count，并在您递增 count 时调用函数。为此，请遵循上述模式并传递状态 count（作为可组合函数的参数）和 lambda (onIncrement)（在需要递增状态时会调用此函数）。StatelessCounter 如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatelessCounter</span><span class="params">(count: <span class="type">Int</span>, onIncrement: () -&gt; <span class="type">Unit</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           Text(<span class="string">&quot;You&#x27;ve had <span class="variable">$count</span> glasses.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       Button(onClick = onIncrement, Modifier.padding(top = <span class="number">8.</span>dp), enabled = count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">           Text(<span class="string">&quot;Add one&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StatefulCounter 拥有状态。这意味着，它会存储 count 状态，并在调用 StatelessCounter 函数时对其进行修改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatefulCounter</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">   StatelessCounter(count, &#123; count++ &#125;, modifier)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太棒了！您已将 count 从 StatelessCounter 提升到 StatefulCounter。</p>
<p>您可以将其插入到应用中，并使用 StatefulCounter 更新 WellnessScreen：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessScreen</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   StatefulCounter(modifier)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：提升状态时，有三条规则可帮助您弄清楚状态应去向何处：</p>
<ol>
<li>状态应至少提升到使用该状态（读取）的所有可组合项的<strong>最低共同父项</strong>。</li>
<li>状态应至少提升到<strong>它可以发生变化（写入）的最高级别</strong>。</li>
<li><strong>如果两种状态发生变化以响应相同的事件，它们应提升到同一级别</strong>。</li>
</ol>
<p>您可以将状态提升到高于这些规则要求的级别，但如果未将状态提升到足够高的级别，则遵循单向数据流会变得困难或不可能。</p>
<p>如前所述，状态提升具有一些好处。我们将探索此代码的不同变体并详细介绍其中一些变体，您无需在应用中复制以下代码段。</p>
<p>1.您的无状态可组合项现在已可重复使用。请看以下示例。<br>如需记录饮用水和果汁的杯数，请记住 waterCount 和 juiceCount，但请使用示例 StatelessCounter 可组合函数来显示两种不同的独立状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatefulCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> waterCount <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> juiceCount <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    StatelessCounter(waterCount, &#123; waterCount++ &#125;)</span><br><span class="line">    StatelessCounter(juiceCount, &#123; juiceCount++ &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4e50498f3456ee4b147540550bf6a817.png"></p>
<p>如果修改了 juiceCount，则重组 StatefulCounter。在重组期间，Compose 会识别哪些函数读取 juiceCount，并触发系统仅重组这些函数。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/be4ff4908d785ec5a8f950e6cf6029d1.png"></p>
<p>当用户点按以递增 juiceCount 时，系统会重组 StatefulCounter，同时也会重组 juiceCount 的 StatelessCounter。但不会重组读取 waterCount 的 StatelessCounter。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f937471bb4782164d529d8c4f59f5053.png"></p>
<p>2.有状态可组合函数可以为多个可组合函数提供相同的状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StatefulCounter</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">   StatelessCounter(count, &#123; count++ &#125;)</span><br><span class="line">   AnotherStatelessMethod(count, &#123; count *= <span class="number">2</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中，如果通过 StatelessCounter 或 AnotherStatelessMethod 更新计数，则系统会按预期重组所有项目。</p>
<p>由于可以共享提升的状态，因此<strong>请务必仅传递可组合项所需的状态</strong>，以避免不必要的重组并提高可重用性。</p>
<blockquote>
<p><strong>要点：设计可组合项的最佳实践是仅向它们传递所需要的参数。</strong><br>如需详细了解状态和状态提升，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/state#state-hoisting">Compose 状态文档</a> 。</p>
</blockquote>
<h3 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h3><p>接下来，添加应用的第二项功能，即健康任务列表。您可以对列表中的项执行以下两项操作：</p>
<ul>
<li>勾选列表项，将任务标记为已完成。</li>
<li>从任务列表中移除不想完成的任务。</li>
</ul>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>1.首先，修改列表项。您可以重复使用“组合中的记忆功能”部分中的 WellnessTaskItem，并将其更新为包含 <strong>Checkbox</strong>。请务必提升 <strong>checked</strong> 状态和 <strong>onCheckedChange</strong> 回调，使函数变为无状态。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/56a3815261e399a7f68edd7bd7b152a4.png" alt="在这里插入图片描述"><br>本部分的 WellnessTaskItem 可组合项应如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.material.Checkbox</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTaskItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    taskName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    checked: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onCheckedChange: (<span class="type">Boolean</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onClose: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Row(</span><br><span class="line">        modifier = modifier, verticalAlignment = Alignment.CenterVertically</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier.weight(<span class="number">1f</span>).padding(start = <span class="number">16.</span>dp),</span><br><span class="line">            text = taskName</span><br><span class="line">        )</span><br><span class="line">        Checkbox(</span><br><span class="line">            checked = checked,</span><br><span class="line">            onCheckedChange = onCheckedChange</span><br><span class="line">        )</span><br><span class="line">        IconButton(onClick = onClose) &#123;</span><br><span class="line">            Icon(Icons.Filled.Close, contentDescription = <span class="string">&quot;Close&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在同一文件中，添加一个有状态 WellnessTaskItem 可组合函数，用于定义状态变量 checkedState 并将其传递给同名的无状态方法。暂时不用担心 onClose，您可以传递空的 lambda 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.getValue</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.setValue</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.mutableStateOf</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.remember</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTaskItem</span><span class="params">(taskName: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> checkedState <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line"></span><br><span class="line">   WellnessTaskItem(</span><br><span class="line">       taskName = taskName,</span><br><span class="line">       checked = checkedState,</span><br><span class="line">       onCheckedChange = &#123; newValue -&gt; checkedState = newValue &#125;,</span><br><span class="line">       onClose = &#123;&#125;, <span class="comment">// we will implement this later!</span></span><br><span class="line">       modifier = modifier,</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.创建一个文件 WellnessTask.kt，对包含 ID 和标签的任务进行建模。将其定义为数据类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">WellnessTask</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> label: String)</span><br></pre></td></tr></table></figure>

<p>4.对于任务列表本身，请创建一个名为 WellnessTasksList.kt 的新文件，并添加一个方法用于生成一些虚假数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWellnessTasks</span><span class="params">()</span></span> = List(<span class="number">30</span>) &#123; i -&gt; WellnessTask(i, <span class="string">&quot;Task # <span class="variable">$i</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在真实应用中，您将从数据层获取数据。</p>
<p>5.在 WellnessTasksList.kt 中，添加一个用于创建列表的可组合函数。定义 <strong>LazyColumn</strong> 以及您所创建的列表方法中的列表项。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.foundation.lazy.LazyColumn</span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.lazy.items</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"><span class="keyword">import</span> androidx.compose.ui.Modifier</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.remember</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTasksList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    list: <span class="type">List</span>&lt;<span class="type">WellnessTask</span>&gt; = remember &#123; getWellnessTasks()</span></span> &#125;</span><br><span class="line">) &#123;</span><br><span class="line">    LazyColumn(modifier = modifier) &#123;</span><br><span class="line">        items(list) &#123; task -&gt;</span><br><span class="line">            WellnessTaskItem(taskName = task.label)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.将列表添加到 WellnessScreen。使用 Column 有助于列表与已有的计数器垂直对齐。</p>
<blockquote>
<p>注意：如果在 Android Studio 的编辑器区域键入 WC，系统会打开一个建议框。如果您按下 Enter 并选择第一个选项，系统会显示可供使用的 Column 模板。<br>如需详细了解 Android Studio 中适用于 Compose 的实时模板和其他实用工具，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/tooling#editor-actions">Compose 工具文档</a> 。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.foundation.layout.Column</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessScreen</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier) &#123;</span><br><span class="line">       StatefulCounter()</span><br><span class="line">       WellnessTasksList()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.运行应用并试一下效果！现在，您应该能够勾选任务，但不能删除任务。我们将在稍后的部分中实现此功能。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7a307b1822a568832967e50b0d22467a.gif"></p>
<h4 id="在-LazyList-中恢复项状态"><a href="#在-LazyList-中恢复项状态" class="headerlink" title="在 LazyList 中恢复项状态"></a>在 LazyList 中恢复项状态</h4><p>现在，我们来详细了解一下 <strong>WellnessTaskItem</strong> 可组合项中的一些内容。</p>
<p><strong>checkedState</strong> 属于每个 <strong>WellnessTaskItem</strong> 可组合项，就像私有变量一样。当 <strong>checkedState</strong> 发生变化时，系统只会重组 <strong>WellnessTaskItem</strong> 的实例，而不是重组 <strong>LazyColumn</strong> 中的所有 <strong>WellnessTaskItem</strong> 实例。</p>
<p>请按以下步骤尝试应用的功能：</p>
<ol>
<li>勾选此列表顶部的所有元素（例如元素 1 和元素 2）。</li>
<li>滚动到列表底部，使这些元素位于屏幕之外。</li>
<li>滚动到顶部，查看之前勾选的列表项。</li>
<li>请注意，它们处于未选中状态。</li>
</ol>
<p>正如您在上一部分中看到的那样，其问题在于，当一个项退出组合时，系统会忘记之前记住的状态。对于 LazyColumn 上的项，当您滚动至项不可见的位置时，这些不可见的项会完全退出组合。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/eacfafe77a586b5c142d94044ed1171b.gif"></p>
<p>如何解决此问题？再次使用 <strong>rememberSaveable</strong>，因为它采用保存的实例状态机制，可确保存储的值在重新创建 activity 或进程（在本例中，即项退出组合）之后继续保留。</p>
<p>只需在有状态 <strong>WellnessTaskItem</strong> 中将 <strong>remember</strong> 替换为 <strong>rememberSaveable</strong> 即可，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.saveable.rememberSaveable</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> checkedState <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a1b83652adb325f3ad573573dfd39b43.gif"></p>
<h4 id="Compose-中的常见模式"><a href="#Compose-中的常见模式" class="headerlink" title="Compose 中的常见模式"></a>Compose 中的常见模式</h4><p>请注意 <strong>LazyColumn</strong> 的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LazyColumn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">...</span></span></span><br><span class="line"><span class="params"><span class="function">    state: <span class="type">LazyListState</span> = rememberLazyListState()</span></span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可组合函数 <strong>rememberLazyListState</strong> 使用 <strong>rememberSaveable</strong> 为列表创建初始状态。<strong>重新创建 activity 后，无需任何编码即可保持滚动状态</strong>。</p>
<p>许多应用需要对滚动位置、列表项布局更改以及其他与列表状态相关的事件作出响应，并进行监听。延迟组件（例如 <strong>LazyColumn</strong> 或 <strong>LazyRow</strong>）可通过提升 <strong>LazyListState</strong> 来支持此用例。如需详细了解此模式，请参阅<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/lists#react-to-scroll-position">介绍列表中的状态的文档</a>。</p>
<p>状态参数使用由公共 <strong>rememberX</strong> 函数提供的默认值是内置可组合函数中的常见模式。另一个示例可以在 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#scaffold"><strong>Scaffold</strong></a> 中找到，它使用 <strong>rememberScaffoldState</strong> 提升状态。</p>
<h3 id="可观察的可变列表"><a href="#可观察的可变列表" class="headerlink" title="可观察的可变列表"></a>可观察的可变列表</h3><p>接下来，如需添加从列表中移除任务的行为，第一步是让列表成为可变列表。</p>
<p>使用可变对象（例如 <strong>ArrayList</strong> 或 <strong>mutableListOf</strong>,）对此不起作用。这些类型不会向 Compose 通知列表中的项已发生更改并安排界面重组。您需要使用使用其他 API。</p>
<p>您需要创建一个可由 Compose 观察的 <strong>MutableList</strong> 实例。此结构可允许 Compose 跟踪更改，以便在列表中添加或移除项时重组界面。</p>
<p>首先，定义可观察的 <strong>MutableList</strong>。扩展函数 <strong>toMutableStateList()</strong> 用于根据初始可变或不可变的 <strong>Collection</strong>（例如 <strong>List</strong>）来创建可观察的 <strong>MutableList</strong>。</p>
<p>或者，您也可以使用工厂方法 <strong>mutableStateListOf</strong> 来创建可观察的 <strong>MutableList</strong>，然后为初始状态添加元素。</p>
<blockquote>
<p><strong>mutableStateOf</strong> 函数会返回一个类型为 <strong><code>MutableState&lt;T&gt;</code></strong> 的对象。<br><strong>mutableStateListOf</strong> 和 <strong>toMutableStateList</strong> 函数会返回一个类型为 <strong><code>SnapshotStateList&lt;T&gt;</code></strong> 的对象。在本部分中，“可观察的 MutableList”一词表示此类。</p>
</blockquote>
<p>打开 WellnessScreen.kt 文件。将 getWellnessTasks 方法移至此文件中以便使用该方法。如需创建列表，请先调用 getWellnessTasks()，然后使用之前介绍的扩展函数 toMutableStateList。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.remember</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.toMutableStateList</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessScreen</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">   Column(modifier = modifier) &#123;</span><br><span class="line">       StatefulCounter()</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> list = remember &#123; getWellnessTasks().toMutableStateList() &#125;</span><br><span class="line">       WellnessTasksList(list = list, onCloseTask = &#123; task -&gt; list.remove(task) &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWellnessTasks</span><span class="params">()</span></span> = List(<span class="number">30</span>) &#123; i -&gt; WellnessTask(i, <span class="string">&quot;Task # <span class="variable">$i</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>警告：您可以改用 mutableStateListOf API 来创建列表。但是，如果使用方法不当，则可能会导致意外重组和界面性能欠佳。</p>
<p>如果您仅定义列表，然后在不同的操作中添加任务，则会导致系统在每次重组时都添加重复项。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t do this!</span></span><br><span class="line"><span class="keyword">val</span> list = remember &#123; mutableStateListOf&lt;WellnessTask&gt;() &#125;</span><br><span class="line">list.addAll(getWellnessTasks())</span><br></pre></td></tr></table></figure>

<p>而是应当在单一操作中创建包含初始值的列表，然后将其传递给 remember 函数，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do this instead. Don&#x27;t need to copy</span></span><br><span class="line"><span class="keyword">val</span> list = remember &#123;</span><br><span class="line">	mutableStateListOf&lt;WellnessTask&gt;().apply &#123; addAll(getWellnessTasks()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.通过移除列表的默认值来修改 <strong>WellnessTaskList</strong> 可组合函数，因为列表会提升到屏幕级别。添加一个新的 lambda 函数参数 <strong>onCloseTask</strong>（用于接收 <strong>WellnessTask</strong> 以进行删除）。将 <strong>onCloseTask</strong> 传递给 <strong>WellnessTaskItem</strong>。</p>
<p>您还需要再进行一项更改。<strong>items</strong> 方法会接收一个 <strong>key</strong> 参数。默认情况下，每个项的状态均与该项在列表中的位置相对应。</p>
<p>在可变列表中，当数据集发生变化时，这会导致问题，因为实际改变位置的项会丢失任何记住的状态。</p>
<p>使用每个 <strong>WellnessTaskItem</strong> 的 <strong>id</strong> 作为每个项的键，即可轻松解决此问题。(如需了解详细请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/lists">列表文档</a> 。)</p>
<p>WellnessTaskList 将如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTasksList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   list: <span class="type">List</span>&lt;<span class="type">WellnessTask</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">   onCloseTask: (<span class="type">WellnessTask</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">   LazyColumn(modifier = modifier) &#123;</span><br><span class="line">       items(</span><br><span class="line">           items = list,</span><br><span class="line">           key = &#123; task -&gt; task.id &#125;</span><br><span class="line">       ) &#123; task -&gt;</span><br><span class="line">           WellnessTaskItem(taskName = task.label, onClose = &#123; onCloseTask(task) &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.修改 WellnessTaskItem：将 <strong>onClose</strong> lambda 函数作为参数添加到有状态 WellnessTaskItem 中并进行调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTaskItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   taskName: <span class="type">String</span>, onClose: () -&gt; <span class="type">Unit</span>, modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> checkedState <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line"></span><br><span class="line">   WellnessTaskItem(</span><br><span class="line">       taskName = taskName,</span><br><span class="line">       checked = checkedState,</span><br><span class="line">       onCheckedChange = &#123; newValue -&gt; checkedState = newValue &#125;,</span><br><span class="line">       onClose = onClose,</span><br><span class="line">       modifier = modifier,</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太棒了！此功能已经完成，现在已经可以从列表中删除项。</p>
<p>如果您点击每行中的 X，则事件会一直到达拥有状态的列表，从列表中移除相应项，并导致 Compose 重组界面。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0925f9943f601f07c517cb9f7234b8e9.png"></p>
<p>如果您尝试使用 <strong>rememberSaveable()</strong> 将列表存储在 WellnessScreen 中，则会发生运行时异常：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3e29d6a514fda1eb91dcf2aba0d04c5a.png" alt="在这里插入图片描述"><br>此错误消息指出，您需要提供<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/state#restore-ui-state">自定义 Saver</a>。但是，您不应使用 <strong>rememberSaveable</strong> 来存储需要长时间序列化或反序列化操作的大量数据或复杂数据结构。</p>
<blockquote>
<p>使用 <strong>activity</strong> 的 <strong>onSaveInstanceState</strong> 时，应遵循类似的规则；如需了解详情，请参阅<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/saving-states#onsaveinstancestate">保存界面状态文档</a>。如果要执行此操作，您需要替代存储机制。如需详细了解其他<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/saving-states#options">保留界面状态的选项</a>，请参阅相关文档。</p>
</blockquote>
<p>接下来，我们来看看 ViewModel 在存储应用状态方面的作用。</p>
<h3 id="ViewModel-中的状态"><a href="#ViewModel-中的状态" class="headerlink" title="ViewModel 中的状态"></a>ViewModel 中的状态</h3><p>屏幕或界面状态指示应在屏幕上显示的内容（例如任务列表）。<strong>该状态通常会与层次结构中的其他层相关联，原因是其包含应用数据。</strong></p>
<p>界面状态描述屏幕上显示的内容，而应用逻辑则描述应用的行为方式以及应如何响应状态变化。逻辑分为两种类型：<strong>第一种是界面行为或界面逻辑，第二种是业务逻辑。</strong></p>
<ul>
<li><strong>界面逻辑涉及如何在屏幕上显示状态变化</strong>（例如导航逻辑或显示信息提示控件）。</li>
<li><strong>业务逻辑决定如何处理状态更改</strong>（例如付款或存储用户偏好设置）。<strong>该逻辑通常位于业务层或数据层，但绝不会位于界面层</strong>。</li>
</ul>
<p>ViewModel 提供界面状态以及对位于应用其他层中的业务逻辑的访问。此外，ViewModel 还会在配置更改后继续保留，因此<strong>其生命周期比组合更长</strong>。ViewModel 可以遵循 Compose 内容（即 activity 或 fragment）的主机的生命周期，也可以遵循导航图的目的地的生命周期（如果您使用的是 Compose Navigation 库）。</p>
<blockquote>
<p>如需详细了解架构和界面层，请参阅<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/guide/ui-layer#define-ui-state">界面层文档</a>。</p>
</blockquote>
<blockquote>
<p>警告：ViewModel 并不是组合的一部分。因此，您不应保留可组合项中创建的状态（例如，记住的值），因为这可能会导致内存泄漏。</p>
</blockquote>
<h4 id="迁移列表并移除方法"><a href="#迁移列表并移除方法" class="headerlink" title="迁移列表并移除方法"></a>迁移列表并移除方法</h4><p>让我们将界面状态（列表）迁移到 ViewModel，并开始将业务逻辑提取到 ViewModel 中。</p>
<p>1.创建文件 WellnessViewModel.kt 以添加 ViewModel 类。</p>
<p>将“数据源”getWellnessTasks() 移至 WellnessViewModel。</p>
<p>像前面一样使用 toMutableStateList 定义内部私有 _tasks 变量，并将 tasks 作为列表公开，这样将避免从 ViewModel 外部对其进行修改。</p>
<p>实现一个简单的 remove 函数，用于委托给列表的内置 remove 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.toMutableStateList</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WellnessViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _tasks = getWellnessTasks().toMutableStateList()</span><br><span class="line">    <span class="keyword">val</span> tasks: List&lt;WellnessTask&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _tasks</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(item: <span class="type">WellnessTask</span>)</span></span> &#123;</span><br><span class="line">       _tasks.remove(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getWellnessTasks</span><span class="params">()</span></span> = List(<span class="number">30</span>) &#123; i -&gt; WellnessTask(i, <span class="string">&quot;Task # <span class="variable">$i</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>2.我们可以通过调用 <strong>viewModel()</strong> 函数，从任何可组合项访问此 ViewModel。</p>
<p>如需使用此函数，请打开 <strong>app&#x2F;build.gradle</strong> 文件，添加以下库，并在 Android Studio 中同步新的依赖项：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.1&quot;</span></span><br></pre></td></tr></table></figure>

<p>3.打开 <strong>WellnessScreen</strong>。实例化 <strong>wellnessViewModel</strong> <strong>ViewModel</strong>，方法是以 Screen 可组合项的参数的形式调用 <strong>viewModel()</strong>，以便在测试此可组合项时进行替换，并根据需要进行提升。为 <strong>WellnessTasksList</strong> 提供任务列表，并为 <strong>onCloseTask</strong> lambda 提供 <strong>remove</strong> 函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.lifecycle.viewmodel.compose.viewModel</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    wellnessViewModel: <span class="type">WellnessViewModel</span> = viewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">   Column(modifier = modifier) &#123;</span><br><span class="line">       StatefulCounter()</span><br><span class="line"></span><br><span class="line">       WellnessTasksList(</span><br><span class="line">           list = wellnessViewModel.tasks,</span><br><span class="line">           onCloseTask = &#123; task -&gt; wellnessViewModel.remove(task) &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>viewModel()</strong> 会返回一个现有的 <strong>ViewModel</strong>，或在给定作用域内创建一个新的 <strong>ViewModel</strong>。<strong>只要作用域处于活动状态，<strong>ViewModel</strong> 实例就会一直保留</strong>。例如，如果在某个 activity 中使用了可组合项，则在该 activity 完成或进程终止之前， <strong>viewModel()</strong> 会返回同一实例。</p>
<p>大功告成！您已将 ViewModel 与部分状态和业务逻辑集成到了屏幕上。<strong>由于状态保留在组合之外并由 ViewModel 存储，因此对列表的更改在配置更改后继续有效。</strong></p>
<blockquote>
<p>ViewModel 在任何情况下（例如，对于系统发起的进程终止）都不会自动保留应用的状态。如需详细了解如何<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/saving-states">保留应用的界面状态</a>，请参阅相关文档。<br>建议<strong>将 ViewModel 用于屏幕级可组合项，即靠近从导航图的 activity、fragment 或目的地调用的根可组合项</strong>。<strong>绝不应将 ViewModel 传递给其他可组合项，而是应当仅向它们传递所需的数据以及以参数形式执行所需逻辑的函数。</strong><br>如需了解详情，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/state#viewmodels-source-of-truth">ViewModel 和状态容器部分</a> 以及 <a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/libraries#viewmodel">Compose 和其他库</a>的相关文档。<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b73872cf6244f60f71c35d1e5c41c14b.png" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="迁移选中状态"><a href="#迁移选中状态" class="headerlink" title="迁移选中状态"></a>迁移选中状态</h4><p>最后一个重构是将<strong>选中状态</strong>和<strong>逻辑</strong>迁移到 <strong>ViewModel</strong>。这样一来，代码将变得更简单且更易于测试，并且所有状态均由 ViewModel 管理。</p>
<p>1.首先，修改 WellnessTask 模型类，使其能够存储选中状态并将 false 设置为默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">WellnessTask</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> label: String, <span class="keyword">var</span> checked: <span class="built_in">Boolean</span> = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>2.在 ViewModel 中，实现一个 <strong>changeTaskChecked</strong> 方法，该方法将接收使用选中状态的新值进行修改的任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WellnessViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">changeTaskChecked</span><span class="params">(item: <span class="type">WellnessTask</span>, checked: <span class="type">Boolean</span>)</span></span> =</span><br><span class="line">       tasks.find &#123; it.id == item.id &#125;?.let &#123; task -&gt;</span><br><span class="line">           task.checked = checked</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在 WellnessScreen 中，通过调用 ViewModel 的 <strong>changeTaskChecked</strong> 方法为列表的 <strong>onCheckedTask</strong> 提供行为。函数现在应如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="params"><span class="function">    wellnessViewModel: <span class="type">WellnessViewModel</span> = viewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">   Column(modifier = modifier) &#123;</span><br><span class="line">       StatefulCounter()</span><br><span class="line"></span><br><span class="line">       WellnessTasksList(</span><br><span class="line">           list = wellnessViewModel.tasks,</span><br><span class="line">           onCheckedTask = &#123; task, checked -&gt;</span><br><span class="line">               wellnessViewModel.changeTaskChecked(task, checked)</span><br><span class="line">           &#125;,</span><br><span class="line">           onCloseTask = &#123; task -&gt;</span><br><span class="line">               wellnessViewModel.remove(task)</span><br><span class="line">           &#125;</span><br><span class="line">       )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.打开 <strong>WellnessTasksList</strong> 并添加 <strong>onCheckedTask</strong> lambda 函数参数，以便将其传递给 <strong>WellnessTaskItem</strong>.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTasksList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   list: <span class="type">List</span>&lt;<span class="type">WellnessTask</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">   onCheckedTask: (<span class="type">WellnessTask</span>, <span class="type">Boolean</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   onCloseTask: (<span class="type">WellnessTask</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">   LazyColumn(</span><br><span class="line">       modifier = modifier</span><br><span class="line">   ) &#123;</span><br><span class="line">       items(</span><br><span class="line">           items = list,</span><br><span class="line">           key = &#123; task -&gt; task.id &#125;</span><br><span class="line">       ) &#123; task -&gt;</span><br><span class="line">           WellnessTaskItem(</span><br><span class="line">               taskName = task.label,</span><br><span class="line">               checked = task.checked,</span><br><span class="line">               onCheckedChange = &#123; checked -&gt; onCheckedTask(task, checked) &#125;,</span><br><span class="line">               onClose = &#123; onCloseTask(task) &#125;</span><br><span class="line">           )</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.清理 WellnessTaskItem.kt 文件。我们不再需要有状态方法，因为 CheckBox 状态将提升到列表级别。该文件仅包含以下可组合函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WellnessTaskItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   taskName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   checked: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   onCheckedChange: (<span class="type">Boolean</span>) -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   onClose: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">   Row(</span><br><span class="line">       modifier = modifier, verticalAlignment = Alignment.CenterVertically</span><br><span class="line">   ) &#123;</span><br><span class="line">       Text(</span><br><span class="line">           modifier = Modifier.weight(<span class="number">1f</span>).padding(start = <span class="number">16.</span>dp),</span><br><span class="line">           text = taskName</span><br><span class="line">       )</span><br><span class="line">       Checkbox(</span><br><span class="line">           checked = checked,</span><br><span class="line">           onCheckedChange = onCheckedChange</span><br><span class="line">       )</span><br><span class="line">       IconButton(onClick = onClose) &#123;</span><br><span class="line">           Icon(Icons.Filled.Close, contentDescription = <span class="string">&quot;Close&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行应用并尝试勾选任何任务。您会发现无法勾选任何任务。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0b902672742e83794e0c37ca03f667da.gif"></p>
<p>这是因为 Compose 将跟踪 <strong>MutableList</strong> 与<strong>添加和移除</strong>元素相关的更改。这就是删除功能能够正常运行的原因。但是，它对行项的值（在本例中为 <strong>checkedState</strong>）的更改一无所知，除非您指示它跟踪这些值。</p>
<p>解决此问题的方法有两种：</p>
<ul>
<li>更改数据类 <strong>WellnessTask</strong>，使 <strong>checkedState</strong> 变为 <strong><code>MutableState&lt;Boolean&gt;</code></strong>（而非<br>  <strong>Boolean</strong>），这会使 <strong>Compose</strong> 跟踪项更改。</li>
<li><strong>复制您要更改的项，从列表中移除相应项，然后将更改后的项重新添加到列表中</strong>，这会使 <strong>Compose</strong> 跟踪该列表的更改。</li>
</ul>
<p>这两种方法各有利弊。例如，根据您所使用的列表的实现，移除和读取该元素可能会产生非常高的开销。</p>
<p>因此，假设您想要避免可能开销高昂的列表操作，并将 <strong>checkedState</strong> 设为可观察，因为这种方式更高效且更符合 <strong>Compose</strong> 的规范。</p>
<p>您的新 <strong>WellnessTask</strong> 应如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.MutableState</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.mutableStateOf</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">WellnessTask</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> label: String, <span class="keyword">val</span> checked: MutableState&lt;<span class="built_in">Boolean</span>&gt; = mutableStateOf(<span class="literal">false</span>))</span><br></pre></td></tr></table></figure>

<p>如前所述，在本例中，您可以使用委托属性，这样可以更轻松地使用变量 <strong>checked</strong>。</p>
<p>将 <strong>WellnessTask</strong> 更改为类，而不是数据类。让 <strong>WellnessTask</strong> 在构造函数中接收默认值为 <strong>false</strong> 的 <strong>initialChecked</strong> 变量，然后可以使用工厂方法 <strong>mutableStateOf</strong> 来初始化 <strong>checked</strong> 变量并接受 <strong>initialChecked</strong> 作为默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.compose.runtime.getValue</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.mutableStateOf</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.setValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WellnessTask</span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> label: String,</span><br><span class="line">    initialChecked: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> checked <span class="keyword">by</span> mutableStateOf(initialChecked)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成！这种解决方案行之有效，并且所有更改在重组和配置更改后仍然保持有效！<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8c704936704ea1d5cb27696357fce9f6.gif"></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>现在，业务逻辑已重构为 ViewModel，而不是在可组合函数内形成耦合，因此单元测试要简单得多。</p>
<p>您可以使用插桩测试来验证 Compose 代码的正确行为以及界面状态是否正常运行。了解如何测试 Compose 界面请参考<a target="_blank" rel="noopener" href="https://developer.android.com/codelabs/jetpack-compose-testing#0">Compose 中的测试</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84state%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/">https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84state%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84Notification/" title="Compose中的Notification"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose中的Notification</div></div><div class="info-2"><div class="info-item-1">发送通知相关的主要有两个关键的类 NotificationCompat.Builder 和 NotificationManagerCompat为方便使用，首先定义一个扩展工具类来管理通知 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106const val MAIN_CHANNEL_ID = &quot;MainChannel ID&quot;const val MAIN_CHANNEL = &quot;MainChannel&quot;fun Context.buildNotification(    id: Int,    title: String,    message: String,   ...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/" title="Compose中的列表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Compose中的列表</div></div><div class="info-2"><div class="info-item-1">Cloumn 和 Row如果是普通的不是特别长的列表，可以直接使用 Column 和 Row 组件，默认 Column 和 Row 组件是不支持滚动的，如果需要支持滚动可以在 Column 和 Row 组件上使用 Modifier.verticalScroll() 和Modifier.horizontalScroll() 修饰符 1234567891011121314151617181920212223@Composablefun ColumnList(list: List&lt;String&gt;) &#123;    Box &#123;        Column(Modifier.verticalScroll(rememberScrollState())) &#123;            list.forEach &#123;                Text(it)                Divider()            &#125;        &#125;    &#125;&#125;@Composablefun...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose-%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">Compose 中的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">可组合函数中的记忆功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E9%A9%B1%E5%8A%A8%E5%9E%8B%E7%95%8C%E9%9D%A2"><span class="toc-number">3.</span> <span class="toc-text">状态驱动型界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8A%9F%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">组合中的记忆功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Compose-%E4%B8%AD%E6%81%A2%E5%A4%8D%E7%8A%B6%E6%80%81"><span class="toc-number">5.</span> <span class="toc-text">在 Compose 中恢复状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87"><span class="toc-number">6.</span> <span class="toc-text">状态提升</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">6.1.</span> <span class="toc-text">有状态与无状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">使用列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-LazyList-%E4%B8%AD%E6%81%A2%E5%A4%8D%E9%A1%B9%E7%8A%B6%E6%80%81"><span class="toc-number">7.2.</span> <span class="toc-text">在 LazyList 中恢复项状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compose-%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">Compose 中的常见模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E5%8F%AF%E5%8F%98%E5%88%97%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">可观察的可变列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewModel-%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">ViewModel 中的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E5%88%97%E8%A1%A8%E5%B9%B6%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">迁移列表并移除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81"><span class="toc-number">9.2.</span> <span class="toc-text">迁移选中状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">9.3.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>