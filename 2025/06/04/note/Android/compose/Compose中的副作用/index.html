<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose中的副作用 | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是副作用从本质上讲，副作用是任何超出函数控制和作用域的东西。副作用会使函数变得不确定，因此它们使开发人员难以推理代码。 想象有一个函数，它被期望对两个数相加：  对于相同的输入值，其结果永远不会变化，也就是说，不会因为运行次数的增加导致输出结果的不同，因为该函数所做的唯一一件事就是将它们相加。因此，我们可以说这个函数是确定的，我们可以很容易地对它进行推理。这样的函数也经常被称为 “纯函数”，因">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose中的副作用">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="什么是副作用从本质上讲，副作用是任何超出函数控制和作用域的东西。副作用会使函数变得不确定，因此它们使开发人员难以推理代码。 想象有一个函数，它被期望对两个数相加：  对于相同的输入值，其结果永远不会变化，也就是说，不会因为运行次数的增加导致输出结果的不同，因为该函数所做的唯一一件事就是将它们相加。因此，我们可以说这个函数是确定的，我们可以很容易地对它进行推理。这样的函数也经常被称为 “纯函数”，因">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.122Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.122Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose中的副作用",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.122Z",
  "dateModified": "2025-06-04T12:46:35.122Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose中的副作用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose中的副作用</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose中的副作用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.122Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.122Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="什么是副作用"><a href="#什么是副作用" class="headerlink" title="什么是副作用"></a>什么是副作用</h1><p>从本质上讲，副作用是任何超出函数控制和作用域的东西。副作用会使函数变得不确定，因此它们使开发人员难以推理代码。</p>
<p>想象有一个函数，它被期望对两个数相加：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/708caa2f092dece2442a9f5b37dcab14.png" alt="在这里插入图片描述"></p>
<p>对于相同的输入值，其结果永远不会变化，也就是说，不会因为运行次数的增加导致输出结果的不同，因为该函数所做的唯一一件事就是将它们相加。因此，我们可以说这个函数是确定的，我们可以很容易地对它进行推理。这样的函数也经常被称为 “<strong>纯函数</strong>”，因为它只使用它的输入来计算结果。</p>
<p>现在，让我们考虑添加一些附带行为:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/72ec702a7c9ceca472878438b4633705.png" alt="在这里插入图片描述"></p>
<p>我们引入了一个计算缓存来节省计算时间，如果之前已经计算过结果的话，将会直接返回缓存的结果。但是这个缓存逃脱了函数的控制，因此没有任何东西告诉我们从它读取的值是否自上次执行以来没有被修改过。想象一下，这个缓存正在从一个不同的线程并发更新，突然发现两次连续的调用<code>get(a, b)</code> 方法，对相同的输入却返回了两个不同的值：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ba96e20106d42c734492f07b7c7961ca.png" alt="在这里插入图片描述"></p>
<p><code>add</code> 函数对于相同的输入返回不同的值，因此它不再是确定性的。同样，假设这个缓存不在内存中，而是依赖于一个数据库。我们可以获得由 <code>get</code> 和 <code>store</code> 调用引发的异常，这取决于当前缺少到数据库的连接等情况。我们对 <code>add</code> 的调用也可能在意想不到的情况下失败。</p>
<p>概括一下，我们可以说副作用是发生在一侧的意想不到的动作，超出了调用者对函数的期望，并且可以改变它的行为。副作用使开发人员难以推理代码，也消除了可测试性，为不稳定打开了大门。</p>
<p>这对于React、Compose这类的声明式<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=UI%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">UI框架</a>至关重要，因为它们都是通过函数（组件）的反复执行来渲染UI的，函数执行的时机和次数都不可控，但是函数的执行结果必须可控，因此，我们要求这些函数组件必须用没有副作用的纯函数实现。</p>
<p>虽然副作用是不应该出现的，但是有时副作用是合理的，且必要的，例如，内存缓存、数据库、执行网络请求、文件读取、日志处理、弹出<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=toast&spm=1001.2101.3001.7020">toast</a>提醒、页面跳转等等。这些操作必须在能感知Composable生命周期的受控环境中执行，否则有可能打断 Compose 的施法。为此 Compose 提供了很多副作用API，使用这些API可以保证对应的操作在Composable的生命周期的特定阶段被执行，确保行为的可预期性。</p>
<h1 id="Compose-中的副作用"><a href="#Compose-中的副作用" class="headerlink" title="Compose 中的副作用"></a>Compose 中的副作用</h1><p>我们了解了在 Composable 函数中执行副作用时如何陷入同样的问题，因为这有效地使副作用逃脱了 Composable 生命周期施加的控制和约束。</p>
<p>我们还知道，可组合函数的属性之一就是可重新启动的，任何 Composable 都可能遭受多次重组。因此，直接在 Composable 中运行副作用并不是一个好主意。</p>
<p>在 Composable 中运行副作用的风险太大了，因为它可能会破坏代码的完整性和应用程序状态。让我们看下面的一个例子：一个从网络加载其状态的可组合函数</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/590c5b6ee716ce3ec0bd5975217fb136.png" alt="在这里插入图片描述"></p>
<p>这里的副作用将运行在每一个重组，这可能不是我们想要的。runtime 可能需要在很短的时间内多次重新组合这个 Composable。结果是将导致许多副作用同时发生，而它们之间没有任何协调。我们可能想要的是在第一次组合时只运行一次副作用，并在整个 Composable 生命周期中保持该状态。</p>
<p>现在，让我们想象我们的用例是 Android UI，所以我们使用 <code>compose-ui</code> 来构建一个可组合树。任何Android 应用程序都有副作用。下面是保持外部状态更新可能产生的副作用的示例。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/bc69a9ae0581edacc6136265b7e6a327.png" alt="在这里插入图片描述"></p>
<p>这个组合描述了一个带有触摸处理支持的 <code>drawer</code> 的屏幕。<code>drawer</code> 状态初始化为 <code>Closed</code>，但随着时间的推移可能会更改为 <code>Open</code>。对于每个组合和重组，可组合对象通知 <code>TouchHandler</code> 关于当前 <code>drawer</code> 状态，只有当它是 <code>Open</code>时才启用触摸处理支持。</p>
<p>这一行 <code>drawerTouchHandler.enabled = drawerState.isOpen</code> 就是一个副作用。我们在组合函数内对一个外部对象赋值一个回调引用，这个操作将成为<strong>组合的副作用</strong>。</p>
<p>回到网络请求的例子，如果一个触发网络请求的组合在完成之前就离开了，会发生什么？那时候我们可能更倾向于取消任务，对吧？</p>
<p>因为编写有状态程序需要副作用，所以 Jetpack Compose 提供了以生命周期感知的方式运行副作用的机制，因此可以在多个重组之间跨任务，或者在可组合对象离开组合时自动取消任务。这些机制称为 <strong>副作用处理程序</strong>（<strong>Effect handlers</strong>）。</p>
<p>在其他 runtime 执行策略中，组合可以转发到不同的线程、并行执行或以不同的顺序执行。这是一扇通向各种潜在优化的大门。Compose 团队想要保持开放，这也是为什么我们不想在没有任何控制的情况下，在 Compose 过程中立即运行我们的副作用。</p>
<p>总的来说，我们需要一些机制来确保：</p>
<ul>
<li>副作用运行在正确的可组合生命周期步骤。不早不晚。就在可组合的时候。</li>
<li>挂起的副作用运行在一个方便配置的 runtime (协程和CoroutineContext)。</li>
<li>捕获引用的副作用有机会在离开组合时销毁这些引用。</li>
<li>当离开组合时，正在进行的挂起的副作用将被取消。</li>
<li>依赖于随时间变化的输入的副作用会在每次变化时自动销毁&#x2F;取消并重新启动。</li>
</ul>
<p>这些机制由 Jetpack Compose 提供，称为 <strong>副作用处理程序</strong>（<strong>Effect handlers</strong>）。</p>
<h2 id="Compose-中的副作用处理程序（Effect-Handlers）"><a href="#Compose-中的副作用处理程序（Effect-Handlers）" class="headerlink" title="Compose 中的副作用处理程序（Effect Handlers）"></a>Compose 中的副作用处理程序（Effect Handlers）</h2><p>我们可以将副作用处理程序分为两类:</p>
<ul>
<li><strong>非挂起的副作用</strong>：例如当 Composable 进入组合时，运行一个副作用来初始化一个回调，当 Composable 离开组合，销毁这个回调。</li>
<li><strong>挂起的副作用</strong>：例如从网络加载数据以提供一些UI状态。</li>
</ul>
<p>在介绍它们之前，让我们先了解一下 <code>@Composable</code> 的生命周期，因为这一点跟副作用是紧密相关的。</p>
<h3 id="Compose-的生命周期"><a href="#Compose-的生命周期" class="headerlink" title="Compose 的生命周期"></a>Compose 的生命周期</h3><p>任何 Composable 在屏幕上具体化时进入组合，最后从 UI 树中移除时离开组合。在这两个事件之间，副作用都可能会运行。有些副作用可以比可组合的生命周期更持久，因此你可以跨组合扩展一个副作用。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4e0098f99d4a6c0502addd0c4246dfef.png" alt="在这里插入图片描述"><br>每个<code>Composable</code>函数最终会对应<code>LayoutNode</code>节点树中的一个<code>LayoutNode</code>节点，可简单的为其定义生命周期：</p>
<ul>
<li><strong>onActive</strong>: 进入重组作用域， <code>Composable</code>对应的<code>LayoutNode</code>节点被挂接到节点树上</li>
<li><strong>onUpdate</strong>：触发重组， <code>Composable</code>对应的<code>LayoutNode</code>节点被更新（0次或者多次）</li>
<li><strong>onDispose</strong>: 离开重组作用域， <code>Composable</code>对应的<code>LayoutNode</code>节点从节点树上移除</li>
</ul>
<h3 id="非挂起的副作用"><a href="#非挂起的副作用" class="headerlink" title="非挂起的副作用"></a>非挂起的副作用</h3><h3 id="DisposableEffect"><a href="#DisposableEffect" class="headerlink" title="DisposableEffect"></a>DisposableEffect</h3><p>它表示组合生命周期的副作用。<code>DisposableEffect</code>可以感知<code>Composable</code>的<code>onActive</code>和<code>onDispose</code>，允许通过副作用完成一些预处理和收尾工作。</p>
<ul>
<li>用于需要释放、销毁的非挂起的副作用。</li>
<li>第一次（当 Composable 进入组合时）以及每次它的<code>key</code>改变的时候运行。</li>
<li>在结束时需要调用一个 <code>onDispose</code> 回调。它在可组合对象离开组合时被释放，在其<code>key</code>发生变化时也会在每次重组时被释放。在这种情况下，副作用被销毁并重新启动。</li>
</ul>
<p>例如监听处理系统返回键的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BackPressHandler</span><span class="params">(enabled: <span class="type">Boolean</span> = <span class="literal">true</span>, onBackPressed: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> backDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher</span><br><span class="line">    <span class="keyword">val</span> currentOnBack <span class="keyword">by</span> rememberUpdatedState(onBackPressed)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> backCallback = remember &#123;</span><br><span class="line">        <span class="keyword">object</span> : OnBackPressedCallback(enabled) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleOnBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">                currentOnBack()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backDispatcher 发生变化时重新执行</span></span><br><span class="line">    DisposableEffect(backDispatcher) &#123;</span><br><span class="line">        backDispatcher?.addCallback(backCallback) <span class="comment">// onActive时添加回调</span></span><br><span class="line">        <span class="comment">// 当 Composable 进入 onDispose 时执行</span></span><br><span class="line">        onDispose &#123;</span><br><span class="line">            backCallback.remove() <span class="comment">// onDispose时移除回调 避免内存泄漏</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compose 中自带的<code>BackHandler</code>组件内部就是基于<code>DisposableEffect</code>实现 的。</p>
<p>它将一个回调添加到一个从 <code>CompositonLocal</code> 获得的<code>Dispatcher</code>调度程序。我们希望在可组合对象进入组合时以及当<code>Dispatcher</code>发生变化时添加回调。要实现这一点，我们可以将 <code>dispatcher</code> 作为副作用处理程序 <code>key</code> 传递。这将确保在这种情况下副作用被销毁并重新启动。</p>
<p>当可组合对象最终离开组合时，回调也会被释放。</p>
<p><code>DisposableEffect</code>的lambda中必须跟随一个<code>onDispose&#123;...&#125;</code>代码块的调用，否则会编译报错。<code>onDispose</code>一般常用于反注册<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83&spm=1001.2101.3001.7020">接口回调</a>，及一些资源清理工作，防止内存泄漏。<strong>当有新的副作用来临时，前一次的副作用就会执行<code>onDispose&#123;...&#125;</code>代码块中的代码。</strong></p>
<p><code>DisposableEffect</code>可以接受一个<code>key</code>作为参数，如果<code>key</code>是可变状态，当<code>key</code>发生变化时，会重新执行副作用中的代码块。</p>
<p>如果你想要副作用在进入组合时只运行一次，并在离开时释放它，你可以传递一个<code>Unit</code>或<code>true</code>这样的<strong>常量</strong>作为<code>key</code> ：<code>DisposableEffect(true)</code> 或 <code>DisposableEffect(Unit)</code> ，则副作用代码块只在<code>onActive</code>时执行一次。</p>
<blockquote>
<p>注意，<code>DisposableEffect</code>总是至少需要一个 <code>key</code>。</p>
</blockquote>
<p><code>DisposableEffect</code> 非常适合用于 <code>Composable</code> 在离开组合树时执行一些清理工作。</p>
<h3 id="SideEffect"><a href="#SideEffect" class="headerlink" title="SideEffect"></a>SideEffect</h3><p>这个副作用有点特殊，因为它的含义类似于 “在组合中触发或者忽略它”。<code>SideEffect</code>仅会在<strong>每次重组成功时执行</strong>，如果由于任何原因导致组合失败，它将被丢弃。因此它能正确的向外传递状态。 其中不能用来处理耗时和异步任务。（注意Composable函数不一定每次都会执行重组也不一定每次重组都会执行成功）</p>
<ul>
<li>用于不需要释放&#x2F;销毁的副作用。</li>
<li>在每一次组合&#x2F;重组成功后运行。</li>
<li>用于向外部状态发布更新。</li>
</ul>
<blockquote>
<p>如果你对 <code>Compose runtime</code> 的内部机制有一定的了解，注意 <code>SideEffect</code> 是一个没有存储在 <code>slot table</code> 中的副作用，这意味着它不会在 Composition 中存活下来，也不会在未来的 Composition 中重新尝试运行等等。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyScreen</span><span class="params">(drawerTouchHandler: <span class="type">TouchHandler</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> drawerState = rememberDrawerState(DrawerValue.Closed)</span><br><span class="line"></span><br><span class="line">    SideEffect &#123; <span class="comment">// 将 drawerState 通知外部</span></span><br><span class="line">        drawerTouchHandler.enabled = drawerState.isOpen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们关心 <code>drawer</code> 的当前状态，因为它可能随时变化。因此，我们需要在每个组合或重新组合中通知它。此外，如果 <code>TouchHandler</code> 是一个单例，在整个应用程序执行期间始终存在，因为这是我们的主屏幕（始终可见），我们可能根本不想释放引用。</p>
<p>我们可以将 <strong>SideEffect</strong> 理解为这样一个副作用处理程序：<strong>它旨在将更新发布到某些不受组合状态系统管理的外部状态，以保持其始终同步</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">rememberAnalytics</span><span class="params">(user: <span class="type">User</span>)</span></span>: FirebaseAnalytics &#123;</span><br><span class="line">    <span class="keyword">val</span> analytics: FirebaseAnalytics = remember &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// On every successful composition, update FirebaseAnalytics with</span></span><br><span class="line">    <span class="comment">// the userType from the current User, ensuring that future analytics</span></span><br><span class="line">    <span class="comment">// events have this metadata attached</span></span><br><span class="line">    SideEffect &#123;</span><br><span class="line">        analytics.setUserProperty(<span class="string">&quot;userType&quot;</span>, user.userType)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> analytics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="currentRecomposeScope"><a href="#currentRecomposeScope" class="headerlink" title="currentRecomposeScope"></a>currentRecomposeScope</h3><p>它更像是一个副作用而不是一个副作用处理程序。作为Android开发者，你可能熟悉<strong>View</strong> 系统中的 <code>invalidate</code> 方法，它基本上强制执行新的测量、布局和绘制过程。例如，它被广泛用于使用 <code>Canvas</code> 创建基于帧的动画。因此，在每个绘制周期中，你会使<strong>View</strong>视图无效，从而根据需要重新绘图。</p>
<p><code>currentRecomposeScope</code> 是一个在任何<strong>Composable</strong>函数中都能访问的成员，我们可以在<code>androidx.compose.runtime.Composables.kt</code>中找到它的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an object which can be used to invalidate the current scope at this point in composition.</span></span><br><span class="line"><span class="comment"> * This object can be used to manually cause recompositions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> currentRecomposeScope: RecomposeScope</span><br><span class="line">    <span class="meta">@ReadOnlyComposable</span></span><br><span class="line">    <span class="meta">@OptIn(InternalComposeApi::class)</span></span><br><span class="line">    <span class="meta">@Composable</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope = currentComposer.recomposeScope ?: error(<span class="string">&quot;no recompose scope found&quot;</span>)</span><br><span class="line">        currentComposer.recordUsed(scope)</span><br><span class="line">        <span class="keyword">return</span> scope</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>RecomposeScope</code> 是一个具有单一方法的接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">RecomposeScope</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invalidate the corresponding scope, requesting the composer recompose this scope. </span></span><br><span class="line"><span class="comment">     * This method is thread safe.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invalidate</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<code>currentRecomposeScope</code> 的作用与<code>View#invalidate</code>方法类似，通过调用 <strong><code>currentRecomposeScope.invalidate()</code></strong>，它将使当前时刻的本地组合无效，并强制触发重组。一般用于手动触发重组。</p>
<p>当使用<strong>非组合状态快照的数据源</strong>时，它可能很有用</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d3d8c6eaaa221b6320d0f408d1ea7645.png" alt="在这里插入图片描述"><br>这里我们有一个 <code>Presenter</code> ，当有结果时，我们手动使其失效以强制重组，因为我们没有以任何方式使用 <code>State</code>。当然这显然是一个非常剑走偏锋的示例，所以在大多数情况下你可能更喜欢利用 <code>State</code> 和智能重组。</p>
<p>所以总的来说，要谨慎使用！当状态可能变化时，使用<code>State</code>进行智能重组，这才是正常手段，因为这将确保最大限度地利用 Compose runtime。</p>
<h3 id="挂起的副作用"><a href="#挂起的副作用" class="headerlink" title="挂起的副作用"></a>挂起的副作用</h3><h3 id="LaunchedEffect"><a href="#LaunchedEffect" class="headerlink" title="LaunchedEffect"></a>LaunchedEffect</h3><p>这是一种用于加载 Composable 初始状态的挂起变体，它会在 Composable 进入组合时立即运行。</p>
<ul>
<li>当进入组合时运行副作用。</li>
<li>离开组合时取消副作用。</li>
<li>当<code>key</code>发生变化时取消并重新启动副作用。</li>
<li>对于<strong>跨组合扩展作业</strong>很有用。</li>
<li>当进入组合时，在Applier的调度器上运行副作用（通常是 <strong>AndroidUiDispatcher.Main</strong>）。</li>
</ul>
<p>当副作用中需要处理<strong>异步任务</strong>的需求时，可以使用 <strong><code>LaunchedEffect</code></strong>， 在 <code>Composable</code> <strong>进入组合</strong> (onActive)时，<code>LaunchedEffect</code> 会启动协程执行 <code>block</code> 中的内容，一般用来启动子协程或者调用挂起函数。</p>
<p>当 <code>Composable</code> <strong>离开组合</strong> (onDispose)时，<code>LaunchedEffect</code>启动的协程会自动取消，因此 <strong><code>LaunchedEffect</code></strong> 不需要实现<code>onDispose&#123;...&#125;</code></p>
<p>当 <code>LaunchedEffect</code> 设置的 <code>key</code> 发生变化时，当前协程自动结束，同时开启新的协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    state: <span class="type">UiState</span>&lt;<span class="type">List</span>&lt;<span class="type">Movie</span>&gt;&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    scaffoldState: <span class="type">ScaffoldState</span> = rememberScaffoldState()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 当 state 中包含错误时，显示一个 SnackBar,</span></span><br><span class="line">    <span class="keyword">if</span> (state.hasError) &#123;</span><br><span class="line">        <span class="comment">// 显示一个 SnackBar 的显示需要一个协程环境，而 LaunchedEffect 会为其提供</span></span><br><span class="line">        <span class="comment">// 当 scaffoldState.snackbarHostState变化时，将启动一个新的协程, SnackBar重新显示一次</span></span><br><span class="line">        <span class="comment">// 当 state.hasError 变成 false 时，LaunchedEffect 进入 onDispose, 协程会被自动取消，SnackBar也会随之消失</span></span><br><span class="line">        LaunchedEffect(scaffoldState.snackbarHostState) &#123;</span><br><span class="line">            scaffoldState.snackbarHostState.showSnackbar(</span><br><span class="line">                message = <span class="string">&quot;Error message&quot;</span>,</span><br><span class="line">                actionLabel = <span class="string">&quot;Retry message&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：使用<strong>LaunchedEffect</strong>时，<strong>务必</strong>要提供一个<strong>key</strong>，如果不这样做，那么它所处的Composable函数发生重组时，上一次的<strong>LaunchedEffect</strong>仍然在运行，其持有的状态仍然是上一次的，容易导致程序混乱，而且非常容易导致<strong>内存泄漏</strong>。</p>
<h4 id="关于-LaunchedEffect-Unit"><a href="#关于-LaunchedEffect-Unit" class="headerlink" title="关于 LaunchedEffect(Unit)"></a>关于 <code>LaunchedEffect(Unit)</code></h4><p>我们通常会在一些示例代码中看到这样的写法:<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/79ea6b8f947ef39d2ec782da6bee2588.png" alt="在这里插入图片描述"></p>
<p>它的作用是只执行一次副作用（这里是将<code>Unit</code>当作常量来使用，这里的<code>Unit</code>是kotlin中的一个<code>object</code>单例对象，其实这里传入其他任何常量也是可以的），也就是说当<strong>LaunchedEffect</strong>的<strong>key</strong>为<strong>常量</strong>时，不会依赖外部状态变化而反复执行，首次进入组合时开始执行，执行完毕就完了，即便重组也不会再次执行。</p>
<p>通常使用<code>LaunchedEffect(Unit)</code>可能是为了用来执行一次性的任务，例如首次进入时执行初始动画api；或者是纯粹的为了给挂起函数提供一个运行环境，例如进入时就开始观察某个<code>Flow</code>的数据变化，由于<code>collect</code>是挂起函数，所以必须在协程作用域中运行。</p>
<p>至于在实际中<strong>LaunchedEffect</strong>的<strong>key</strong>要不要设置为一个常量，只需要思考你的任务是否是需要跟随重组反复执行的，还是说只是在界面呈现时只执行一次而忽略后续重组。通常来说，如果你的任务是依赖于某个<code>mutableStateof</code>的可变状态，那么一般就使用该状态做key。</p>
<h3 id="rememberCoroutineScope"><a href="#rememberCoroutineScope" class="headerlink" title="rememberCoroutineScope"></a>rememberCoroutineScope</h3><p>由于 <code>LaunchedEffect</code> 是可组合函数， 因此只能在<code>Composable</code>函数中调用，如果想在非<code>Composable</code>环境中使用协程，例如 <code>Button</code> 的 <code>onClick</code> 方法中， 可以使用 <code>rememberCoroutineScope</code>，它会返回一个<code>CoroutineScope</code> 协程作用域，可以用来启动新的协程。 当 <code>Composable</code> 进入 <code>onDispose</code> 时，启动的协程会自动取消。如果你需要手动控制一个或多个协程的生命周期，可以考虑使用它，例如在用户事件发生时取消动画等。</p>
<ul>
<li>用于运行<strong>绑定到组合生命周期的挂起的副作用</strong>。</li>
<li><strong>创建绑定到这个组合生命周期的协程作用域<code>CoroutineScope</code></strong>。</li>
<li><strong>离开组合时，Scope 被取消</strong>。</li>
<li>在不同的组合中返回相同的作用域，因此我们可以继续向它提交更多的任务，所有正在进行的任务将在最终离开时被取消。</li>
<li>用于启动<strong>可响应用户交互的作业</strong>。</li>
<li>当进入组合时，在Applier的调度器上运行副作用（通常是 <strong>AndroidUiDispatcher.Main</strong>）。</li>
</ul>
<p>下面的示例在点击按钮时，通过 <code>rememberCoroutineScope</code> 创建的协程作用域来启动一个的协程用于显示<code>Snackbar</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyApp</span><span class="params">(scaffoldState: <span class="type">ScaffoldState</span> = rememberScaffoldState()</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个绑定 MyApp 生命周期的协程作用域</span></span><br><span class="line">    <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line">    Scaffold(scaffoldState = scaffoldState) &#123; padding -&gt;</span><br><span class="line">        Column(Modifier.padding(padding)) &#123;</span><br><span class="line">            Button(</span><br><span class="line">                onClick = &#123;</span><br><span class="line">                    <span class="comment">// 点击按钮时创建一个新的协程作用域，用于显示Snackbar</span></span><br><span class="line">                    scope.launch &#123;</span><br><span class="line">                        scaffoldState.snackbarHostState.showSnackbar(<span class="string">&quot;Something happened!&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ) &#123;</span><br><span class="line">                Text(text = <span class="string">&quot;Press me&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子是一个 UI 端的限流操作：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8b8b1dd04e78c61f0e2200b03dc4675f.png" alt="在这里插入图片描述"></p>
<p>在过去，你可能用过 <code>View</code> 系统的 <code>postDelayed</code> 或 <code>Handler</code> 来实现这个功能。每当文本输入发生变化时，我们希望取消之前正在进行的任何作业，并在延迟后发布一个新的作业，以便始终在潜在的网络请求之间强制执行最小的延迟。</p>
<blockquote>
<p>与 <code>LaunchedEffect</code> 不同的是，<code>LaunchedEffect</code> 用于限定由<strong>组合</strong>发起的作业的作用域，而<code>rememberCoroutineScope</code> 则用于限定由<strong>用户交互</strong>发起的作业的作用域。</p>
</blockquote>
<p>前面提到页面跳转其实也是一种副作用，在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/lyabc123456/article/details/128403631">Jetpack Compose中的导航路由</a> 中提到过，使用 <code>NavController</code> 进行导航时，如果目标路由页面不存在，会直接抛出异常导致应用崩溃，当时给出的方法是使用 <code>try-catch</code> 或者定义一个方便的扩展函数来使用。其实最好的解决方案就是使用这里的 <code>rememberCoroutineScope()</code> 来解决：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">WelcomeScreen</span><span class="params">(navController : <span class="type">NavController</span>)</span></span> &#123;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxSize(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally,</span><br><span class="line">        verticalArrangement = Arrangement.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(<span class="string">&quot;WelcomeScreen&quot;</span>, fontSize = <span class="number">20.</span>sp)</span><br><span class="line">        <span class="keyword">val</span> scope = rememberCoroutineScope()</span><br><span class="line">        <span class="keyword">val</span> context = remember &#123;</span><br><span class="line">            SupervisorJob() + Dispatchers.Main + CoroutineExceptionHandler &#123; context, throwable -&gt;</span><br><span class="line">                println(<span class="string">&quot;<span class="subst">$&#123;context[CoroutineName]&#125;</span> 发生了异常: <span class="variable">$throwable</span>&quot;</span>)</span><br><span class="line">            &#125; + CoroutineName(<span class="string">&quot;跳转LoginScreen&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Button(onClick = &#123;</span><br><span class="line">            scope.launch(context) &#123; navController.navigate(<span class="string">&quot;Login&quot;</span>) &#125;</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Go to LoginScreen&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调转到<code>Login</code>路由页面时，使用 <code>scope.launch(context)</code> 在指定的协程上下文中运行，该协程上下文由 <code>SupervisorJob()</code> （用来隔离协程作用域，防止异常传播）、一个主线程调度器、一个协程异常处理器（用来打印异常日志）以及一个协程名称组成。这样即便目标路由页面不存在，也不会导致应用崩溃。我们可以在控制台看到如下日志：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CoroutineName(跳转LoginScreen) 发生了异常: java.lang.IllegalArgumentException: </span><br><span class="line">Navigation destination that matches request NavDeepLinkRequest&#123; uri=android-app:<span class="comment">//androidx.navigation/Login &#125; </span></span><br><span class="line">cannot be found <span class="keyword">in</span> the navigation graph NavGraph(<span class="number">0x0</span>) startDestination=&#123;Destination(<span class="number">0x43892b15</span>) route=Welcome&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rememberUpdatedState"><a href="#rememberUpdatedState" class="headerlink" title="rememberUpdatedState"></a>rememberUpdatedState</h3><p><code>rememberUpdatedState</code>可以在不中断副作用的情况下感知外界的变化，一般用来获取观察状态的最新状态值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyScreen</span><span class="params">(onTimeOut: () -&gt; <span class="type">Unit</span>)</span></span> &#123; </span><br><span class="line">    <span class="keyword">val</span> currentOnTimeout <span class="keyword">by</span> rememberUpdatedState(onTimeOut)</span><br><span class="line">    <span class="comment">// key为Unit时不会因为MyScreen的重组重新执行</span></span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        delay(<span class="number">300</span>)</span><br><span class="line">        currentOnTimeout() <span class="comment">// 总是能获取到最新的 onTimeOut</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下面的例子更加容易理解：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">UpdatedRememberExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myInput <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Column(Modifier.height(<span class="number">100.</span>dp)) &#123;</span><br><span class="line">        OutlinedButton(</span><br><span class="line">            modifier = Modifier.fillMaxWidth().padding(vertical = <span class="number">8.</span>dp),</span><br><span class="line">            onClick = &#123; myInput++ &#125;</span><br><span class="line">        ) &#123;</span><br><span class="line">            Text(<span class="string">&quot;Increase rememberInput: <span class="variable">$myInput</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Calculation(input = myInput)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Calculation</span><span class="params">(input: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rememberUpdatedStateInput <span class="keyword">by</span> rememberUpdatedState(input)</span><br><span class="line">    <span class="keyword">val</span> rememberedInput <span class="keyword">by</span> remember &#123; mutableStateOf(input) &#125;</span><br><span class="line">    Text(<span class="string">&quot;updatedInput: <span class="variable">$rememberUpdatedStateInput</span>, rememberedInput: <span class="variable">$rememberedInput</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/98cc8dc5dced3205f1893a3e34f7f860.gif" alt="在这里插入图片描述"><br>可以看到在Calculation组件中，使用<code>rememberUpdatedState</code>方式的每次都能读取到外部更新后的最新的状态值，而普通方式则不行。当然这里也可以使用 <code>remember(key) &#123; &#125;</code> 的方式也能达到效果。</p>
<p>查看<code>rememberUpdatedState</code>可知它就是不断的将新值赋值给自身的<code>value</code>而已：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">rememberUpdatedState</span><span class="params">(newValue: <span class="type">T</span>)</span></span>: State&lt;T&gt; = remember &#123;</span><br><span class="line">    mutableStateOf(newValue)</span><br><span class="line">&#125;.apply &#123; value = newValue &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般当需要<strong>使用Composable函数参数中传入的lambda</strong>或者<strong>需要在副作用API中使用传入的lambda参数</strong>时，建议<strong>将lambda包裹在rememberUpdateState</strong>中。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b259ae2e3c6cb31ee8bb235c78572109.png" alt="在这里插入图片描述"></p>
<h3 id="snapshotFlow"><a href="#snapshotFlow" class="headerlink" title="snapshotFlow"></a>snapshotFlow</h3><p><code>snapshotFlow</code> 可以将 <code>Compose</code> 的 <code>State</code> 转换为 <code>Flow</code>。每当State变化时，flow就会发送新数据（但是冷流，调用collect才会发） snapshotFlow 会在收集到块时运行该块，并发出从块中读取的 State 对象的结果。当在 snapshotFlow 块中读取的 State 对象之一发生变化时，如果新值与之前发出的值不相等，Flow 会向其收集器发出新值（此行为类似于 <code>Flow.distinctUntilChanged</code> 的行为）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyScreen2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> pagerState = rememberPagerState()</span><br><span class="line">    LaunchedEffect(pagerState) &#123;</span><br><span class="line">        snapshotFlow &#123; pagerState.currentPage &#125; .collect &#123; page -&gt;</span><br><span class="line">            <span class="comment">// currentPage发生变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HorizontalPager(</span><br><span class="line">        count = <span class="number">10</span>,</span><br><span class="line">        state = pagerState,</span><br><span class="line">    ) &#123; page -&gt;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SnapshotFlowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> scaffoldState = rememberScaffoldState()</span><br><span class="line">    LaunchedEffect(scaffoldState) &#123;</span><br><span class="line">        snapshotFlow &#123; scaffoldState.snackbarHostState &#125;</span><br><span class="line">            .mapNotNull &#123; it.currentSnackbarData?.message &#125;</span><br><span class="line">            .distinctUntilChanged()</span><br><span class="line">            .collect &#123; message -&gt;</span><br><span class="line">                println(<span class="string">&quot;A SnackBar with message <span class="variable">$message</span> was shown&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="produceState"><a href="#produceState" class="headerlink" title="produceState"></a>produceState</h3><p><code>produceState</code> 和 <code>derivedStateOf</code> 都是状态创建的副作用API。从本质上讲，<code>remember</code> 也是一种副作用API，只在组件<code>OnActive</code>时被创建一次，不跟随重组反复创建。</p>
<p><strong>produceState可以将任意数据源转换成一个State供给Composable函数使用</strong></p>
<p>它实际上是建立在 <code>LaunchedEffect</code> 之上的语法糖。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">produceState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    initialValue: <span class="type">T</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    key1: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    key2: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    producer: <span class="type">suspend</span> <span class="type">ProduceStateScope</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: State&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = remember &#123; mutableStateOf(initialValue) &#125;</span><br><span class="line">    LaunchedEffect(key1, key2) &#123;</span><br><span class="line">        ProduceStateScopeImpl(result, coroutineContext).producer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即<code>produceState</code> 会创建一个协程，它也可用于观察非挂起的数据源。 该协程将作用域限定为可将值推送到返回的 <code>State</code> 的组合。使用此协程将非 Compose 状态转换为 Compose 状态，例如将外部订阅驱动的状态（如 Flow、LiveData 或 RxJava）引入组合。</p>
<p><code>produceState</code> 创建的协程会在进入组合时启动，在其退出组合时取消。设置相同的值不会触发重组。</p>
<p>以下是使用示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadNetWorkImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    url: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    imageRepository: <span class="type">ImageRepository</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> : State&lt;Result&gt; &#123;</span><br><span class="line">    <span class="comment">// produceState 观察 url 和 imageRepository 两个参数，当它们发生变化时，producer会重新执行</span></span><br><span class="line">    <span class="comment">// produceState的实现是通过 remember &#123; mutableStateOf() &#125; + LaunchedEffect （具有学习意义）</span></span><br><span class="line">    <span class="comment">// produceState 中的任务会随着 LaunchedEffect 的 onDispose 被自动停止。</span></span><br><span class="line">    <span class="keyword">return</span> produceState&lt;Result&gt;(initialValue = Result.Loading, url, imageRepository) &#123;</span><br><span class="line">        <span class="comment">// 通过挂起函数请求图片</span></span><br><span class="line">        <span class="keyword">val</span> image = imageRepository.load(url)</span><br><span class="line">        <span class="comment">// 根据请求结果设置 Result</span></span><br><span class="line">        <span class="comment">// 当 Result 变化时，读取此 State 的 Composable 会触发重组</span></span><br><span class="line">        value = <span class="keyword">if</span> (image == <span class="literal">null</span>) &#123;</span><br><span class="line">            Result.Error</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Result.Success(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ProduceStateSampleButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> loadImage <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        horizontalAlignment = Alignment.CenterHorizontally</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// Display a load image button when image is not loading</span></span><br><span class="line">        OutlinedButton(onClick = &#123; loadImage = !loadImage &#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">&quot;Click to load image with produceState <span class="variable">$loadImage</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loadImage) &#123;</span><br><span class="line">            ProduceStateExample()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">ProduceStateExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">    <span class="keyword">val</span> url = <span class="string">&quot;www.example.com&quot;</span></span><br><span class="line">    <span class="keyword">val</span> imageRepository = remember &#123; ImageRepository() &#125;</span><br><span class="line">    <span class="keyword">val</span> imageState = loadNetworkImage(url = url, imageRepository)</span><br><span class="line">    <span class="keyword">when</span> (imageState.value) &#123;</span><br><span class="line">        <span class="keyword">is</span> Result.Loading -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;🔥 ProduceStateExample() Result.Loading&quot;</span>)</span><br><span class="line">            with(context) &#123;showToast(<span class="string">&quot;🔥 ProduceStateExample() Result.Loading&quot;</span>)&#125;</span><br><span class="line">            CircularProgressIndicator()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> Result.Error -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;❌ ProduceStateExample() Result.Error&quot;</span>)</span><br><span class="line">            with(context) &#123;showToast(<span class="string">&quot;❌ ProduceStateExample() Result.Error&quot;</span>)&#125;</span><br><span class="line">            Image(imageVector = Icons.Default.Error, contentDescription = <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> Result.Success -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;✅ ProduceStateExample() Result.Success&quot;</span>)</span><br><span class="line">            with(context) &#123;showToast(<span class="string">&quot;✅ ProduceStateExample() Result.Success&quot;</span>)&#125;</span><br><span class="line">            <span class="keyword">val</span> image = (imageState.value <span class="keyword">as</span> Result.Success).image</span><br><span class="line">            Image(</span><br><span class="line">                painterResource(id = image.imageIdRes),</span><br><span class="line">                contentDescription = <span class="literal">null</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Context.<span class="title">showToast</span><span class="params">(msg: <span class="type">String</span>)</span></span> = Toast.makeText(<span class="keyword">this</span>, msg, Toast.LENGTH_SHORT).show()</span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> Loading : Result()</span><br><span class="line">    <span class="keyword">object</span> Error : Result()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Success</span>(<span class="keyword">val</span> image: ImageRes) : Result()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageRes</span>(<span class="keyword">val</span> imageIdRes: <span class="built_in">Int</span>) </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageRepository</span> &#123;     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a drawable resource or null to simulate Result with Success or Error states</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(url: <span class="type">String</span>)</span></span>: ImageRes? &#123;</span><br><span class="line">        delay(<span class="number">2000</span>) </span><br><span class="line">        <span class="comment">// Random is added to return null if get a random number that is zero.</span></span><br><span class="line">        <span class="comment">// Possibility of getting null is 1/4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (Random.nextInt(until = <span class="number">4</span>) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">val</span> images = listOf(</span><br><span class="line">                R.drawable.avatar_1_raster,</span><br><span class="line">                R.drawable.avatar_2_raster,</span><br><span class="line">                R.drawable.avatar_3_raster,</span><br><span class="line">                R.drawable.avatar_4_raster,</span><br><span class="line">                R.drawable.avatar_5_raster,</span><br><span class="line">                R.drawable.avatar_6_raster,</span><br><span class="line">            ) </span><br><span class="line">            <span class="comment">// Load a random id each time load function is called</span></span><br><span class="line">            ImageRes(images[Random.nextInt(images.size)])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/5184190bbcb8e248ffe811e8471cc223.gif" alt="在这里插入图片描述"></p>
<p>你可以为<code>produceState</code> 提供一个可选的初始默认值<code>initialValue</code> ，也可以提供<strong>一个或多个<code>key</code></strong>。</p>
<p>唯一需要注意的是，<code>produceState</code> <strong>允许不传递任何<code>key</code></strong>，在这种情况下，它将使用<code>Unit</code>作为<code>key</code>调用 <code>LaunchedEffect</code>，这会使其能够<strong>跨越组合</strong>。请注意这一点，因为API 接口文档中没有显式的说明这一点。</p>
<p>还可以在 <code>produceState</code> 中使用 <code>awaitDispose</code> 清理资源避免内存泄漏：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> currentPerson <span class="keyword">by</span> produceState(<span class="literal">null</span>, viewModel) &#123;</span><br><span class="line">    <span class="keyword">val</span> disposeable = viewModel.registerPersonObserver &#123; person -&gt;</span><br><span class="line">        value = person</span><br><span class="line">    &#125;</span><br><span class="line">    awaitDispose &#123;</span><br><span class="line">        <span class="comment">// 当 Composable 进入 onDispose时，进入此处</span></span><br><span class="line">        disposeable.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="derivedStateOf"><a href="#derivedStateOf" class="headerlink" title="derivedStateOf"></a>derivedStateOf</h3><p><code>derivedStateOf</code> <strong>用来将一个或多个 State 转成另一个用于观察的 State</strong>， <code>derivedStateOf&#123;...&#125;</code> 的 <code>block</code> 中可以依赖其他 <code>State</code> 创建并返回一个 <code>DerivedState</code>, 当 <code>block</code> 中依赖的 <code>State</code> 变化时，会更新此 <code>DerivedState</code>，依赖 <code>DerivedState</code> 的所有 <code>Composable</code> 会随之重组。</p>
<ul>
<li>依赖的其他状态改变的时候，自身状态也会跟着改变。</li>
<li>通常配合 <code>remember(key)</code> 一起使用：<code>val value by remember(otherState) &#123; derivedStateOf&#123;...使用otherState处理...&#125;&#125;</code></li>
<li>如果一个 <strong>List</strong> 是根据另一个 <strong>List</strong> 的处理之后的结果来展示。</li>
</ul>
<p>以下示例展示了基本的“待办事项”列表，其中具有用户定义的高优先级关键字的任务将首先显示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TodoList</span><span class="params">(highPriorityKeywords: <span class="type">List</span>&lt;<span class="type">String</span>&gt; = listOf(<span class="string">&quot;Review&quot;</span>, <span class="string">&quot;Unblock&quot;</span>, <span class="string">&quot;Compose&quot;</span>)</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> todoTasks = remember &#123; mutableStateListOf&lt;String&gt;() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate high priority tasks only when the todoTasks or highPriorityKeywords</span></span><br><span class="line">    <span class="comment">// change, not on every recomposition</span></span><br><span class="line">    <span class="keyword">val</span> highPriorityTasks <span class="keyword">by</span> remember(highPriorityKeywords) &#123;</span><br><span class="line">        derivedStateOf &#123; todoTasks.filter &#123; it.containsWord(highPriorityKeywords) &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123;</span><br><span class="line">        LazyColumn &#123;</span><br><span class="line">            items(highPriorityTasks) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">            items(todoTasks) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Rest of the UI where users can add elements to the list */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，<code>derivedStateOf</code> 保证每当 <code>todoTasks</code> 发生变化时，系统都会执行 <code>highPriorityTasks</code> 计算，并相应地更新界面。如果 <code>highPriorityKeywords</code> 发生变化，系统将执行 <code>remember</code> 代码块，并且会创建新的派生状态对象并记住该对象，以代替旧的对象。由于执行过滤以计算 <code>highPriorityTasks</code> 的成本很高，因此应仅在任何列表发生更改时才执行，而不是在每次重组时都执行。</p>
<p>此外，更新 <code>derivedStateOf</code> 生成的状态不会导致可组合项在声明它的位置重组，Compose 仅会对返回状态为已读的可组合项（在本例中，指 LazyColumn 中的可组合项）进行重组。</p>
<p>该代码还假设 <code>highPriorityKeywords</code> 的变化频率显著低于 <code>todoTasks</code>。否则，该代码会使用 <code>remember(todoTasks, highPriorityKeywords)</code> 而不是 <code>derivedStateOf</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SearchScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> postList = remember &#123; mutableStateListOf&lt;String&gt;() &#125;</span><br><span class="line">    <span class="keyword">val</span> keyWord <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里 postList 和 keyWord任意一个变化时，会更新 result</span></span><br><span class="line">    <span class="keyword">val</span> result <span class="keyword">by</span> remember &#123;</span><br><span class="line">        derivedStateOf &#123; postList.filter &#123; it.contains(keyWord) &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Box(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">        LazyColumn &#123;</span><br><span class="line">            items(result) &#123; item -&gt;</span><br><span class="line">                Text(item)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>remember</code> 实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result2 = remember(postList, keyWord) &#123;</span><br><span class="line">     postList.filter &#123; it.contains(keyWord) &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样写意味着<code>postList</code> 和 <code>keyWord</code>任意一个变化时，<code>Composable</code>会重组，与之相比 <code>derivedStateOf</code> 只有当输出的 <code>DerivedState</code>变化才会导致Composable重组，所以<strong>当一个计算结果依赖较多的 State 时，derivedStateOf 有助于减少重组次数，提高性能。</strong></p>
<blockquote>
<p><code>derivedStateOf</code> 只能监听<code>block</code>内的 <code>state</code>，一个非<code>State</code>类型的数据变化则可以通过<code>remember</code>的<code>key</code>进行监听。</p>
</blockquote>
<h3 id="remember-key"><a href="#remember-key" class="headerlink" title="remember(key)"></a>remember(key)</h3><p><code>remember</code> 函数有多个重载版本，其中我们最常用的写法是不带参数的版本: <code>remember &#123; mutableStateOf() &#125;</code>，但是它还可以传递多个 key 作为参数：<code>remember(key1，key2, ...) &#123; mutableStateOf() &#125;</code> 它根据参数 <code>key</code> 是否变化，来决定使用缓存的效果，当 <code>key</code> 的值发生变化后，重新执行 <code>&#123; &#125;</code> 里面的初始化代码，否则就一直返回内部的缓存值。</p>
<p>下面是一个简单计数器的例子，每当当前计算方式发生变化时，<code>counter</code> 的值会被重置：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RememberKeyExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> operation <span class="keyword">by</span> remember &#123; mutableStateOf(MathOperation.INCREASE) &#125;</span><br><span class="line">    <span class="keyword">var</span> counter <span class="keyword">by</span> remember(operation) &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    Button(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        onClick = &#123;</span><br><span class="line">            operation = <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">                MathOperation.INCREASE -&gt; MathOperation.DECREASE</span><br><span class="line">                MathOperation.DECREASE -&gt; MathOperation.INCREASE</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">val</span> text = <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">            MathOperation.INCREASE -&gt; <span class="string">&quot;Increase&quot;</span></span><br><span class="line">            MathOperation.DECREASE -&gt; <span class="string">&quot;Decrease&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        Text(<span class="string">&quot;Current operation <span class="variable">$text</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Button(</span><br><span class="line">        modifier = Modifier.fillMaxWidth(),</span><br><span class="line">        onClick = &#123;</span><br><span class="line">            <span class="keyword">when</span> (operation) &#123;</span><br><span class="line">                MathOperation.INCREASE -&gt; counter++</span><br><span class="line">                MathOperation.DECREASE -&gt; counter--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        Text(text = <span class="string">&quot;Counter <span class="variable">$counter</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">MathOperation</span> &#123; INCREASE, DECREASE &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8b437cbadf841fc51889711cbaf7446f.gif" alt="在这里插入图片描述"></p>
<h3 id="副作用的观察参数"><a href="#副作用的观察参数" class="headerlink" title="副作用的观察参数"></a>副作用的观察参数</h3><p>很多副作用Api都允许指定观察参数<code>key</code>，当<code>key</code>变化时，执行中的副作用会终止。 key的频繁变化会影响执行效率。因此关于key的使用应当遵循以下原则： <strong>当一个状态的变化需要造成副作用终止时，才将其添加为观察参数key, 否则应该将其通过<code>rememberUpdatedState</code>包装后，在副作用中使用，以避免打断执行中的副作用。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HomeScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    lifecycleOwner: <span class="type">LifecycleOwner</span> = LocalLifecycleOwner.current,</span></span></span><br><span class="line"><span class="params"><span class="function">    onStart: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onStop: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> currentOnStart <span class="keyword">by</span> rememberUpdatedState(onStart)</span><br><span class="line">    <span class="keyword">val</span> currentOnStop <span class="keyword">by</span> rememberUpdatedState(onStop)</span><br><span class="line"></span><br><span class="line">    DisposableEffect(lifecycleOwner) &#123;</span><br><span class="line">        <span class="keyword">val</span> observer = LifecycleEventObserver &#123; _, event -&gt;</span><br><span class="line">            <span class="comment">// 回调 currentOnStart() 或 currentOnStop()</span></span><br><span class="line">            <span class="keyword">when</span>(event) &#123;</span><br><span class="line">                Lifecycle.Event.ON_START -&gt; currentOnStart()</span><br><span class="line">                Lifecycle.Event.ON_STOP -&gt; currentOnStop()</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lifecycleOwner.lifecycle.addObserver(observer)</span><br><span class="line">        onDispose &#123;</span><br><span class="line">            lifecycleOwner.lifecycle.removeObserver(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中，<strong>当 lifecycleOwner 变化时，需要终止对当前 lifecycleOwner 的监听，并重新注册Observer, 因此这里才将其添加为key。而 onStart 和 onStop 只要保证在回调它们时，可以获取最新的值即可，所以应该使用rememberUpdatedState包装，不应该作为观察参数因为它们的变动终止副作用执行。</strong></p>
<h2 id="什么情况下该用-derivedStateOf-Or-remember-key-？"><a href="#什么情况下该用-derivedStateOf-Or-remember-key-？" class="headerlink" title="什么情况下该用 derivedStateOf { } Or remember(key) { } ？"></a>什么情况下该用 derivedStateOf { } Or remember(key) { } ？</h2><p>记住以下原则即可：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/928fb1128d7fd8aa5a398ee3bf2125cb.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3da3b3a0345ded25a60e4d22e9339a01.png" alt="在这里插入图片描述"><br>也就是说，<strong>如果使用 derivedStateOf 一般是你确定你所观察的状态或key的变化频率远高于你所期望的更新频率；而如果使用 remember(key) 则是你确定你的状态和传入的key的变化频率一样，换句话说就是你的状态每次都跟着你的key的变化而变化。</strong></p>
<p>比如下图的示例中，<code>submitEnabled</code>在输入框文本内容合法时会变成<code>true</code>，代表提交按钮变为可用状态：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1554adbb88488de844f2044df251d63c.gif" alt="在这里插入图片描述"></p>
<p>当输入框的内容从空白变成一个字符时，提交按钮从不可用变成可用状态，这没有问题，然而在当我们继续向输入框中输入文字时，情况有所不同：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fe987c4bb19e6695fa537000c1a94315.gif" alt="在这里插入图片描述"></p>
<p>可以看到后续向输入框持续输入内容时，已经变成<code>true</code>的<code>submitEnabled</code>仍然会被反复更新为<code>true</code>，而每次<code>submitEnabled</code>被更新为<code>true</code>时，界面都会触发重组流程。这不是我们想要的效果，我们想要的是只有在<code>submitEnabled</code>状态的值发生不同的改变时，才会重组，即在从<code>false</code>变成<code>true</code>以后，只有再次从<code>true</code>变成<code>false</code>时才会重复，而不是每次都重组。</p>
<p>这时正是使用 <strong>derivedStateOf</strong> 的场景：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/930963cd25f4c9d2b4d4238b8cc7e049.png" alt="在这里插入图片描述"></p>
<p>我们发现如果换成 <code>derivedStateOf &#123; &#125;</code> 后，同样的场景<code>submitEnabled</code>只会触发三次更新：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/51da617082843a4ae83e9ad4ab5dc22a.gif" alt="在这里插入图片描述"></p>
<p>另外一个典型的常见例子就是在列表中显示一个 “回到顶部” 的按钮：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2e2e3754f0fae4a7d2f522c254905a27.png" alt="在这里插入图片描述"></p>
<p>假如我们这样做，那么 <code>LazyList</code> 在滚动的每一帧都会更新 <code>listState</code>, 这会导致读取<code>listState</code>的地方不停的进行重组。此时可以使用<code>derivedStateOf</code>避免滑动过程中每一帧更新<code>listState</code>导致重组，而是只在索引值发生从 【等于0】到【大于0】之间的变化时，才会更新<code>showButton</code>的状态。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/23e13e7f38e73959cb9063dfcba6aad8.png" alt="在这里插入图片描述"></p>
<p>但并不是每次创建衍生的新状态时都需要使用 <code>derivedStateOf</code>，比如计算列表的大小时，此时 <code>contacts.size</code>的变化频率跟<code>contactCount</code>的是一样的，完全没有必要，还会增加额外开销：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/585dd47dba8b49272c1ec779c1448b4e.png" alt="在这里插入图片描述"></p>
<p>下面再看一个模拟购物车增加商品数量的代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">DerivedStateOfExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfItems <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line"></span><br><span class="line">    Column(modifier = Modifier.padding(horizontal = <span class="number">8.</span>dp).height(<span class="number">100.</span>dp)) &#123;</span><br><span class="line">        Surface &#123;</span><br><span class="line">            Row(verticalAlignment = Alignment.CenterVertically) &#123;</span><br><span class="line">                Text(text = <span class="string">&quot;Amount to buy: <span class="variable">$numberOfItems</span>&quot;</span>, modifier = Modifier.weight(<span class="number">1f</span>))</span><br><span class="line">                IconButton(onClick = &#123; numberOfItems++ &#125;) &#123;</span><br><span class="line">                    Icon(imageVector = Icons.Default.Add, contentDescription = <span class="string">&quot;add&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                Spacer(modifier = Modifier.width(<span class="number">4.</span>dp))</span><br><span class="line">                IconButton(onClick = &#123; <span class="keyword">if</span> (numberOfItems &gt; <span class="number">0</span>) numberOfItems-- &#125;) &#123;</span><br><span class="line">                    Icon(imageVector = Icons.Default.Remove, contentDescription = <span class="string">&quot;remove&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Surface &#123;</span><br><span class="line">            <span class="keyword">val</span> derivedStateMax <span class="keyword">by</span> remember &#123;</span><br><span class="line">                derivedStateOf &#123; numberOfItems &gt; <span class="number">5</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (derivedStateMax) &#123;</span><br><span class="line">                println(<span class="string">&quot;🤔 COMPOSING...&quot;</span>)</span><br><span class="line">                Text(<span class="string">&quot;You cannot buy more than 5 items&quot;</span>,</span><br><span class="line">                    color = Color(<span class="number">0xffE53935</span>),</span><br><span class="line">                    modifier = Modifier.fillMaxWidth().background(getRandomColor())</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Surface &#123;</span><br><span class="line">            <span class="keyword">val</span> derivedStateMax2 <span class="keyword">by</span> remember(numberOfItems) &#123;</span><br><span class="line">                mutableStateOf(numberOfItems &gt; <span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (derivedStateMax2) &#123;</span><br><span class="line">                println(<span class="string">&quot;🤔 COMPOSING...2&quot;</span>)</span><br><span class="line">                Text(<span class="string">&quot;You cannot buy more than 5 items&quot;</span>,</span><br><span class="line">                    color = Color(<span class="number">0xffE53935</span>),</span><br><span class="line">                    modifier = Modifier.fillMaxWidth().background(getRandomColor())</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中列出了两种对比状态：第一个<code>derivedStateMax</code>使用 <code>derivedStateOf &#123; &#125;</code> 方式的状态，而第二个<code>derivedStateMax2</code> 使用 <code>remember(key) &#123; &#125;</code> 方式的状态。运行效果如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6665861301be399c9e5bc790d638af08.gif" alt="在这里插入图片描述"><br>很显然，可以看到使用 <code>derivedStateOf &#123; &#125;</code> 方式的状态，当数量超过5之后，继续增加数量也不会再导致状态更新了，只有数量再次减到5以下才会更新一次；而下面使用 <code>remember(key) &#123; &#125;</code> 方式的状态值则每次都会更新状态触发重组。我想这个例子应该能很好的表达二者的区别。</p>
<p>假如我们有一个比较复杂的函数，它依赖于输入参数进行一些比较”昂贵”的计算处理，然后我们的UI需要根据函数的输出来更新，这时就适合需要使用 <code>remember(key) &#123; &#125;</code> 的场景，因为我们期望UI跟随<code>key</code>的变化而变化，即对于相同的输入我们期望有相同的输出(即避免重复计算)，而对不同的输入有不同的输出。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> output = remember(input) &#123; expensiveCalculate(input) &#125; </span><br></pre></td></tr></table></figure>

<h2 id="derivedStateOf-需要总是被-remembered-吗？"><a href="#derivedStateOf-需要总是被-remembered-吗？" class="headerlink" title="derivedStateOf 需要总是被 remembered 吗？"></a>derivedStateOf 需要总是被 remembered 吗？</h2><p>如果你使用 <strong>derivedStateOf</strong> 是在<strong>Composable</strong>函数内部，是的，它需要跟<code>mutableStateof</code>以及其他需要跨越重组而存活的对象一样，需要使用一个<code>remember&#123; &#125;</code>来包裹，否则在每次重组时都将被初始化为一个新的对象实例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyComposable</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// we need to use remember here to survive recomposition</span></span><br><span class="line">	<span class="keyword">val</span> state = remember &#123; derivedStateOf &#123;...&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果你是在状态容器中使用 <strong>derivedStateOf</strong> ，那就不一定需要<code>remember&#123; &#125;</code>来包裹了，比如在<strong>ViewModel</strong>中，因为<strong>ViewModel</strong>本身就是甚至能超越<strong>Activity</strong>的生死而存在的东西。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line">	<span class="comment">// we don&#x27;t need remember here (nor could we use it) because the ViewModel is outside of Composition.</span></span><br><span class="line">	<span class="keyword">val</span> state = derivedStateOf &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三方库适配"><a href="#第三方库适配" class="headerlink" title="第三方库适配"></a>第三方库适配</h2><p>我们经常需要使用来自第三方库的其他数据类型，例如 <code>Observable</code>、<code>Flow</code> 或 <code>LiveData</code>。Jetpack Compose 为最常见的第三方类型提供了适配器，因此取决于库，你需要获取不同的依赖项。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/aac29970b38ddc1b721eb7ae37336e25.png" alt="在这里插入图片描述"></p>
<p>所有这些适配器最终都会<strong>委托给副作用处理程序</strong>。它们都使用第三方库的 API 来添加观察者，并将每个发出的元素映射到一个特定的 <code>MutableState</code> 上，该 <code>MutableState</code> 作为不可变的 <code>State</code> 在适配器函数中公开。</p>
<p>下面是不同库的一些示例</p>
<h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/69d327a29a62c04ab50306dc865984d2.png" alt="在这里插入图片描述"></p>
<p><code>observeAsState</code>的实际实现依赖于<code>DisposableEffect</code>处理程序。</p>
<h3 id="RxJava2"><a href="#RxJava2" class="headerlink" title="RxJava2"></a>RxJava2</h3><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2da5871147402b5431a26ddecf3e6295.png" alt="在这里插入图片描述"></p>
<p>同样的扩展对 <code>Flowable</code> 也适用。</p>
<h3 id="KotlinX-Coroutines-Flow"><a href="#KotlinX-Coroutines-Flow" class="headerlink" title="KotlinX Coroutines Flow"></a>KotlinX Coroutines Flow</h3><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b55083e61b1f4b2bfc68493ca3c75dea.png" alt="在这里插入图片描述"><br><code>collectAsState</code> 的实现有点不同，因为<code>Flow</code>需要从挂起的上下文中消费。这就是为什么它依赖<code>produceState</code>而不是委托<code>launchedeeffect</code>的原因。</p>
<p>所有这些适配器都依赖于前面提到的副作用处理API，如果您有一个要集成的库，您可以按照相同的模式轻松编写自己的适配器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/314e66f8aa5f68e5ea8d5770b5c54c90.png" alt="在这里插入图片描述"><br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/732d6a22739ca3d4aac4e53de7d49d4e.png" alt="在这里插入图片描述"></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/30d9c203794114cd2bdb7ce3efad89f2.png" alt="在这里插入图片描述"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/">https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/" title="Compose中的列表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose中的列表</div></div><div class="info-2"><div class="info-item-1">Cloumn 和 Row如果是普通的不是特别长的列表，可以直接使用 Column 和 Row 组件，默认 Column 和 Row 组件是不支持滚动的，如果需要支持滚动可以在 Column 和 Row 组件上使用 Modifier.verticalScroll() 和Modifier.horizontalScroll() 修饰符 1234567891011121314151617181920212223@Composablefun ColumnList(list: List&lt;String&gt;) &#123;    Box &#123;        Column(Modifier.verticalScroll(rememberScrollState())) &#123;            list.forEach &#123;                Text(it)                Divider()            &#125;        &#125;    &#125;&#125;@Composablefun...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E4%B8%AD%E7%9A%84%E8%BD%AF%E9%94%AE%E7%9B%98%E4%B8%8E%E7%84%A6%E7%82%B9%E6%8E%A7%E5%88%B6/" title="Compose中的软键盘与焦点控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Compose中的软键盘与焦点控制</div></div><div class="info-2"><div class="info-item-1">FocusRequester 与 FocusManager在 Compose 中，可以通过 FocusRequester 与 FocusManager 这两个对象可以主动在代码中控制焦点获取和取消焦点，其中FocusRequester可以用来获取焦点，通过调用它的requestFocus()方法来实现，而 FocusManager可以用来取消焦点（以及移动焦点），通过调用它的clearFocus() 方法来实现。（不知道 Compose 官方的设计初衷是什么，这里为什么要搞两个对象。。） 123456789101112131415161718192021222324252627282930313233@Composablefun FocusControlExample() &#123;    var text by remember &#123; mutableStateOf(&quot;&quot;) &#125;    var hasFocus by remember &#123; mutableStateOf(false) &#125;    val...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">什么是副作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Compose-%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Compose 中的副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Compose-%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%88Effect-Handlers%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">Compose 中的副作用处理程序（Effect Handlers）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">Compose 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%8C%82%E8%B5%B7%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">非挂起的副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DisposableEffect"><span class="toc-number">2.1.3.</span> <span class="toc-text">DisposableEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SideEffect"><span class="toc-number">2.1.4.</span> <span class="toc-text">SideEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#currentRecomposeScope"><span class="toc-number">2.1.5.</span> <span class="toc-text">currentRecomposeScope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text">挂起的副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LaunchedEffect"><span class="toc-number">2.1.7.</span> <span class="toc-text">LaunchedEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-LaunchedEffect-Unit"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">关于 LaunchedEffect(Unit)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rememberCoroutineScope"><span class="toc-number">2.1.8.</span> <span class="toc-text">rememberCoroutineScope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rememberUpdatedState"><span class="toc-number">2.1.9.</span> <span class="toc-text">rememberUpdatedState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#snapshotFlow"><span class="toc-number">2.1.10.</span> <span class="toc-text">snapshotFlow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#produceState"><span class="toc-number">2.1.11.</span> <span class="toc-text">produceState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#derivedStateOf"><span class="toc-number">2.1.12.</span> <span class="toc-text">derivedStateOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remember-key"><span class="toc-number">2.1.13.</span> <span class="toc-text">remember(key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A7%82%E5%AF%9F%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.14.</span> <span class="toc-text">副作用的观察参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%AF%A5%E7%94%A8-derivedStateOf-Or-remember-key-%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">什么情况下该用 derivedStateOf { } Or remember(key) { } ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#derivedStateOf-%E9%9C%80%E8%A6%81%E6%80%BB%E6%98%AF%E8%A2%AB-remembered-%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">derivedStateOf 需要总是被 remembered 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E9%80%82%E9%85%8D"><span class="toc-number">2.4.</span> <span class="toc-text">第三方库适配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LiveData"><span class="toc-number">2.4.1.</span> <span class="toc-text">LiveData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RxJava2"><span class="toc-number">2.4.2.</span> <span class="toc-text">RxJava2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KotlinX-Coroutines-Flow"><span class="toc-number">2.4.3.</span> <span class="toc-text">KotlinX Coroutines Flow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>