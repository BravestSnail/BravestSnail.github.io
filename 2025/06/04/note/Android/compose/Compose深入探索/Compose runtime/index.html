<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose runtime | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="到目前为止，我们将 Compose runtime 在内存中维护的状态称为“Composition”，这是一个较为肤浅的概念。让我们从了解用于存储和更新Composition状态的数据结构开始探索。 slot table 和 change list我发现这两种数据结构之间存在一些混淆，可能是由于目前缺乏关于Compose内部结构的文档。现在，我认为有必要首先澄清这一点。 slot table（插槽">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose runtime">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="到目前为止，我们将 Compose runtime 在内存中维护的状态称为“Composition”，这是一个较为肤浅的概念。让我们从了解用于存储和更新Composition状态的数据结构开始探索。 slot table 和 change list我发现这两种数据结构之间存在一些混淆，可能是由于目前缺乏关于Compose内部结构的文档。现在，我认为有必要首先澄清这一点。 slot table（插槽">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.123Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.124Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose runtime",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.123Z",
  "dateModified": "2025-06-04T12:46:35.124Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose runtime',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose runtime</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose runtime</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.123Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.124Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>到目前为止，我们将 Compose runtime 在内存中维护的状态称为“<strong>Composition</strong>”，这是一个较为肤浅的概念。让我们从了解用于存储和更新Composition状态的数据结构开始探索。</p>
<h3 id="slot-table-和-change-list"><a href="#slot-table-和-change-list" class="headerlink" title="slot table 和 change list"></a>slot table 和 change list</h3><p>我发现这两种数据结构之间存在一些混淆，可能是由于目前缺乏关于Compose内部结构的文档。现在，我认为有必要首先澄清这一点。</p>
<p><code>slot table</code>（插槽表）是一个优化的内存结构，runtime 使用它来存储<strong>组合的当前状态</strong>。它在初始组合时填充数据，并在每次重新组合时更新。我们可以把它看作是所有Composable函数调用的跟踪，包括它们在源码中的位置、参数、记住的值、<code>CompositionLocals</code>等等。它包含了在合成过程中发生的一切内容。所有这些信息将被 <code>Composer</code> 稍后用于生成下一个更改列表，因为对树的任何更改总是依赖于当前状态。</p>
<p><code>slot table</code> 记录Composable的状态，而 <code>change list</code> 则是对节点树进行实际更改的内容。每次 Composable 函数的状态发生更改时，对应的更改操作会被添加到 <code>change list</code> 中。它可以理解为一个补丁文件，一旦应用，它就会更新树。所有要执行的更改都需要先被记录，然后再被应用。</p>
<p>最后，<code>Recomposer</code>协调所有这些，决定在什么时候和在什么线程上进行重组，以及在什么时候和在什么线程上应用更改。稍后会详细介绍。</p>
<h3 id="slot-table-深入了解"><a href="#slot-table-深入了解" class="headerlink" title="slot table 深入了解"></a>slot table 深入了解</h3><p><code>slot table</code> 是一种为快速线性访问而优化的数据结构。它用于存储 <code>Composition</code> 的状态，它基于 “<code>gap buffer</code>”（间隙缓冲区）的思想，在文本编辑器中非常常见。它将数据存储在<strong>两个线性数组</strong>中。其中一个数组保存关于<code>Composition</code>中可用的 <code>group</code> 的信息，另一个数组存储属于每个 <code>group</code> 的<strong>插槽</strong>（<code>slot</code>）。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2cc2ef34ed0c1cb712ced27d03778ada.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>在上一篇中，我们学习了编译器如何包装可组合函数体以使它们发出 <code>group</code> 。一旦 Composable 存储在内存中，这些组将为它提供唯一<code>key</code>，以便以后可以标识它。 <code>group</code>包含了 Composable 调用及其子调用的所有相关信息，并提供了关于如何处理Composable(作为一个组)的信息。根据可组合主体内部的控制流模式，<code>group</code>可以有不同的类型：可重启组、可移动组、可替换组、可重用组……</p>
</blockquote>
<p>存储 <code>groups</code> 的数组使用 <code>Int</code> 类型，因为它只存储 <code>group fields</code>（表示组的元数据）。父组和子组以 <code>group fields</code>的形式存储。鉴于它是一个线性数据结构，父组的 <code>group fields</code>总是在前面，所有子组的 <code>group fields</code>将紧随其后。这是一种建模<code>group</code>树的线性方法，它有利于对子节点进行线性扫描。除非通过<code>group</code><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%94%9A%E7%82%B9&spm=1001.2101.3001.7020">锚点</a>访问，否则对其进行随机访问是非常昂贵的。（锚点就像指针一样的存在）</p>
<p>另一方面，<code>slots</code> 数组存储这些组中的每一个<code>group</code>的相关数据。它存储任何类型的值（<code>Any?</code>），因为它意味着存储任何类型的信息。这是实际 <code>Composition</code> 组合数据存储的地方。存储在 <code>groups</code> 数组中的每个<code>group</code>都描述了如何在 <code>slots</code> 数组中查找和解释它的 <code>slot</code>，因为一个<code>group</code>总是链接到一系列的<code>slots</code>。</p>
<p><code>slot table</code> 依赖于一个 <code>gap</code> (间隙) 来读写。可以把它看成是表中的<strong>一系列位置</strong>。这个间隙会四处移动，并决定何时从哪里读取数据，何时将数据写入数组。<code>gap</code> 有一个指针来指示从哪里开始写入，并且可以移动它的开始和结束位置，因此表中的数据也可以被覆盖。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/99eb1543ad030aff2c358fd8268199cc.png" alt="在这里插入图片描述"></p>
<p>一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=gap&spm=1001.2101.3001.7020">gap</a> buffer是一种表示带有当前索引或光标的集合的数据结构。它在内存中用一个扁平数组实现。该扁平数组的大小大于它所表示的数据集合，未使用的空间称为gap。当需要插入新数据时，gap会移动到对应的位置，以便插入新的元素。这个过程会使得数据移动，但是由于gap的存在，移动的数据量会被最小化。这个结构的好处是，随机访问非常快速，而且插入和删除操作的时间复杂度是O(n)。</p>
<p>考虑以下条件逻辑：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/52a884b4e02a503b246e7652ef6a045f.png" alt="在这里插入图片描述"></p>
<p>由于此 Composable 被标记为 <code>non-restartable</code>，因此将插入一个可替换的 <code>group</code>（而不是一个可重启的 <code>group</code>）。该 <code>group</code> 将在 <code>slot</code> 表中为当前处于 “<code>active</code>” 状态的子元素的存储数据。如果 <code>a</code> 为<code>true</code>，那么处于 “<code>active</code>” 状态的子元素将是 <code>Text(a)</code>。当条件切换时，<code>gap</code> 将移回 <code>group</code> 的起始位置，并从那里开始写入，用 <code>Text(b)</code> 的数据覆盖所有这些位置。</p>
<p>为了读写表，我们有<code>SlotReader</code>和<code>SlotWriter</code>。表可以有多个<code>active</code>的 <code>Reader</code>，但 <strong>只能有一个<code>active</code>的<code>Writer</code></strong>。在每次读或写操作后，相关的 <code>Reader</code>或<code>Writer</code>都会被关闭。可以启用任意数量的 <code>Reader</code> 来读取数据，但为了安全起见，<strong>只有在表未被写入时才能够从中读取</strong>。<code>SlotTable</code>会保持无效状态直到<code>active</code>的<code>Writer</code>被关闭，因为它将直接修改 <code>groups</code> 和 <code>slots</code>，如果我们在写的时候同时尝试从中读取，可能会导致竞争。</p>
<p>一个 <code>reader</code> 的作用类似于<strong>访问者</strong>。它跟踪正在从 groups 数组中读取的当前组、它的开始和结束位置、父组（紧挨着存储的）、当前正在读取的组中的当前<code>slot</code>、组的数量等等。Reader可以重新定位、跳过组、从当前 slot 中读取值、从特定索引中读取值等等。换句话说，它被用来从数组中读取有关<code>group</code>和它们的<code>slot</code>的信息。</p>
<p>相对的，<code>Writer</code> 用于向数组中写入 groups 和 slots。正如上面所述，它可以将任何类型（<code>Any?</code>）的数据写入表中。<code>SlotWriter</code>依赖于上面提到的 <code>gap</code> 来操作 groups 和 slots，因此它使用它们来确定在数组中进行写入的位置。</p>
<p>把<code>gap</code>想象成一个<strong>可滑动可调整大小的线性数组区间</strong>。<code>Writer</code> 维护着每个<code>gap</code>的起始位置、结束位置和长度，它可以通过更新起始位置和结束位置来移动<code>gap</code>的位置。</p>
<p><code>Writer</code> 能够添加、替换、移动和删除 groups 和 slots。比如，想象一下向树中添加一个新的Composable 节点，或者在条件逻辑下需要替换的 Composable 节点。</p>
<p><code>Writer</code> 可以跳过 groups 和 slots，按给定数量的位置前进，seek 到由 <code>Anchor</code> 确定的位置，以及许多类似的操作。</p>
<p><code>Anchor</code> 是一个指向表中特定索引的位置的引用，<code>SlotTable</code> 的 <code>writer</code> 维护着指向特定位置的 <code>Anchor</code> 列表。同时，<code>Anchor</code>追踪每个<code>group</code>在表中的位置，也称为<code>group</code>索引。如果在<code>Anchor</code>指向的位置之前插入，移动，替换或删除<code>group</code>，<code>Anchor</code>会相应地进行更新。这个机制可以帮助<code>writer</code>快速访问表中的指定位置。</p>
<p><code>slot table</code>还可以作为 composition groups的迭代器，因此它可以向工具提供关于它们的信息，以便这些工具能够检查和呈现组合的详细信息。现在是时候了解更改列表。</p>
<blockquote>
<p>如果需要获取有关slot table的更多细节，建议阅读Jetpack Compose团队的Leland Richardson的<a target="_blank" rel="noopener" href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd">这篇文章</a>。</p>
</blockquote>
<h3 id="change-list"><a href="#change-list" class="headerlink" title="change list"></a>change list</h3><p>我们已经学习了关于 <code>slot table</code> 知识，了解了它是如何允许运行时跟踪合成的当前状态。但是，<code>change list</code> 的确切作用是什么呢？它是什么时候产生的？它模拟了什么？这些更改是在何时应用的，出于什么原因？我们仍然有许多事情需要搞清楚。</p>
<p>每当合成（或重新合成）发生时，我们的源Composable函数将被执行 和 <strong>发射（Emit）</strong>。<strong>Emit</strong> 这个词意味着创建<strong>延迟的更改</strong>以更新 <code>slot table</code> ，最终也会更新实际生成的树。这些更改存储为一个列表。生成这个新的更改列表是基于已经存储在 <code>slot table</code> 中的内容。记住：对树的任何更改都必须依赖于 Composition 的当前状态。</p>
<blockquote>
<p>这可以举一个移动节点的例子。假设我们要重新排列列表的Composable函数。我们需要检查该节点在表中之前的位置，删除所有这些槽，并从新位置开始再次写入它们。</p>
</blockquote>
<p>换句话说，每当一个 Composable 函数发射时，它都会查看<code>slot table</code> ，根据当前可用的需求和信息创建延迟更改，并将其添加到包含所有更改的列表中。稍后，在 Composition 完成后，就是实例化的时候了，那些<strong>记录</strong>的更改将会被有效地执行。这时，它们会使用 Composition 的最新可用信息有效地更新<code>slot table</code> 。这个过程使得发射过程非常快速：它只是创建一个等待被运行的延迟操作。</p>
<p>由此，我们可以看出<code>change list</code> 是最终对<code>slot table</code> 进行更改的。在这之后，它将通知 <code>Applier</code> 更新实例化的节点树。</p>
<p>正如我们上面所说的，<code>Recomposer</code>协调这个过程，并决定在哪个线程上进行合成或重新合成，以及使用哪个线程来应用<code>change list</code> 中的更改。后者也是<code>LaunchedEffect</code>用于执行副作用的默认上下文。</p>
<h3 id="投喂-Composer"><a href="#投喂-Composer" class="headerlink" title="投喂 Composer"></a>投喂 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Composer&spm=1001.2101.3001.7020">Composer</a></h3><p>注入的<code>$composer</code>将我们编写的 Composable 函数连接到 Compose runtime。</p>
<p>让我们探讨如何将节点添加到内存表示的树中。我们可以使用 <strong>Layout</strong> Composable来讨论。<strong>Layout</strong> 是 Compose UI 提供的所有UI组件的管道。下面是其代码实现：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/32e5e5fb387d72287ba74f34f650639c.png" alt="在这里插入图片描述"></p>
<p><strong>Layout</strong> 使用 <strong>ReusableComposeNode</strong> 来将 <strong>LayoutNode</strong> 发射到组合中。但即使听起来像是立即创建并添加节点，它实际上是在告知 runtime 如何在组合的当前位置创建、初始化和插入节点。以下是其实现代码：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b12ffa4b4d27791d6aa898e2d491f301.png" alt="在这里插入图片描述"><br>这里省略了一些不相关的部分，但请注意它将一切委托给<code>currentComposer</code>实例。我们还可以看到它是会启动一个可替换的<code>group</code>，以便在存储时来包装Composable的内容。在 <code>content</code> lambda 内发射的任何子元素都将有效地存储为 Composition 中该 <code>group</code> 的子元素。</p>
<p>其他Composable函数也是同样的发射操作。例如，<code>remember</code>：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/dbd8290c2a353d720bb2fb4860f3bd83.png" alt="在这里插入图片描述"></p>
<p><code>remember</code> Composable 函数使用 <code>currentComposer</code> 来将用户提供的lambda返回值 <strong>缓存</strong>（记住）到 Composition 中。<code>invalid</code>参数强制更新值，无论它之前是否已被存储。缓存的代码实现如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9345e3a31222e7ed5440481033eefdff.png" alt="在这里插入图片描述"><br>它首先会在 Composition（slot table）中查找这个值。如果未找到，它就会计划<strong>安排一次对该值更新</strong>操作（换句话说，是记录它）。否则如果找到的话，就原样返回该值。</p>
<h3 id="对更改进行建模"><a href="#对更改进行建模" class="headerlink" title="对更改进行建模"></a>对更改进行建模</h3><p>正如前面所解释的，所有委托给 <code>currentComposer</code> 的发射操作在内部都被建模为 <code>Changes</code> 并添加到列表中。<code>Change</code> 是一个延迟执行的函数，它可以访问当前的 <code>Applier</code> 和 <code>SlotWriter</code>（记住一次只有一个活动的 <code>writter</code>）。让我们看一下它的代码：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/dee29008677bac68587dddc835a0c5aa.png" alt="在这里插入图片描述"></p>
<p>这些更改被添加到列表中(记录)。“发射”操作本质上意味着创建这些<code>Changes</code>，它们是<strong>延迟执行的lambdas</strong>，以潜在地从 <code>slot table</code> 中添加、删除、替换或移动节点，并进而通知 <code>Applier</code> (因此这些更改就被实现)。</p>
<p>出于这个原因，每当我们讨论“发射更改”时，我们可能还会使用“记录更改”或“调度更改”这样的词。它们都指的是同一件事。</p>
<p>在组合完成之后，一旦所有Composable函数调用完毕，所有更改都会被记录下来，此时 <strong><code>Applier</code> 就会批量的应用它们</strong>。</p>
<h3 id="优化写入时间"><a href="#优化写入时间" class="headerlink" title="优化写入时间"></a>优化写入时间</h3><p>如上所述，插入新节点被委托给 <code>Composer</code>。这意味着它总是知道什么时候已经进入了将新节点插入组合的过程。在这种情况下，<code>Composer</code> 可以缩短流程，并在发射更改时<strong>立即</strong>开始向<code>slot table</code>写入，而不是记录它们（即将它们添加到列表中稍后才进行解释）。在另一种情况下，这些更改被记录并延迟，因为现在还不是进行更改的时候。</p>
<h3 id="读写-groups"><a href="#读写-groups" class="headerlink" title="读写 groups"></a>读写 groups</h3><p>一旦组合完成，<code>composition.applychanges()</code>最终被调用以构建树，并将更改写入<code>slot table</code>。<code>Composer</code>可以写入不同类型的信息：数据、节点或组。也就是说，为了简单起见，所有这些数据最终都以 <code>group</code> 的形式存储。</p>
<p><code>Composer</code>可以“开始”和“结束”任何<code>group</code> 。根据所采取的行动，这有不同的含义。如果它正在写入，它将代表从<code>slot table</code>中“创建的组”和“删除的组”。如果它正在读取，则会要求<code>SlotReader</code>将其<strong>读取指针</strong>移到组外，以便开始或结束从其中进行读取。</p>
<p>Composable 树上的节点（最终是表中的组）不仅可以插入，还可以删除或移动。删除一个组意味着从表中删除它及其所有对应的槽。为此，<code>Composer</code> 会要求重新定位<code>SlotReader</code>，并让它跳过该组（因为它不存在了），同时记录从<code>applier</code>中删除其所有节点的操作。任何修改操作都需要先记录，然后批量应用，主要是为了确保它们都有意义。<code>Composer</code>还将丢弃已删除组的任何 <code>pending invalidations</code>（挂起的失效）， 因为它们永远不会发生。</p>
<blockquote>
<p>并非所有组都是可重启、可替换、可移动或可重用的。在以<code>group</code>形式存储的其他内容中，我们可以找到默认的包装代码块。这个代码块包含了生成默认参数所需的可组合调用的<code>remembered</code>值：例如 <code>model: Model = remember &#123; DefaultModel() &#125;</code>。这样也是会以一个非常特定的<code>group</code>形式来存储的。</p>
</blockquote>
<p>当 <code>Composer</code> 想要创建一个<code>group</code>时，会发生以下事情:</p>
<ul>
<li>如果 <code>Composer</code> 正在插入值，它将继续写入 <code>slot table</code>，因为没有理由等待。</li>
<li>如果有挂起的操作，它将在应用这些更改的时候将这些更改记录到applier。这时，如果<code>group</code>已经在 <code>slot table</code>中存在，<code>Composer</code>将尝试重用该<code>group</code>。</li>
<li>当<code>group</code>已经存储但位置不同时(它已被移动)，将记录移动组的所有slot的操作。</li>
<li>如果<code>group</code>是新的(在表中没有找到)，它将进入插入模式，先将<code>group</code>及其所有子<code>group</code>写入一个临时<code>insertTable</code>表(另一个SlotTable)，直到组完成之后，再将安排其插入到最终表。</li>
<li>如果<code>Composer</code>没有插入，并且也没有挂起的写操作，它将尝试开始读取组。</li>
</ul>
<p>重用组是很常见的。有时不需要创建新节点，但我们可以重用它，以防它已经存在。(参见上面的<code>ReusableComposeNode</code>)。这将触发(记录)<code>Applier</code>导航到该节点的操作，但将跳过创建和初始化该节点的操作。</p>
<p>当节点的属性需要更新时，该操作也被记录为<code>Change</code>。</p>
<h3 id="记忆值"><a href="#记忆值" class="headerlink" title="记忆值"></a>记忆值</h3><p>我们了解了<code>Composer</code>如何能够将值<code>remember</code>到<code>Composition</code>中(将它们写到 <code>slot table</code>中)，并且它还可以稍后更新这些值。当调用<code>remember</code>时，会立即检查比较它是否自上次组合以后发生了变化 ，但更新操作只会被记录为<code>Change</code>，除非Composer已经在执行插入。</p>
<p>当要更新的值是一个<code>RememberObserver</code>时，<code>Composer</code>也会记录一个隐式的<code>Change</code>来跟踪构图中的记忆操作。（如果稍后需要忘记那些已经remembered的值，这是必要的）</p>
<h3 id="重组作用域"><a href="#重组作用域" class="headerlink" title="重组作用域"></a>重组作用域</h3><p>当<code>Composer</code>在重组作用域时还会发生的其他事情，如支持智能重组。它们直接链接到重启的<code>group</code>。每次创建一个重启的<code>group</code>时，<code>Composer</code>都会为其创建一个<code>RecomposeScope</code>，并将其设置为 <code>Composition</code> 的 <code>currentRecomposeScope</code>。</p>
<p><code>RecomposeScope</code>对组合的一个区域进行建模，该区域可以独立于组合的其他部分进行重新组合。它可用于手动使可组合对象失效和触发重新组合。失效是通过<code>composer</code>请求的，如 <code>composer.currentRecomposeScope().invalidate()</code> 。为了重新组合，Composer 将<code>slot table</code>定位到该组的起始位置，然后调用传递给 lambda 的重组 block 块。这将再次调用 Composable 函数，并再次执行发射操作，从而会进一步要求 <code>Composer</code> 重写表中的现有数据。</p>
<p><code>Composer</code>维护所有已失效的重组作用域的堆栈。这意味着它们正在被挂起并等待重新组合，换句话说，它们需要在下一次重新组合中被触发。<code>currentRecomposeScope</code>实际上是通过这个栈的<code>peek</code>操作获得的。</p>
<p>也就是说，<code>RecomposeScopes</code> 并不总是被启用的。只有当 Compose 发现 Composable 从它的 <code>State</code> 快照中执行读操作时，才会发生这种情况。在这种情况下，<code>Composer</code> 会标记 <code>RecomposeScope</code> 为已使用，这使得在 Composable 的末尾插入的<code>end</code>调用不再返回<code>null</code>，因此会激活后面的 <code>recomposition lambda</code> (参见下面，在<code>?</code>字符后面的部分) 。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/babd16234964212f86887b8622960b80.png" alt="在这里插入图片描述"><br>当需要重新组合当前父组的所有无效子组时，<code>Composer</code>可以重新组合，或者当不需要重新组合时，<code>Composer</code>也可以简单地让读取器跳过该组直到结束（即跳过重组）。</p>
<h3 id="Composer-中的副作用"><a href="#Composer-中的副作用" class="headerlink" title="Composer 中的副作用"></a>Composer 中的副作用</h3><p>Composer 也能够记录 <code>SideEffect</code>。<strong><code>SideEffect</code> 总是在合成之后运行</strong>。它们被记录为一个函数，以便在已经应用了对相应树的更改时调用。它们表示发生在旁边的效果，所以这种类型的效果完全不知道 Composable 的生命周期。我们不会在离开合成时自动取消它，也不会在重组时重新尝试它。这是因为这种类型的效果没有存储在<code>slot table</code>中，因此如果组合失败就会被丢弃。</p>
<h3 id="存储CompositionLocals"><a href="#存储CompositionLocals" class="headerlink" title="存储CompositionLocals"></a>存储CompositionLocals</h3><p>Composer 还提供了注册 <code>CompositionLocals</code> 并在给定<code>key</code>的情况下获取其值的方法。 <code>CompositionLocal.current</code> 的调用依赖于此。 <code>Provider</code>和它的值一起也作为一个<code>group</code>被存储在<code>slot table</code>中。</p>
<h3 id="存储源信息"><a href="#存储源信息" class="headerlink" title="存储源信息"></a>存储源信息</h3><p>Composer 还以<code>CompositionData</code>的形式存储那些在合成过程中通过 Compose tools 收集的源信息。</p>
<h3 id="通过-CompositionContext-链接-Compositions"><a href="#通过-CompositionContext-链接-Compositions" class="headerlink" title="通过 CompositionContext 链接 Compositions"></a>通过 CompositionContext 链接 Compositions</h3><p>Compose 中不存在单一的组合，而是由组合和子组合组成的树。子组合是内联创建的组合，其唯一目的是在当前组合的上下文中构造一个单独的组合，以支持独立的失效操作。</p>
<p>子组合通过父组合的<code>CompositionContext</code>引用连接到它的父组合。此上下文的存在是为了将组合和子组合作为树链接在一起。它确保<code>CompositionLocals</code>和<code>invalidations</code>被透明地解析&#x2F;沿着树向下传播，就好像它们属于单个Composition一样。<code>CompositionContext</code>本身也作为一个<code>group</code>被写入到<code>slot table</code>中。</p>
<p>创建子组合通常通过<code>rememberCompositionContext</code>完成：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a6fbcb6efcd44bf958a3684400b247fb.png" alt="在这里插入图片描述"></p>
<p>这个函数在<code>slot table</code>的当前位置记忆了一个新的<code>Composition</code>，如果它已经被记忆，则返回该 <code>Composition</code>。它用于需要从单独的 Composition 的位置创建子 Composition 的情况，比如 <code>VectorPainter</code> 、<code>Dialog</code>、<code>SubcomposeLayout</code>、<code>Popup</code> 或 实际的<code>AndroidView</code> （一个包装器，用于将 <code>Android Views</code> 集成到 <code>Composable</code> 树中）。</p>
<h3 id="访问当前State快照"><a href="#访问当前State快照" class="headerlink" title="访问当前State快照"></a>访问当前State快照</h3><p>Composer具有对当前快照的引用，即当前线程返回的可变状态和其他状态对象的值的快照。除非在快照中显式更改了状态对象，否则所有状态对象在快照中的值与创建快照时的值相同。</p>
<h3 id="节点导航"><a href="#节点导航" class="headerlink" title="节点导航"></a>节点导航</h3><p>节点树的导航是由<code>applier</code>执行的，但并不是直接执行的。它是通过记录所有节点在<code>reader</code>遍历时的位置，并将它们记录在一个<code>downNodes</code>数组中来完成的。当节点导航被实现时，所有在<code>down nodes</code>中的<code>downs</code>都将被传递给<code>applier</code>。如果在对应的<code>down</code>被实现之前就记录了<code>up</code>，则它将被简单地从<code>downNodes</code>堆栈中删除，作为一种快捷方式。</p>
<h3 id="保持读写同步"><a href="#保持读写同步" class="headerlink" title="保持读写同步"></a>保持读写同步</h3><p>这是一些较低层次的实现细节，但由于组（group）可以插入、删除或移动，一个组在writer中的位置可能会与在reader中的位置有一段时间的不同（直到更改被应用）。因此需要维护一个delta来跟踪差异。该delta将通过插入、删除和移动更新，并反映 “writer必须移动的 unrealized distance 以匹配reader中的当前slot”（根据文档所说）。</p>
<h3 id="应用更改"><a href="#应用更改" class="headerlink" title="应用更改"></a>应用更改</h3><p>正如前面多次提到的，<code>Applier</code>负责执行这个过程。当前的<code>Composer</code>委托这个抽象来应用<code>Composition</code>后记录的所有更改。这就是我们所说的“<code>materializing</code>”。此过程执行<code>Changes</code>列表，并更新<code>slot table</code>，解释存储在其中的 <code>Composition</code> 数据，以有效地产生结果。</p>
<p>runtime 本身并不关心<code>Applier</code>如何实现。它依赖于一个公共的锲约接口协议，期望客户端库实现。这是因为<code>Applier</code> 是与平台集成的接口，因此它将根据用例而变化。该接口协议如下：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e70f936959422ddfce1f6085268b01a9.png" alt="在这里插入图片描述"><br>接口声明中的第一个是<code>N</code>类型参数。它是我们正在应用的节点类型。这就是为什么compose可以与通用调用图或节点树一起使用。它始终不关心使用的节点类型。<code>Applier</code>提供操作来遍历树、插入、删除或移动节点，但它不关心这些节点的类型或它们如何最终插入。提示：<strong>这将被委托给节点本身</strong>。</p>
<p>锲约还定义了如何从当前节点中删除给定范围内的所有子节点，或移动子节点以更改它们的位置。<code>clear</code>操作定义了如何指向根并从树中删除所有节点，准备将<code>Applier</code>及其根用作将来的新组合的目标。</p>
<p><code>Applier</code> 会遍历整个树，访问和应用所有节点。可以从上到下或从下到上遍历整个树。<code>Applier</code> 一直保持对其正在访问和应用更改的当前节点的引用。<code>Composer</code> 在应用更改之前和之后调用 <code>begin</code> 和 <code>end</code> 应用更改的调用。<code>Applier</code> 提供了从上到下或从下到上插入节点的方式，并提供了向上导航（导航到当前节点的父节点）和向下导航（导航到当前节点的子节点）的方式。</p>
<h3 id="构建节点树时的性能"><a href="#构建节点树时的性能" class="headerlink" title="构建节点树时的性能"></a>构建节点树时的性能</h3><p>这里有一个从上往下或从下往上构建树的重要区别。</p>
<h4 id="自上而下地插入节点"><a href="#自上而下地插入节点" class="headerlink" title="自上而下地插入节点"></a>自上而下地插入节点</h4><p>当使用自上而下的方式构建树时，节点按其在树中的位置创建并添加到 applier 中。这意味着每个父节点都在其子节点之前添加，因此子节点可以直接引用其父节点。这是一个自然的方式来构建树，也是通常的用法。</p>
<p>在这种情况下，applier 首先遍历根节点，然后处理根节点的每个子节点。在遍历树时，每当它到达一个新节点时，它会调用开始方法，然后在处理完节点及其所有子节点后，调用结束方法。</p>
<p>自上而下的插入是一种基于深度优先搜索的算法，每当它到达叶子节点时，就开始向上回溯，直到回溯到根节点。</p>
<p>考虑以下树：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1252df63514c64d2a194f0cb74e7bffa.png" alt="在这里插入图片描述"></p>
<p>如果我们想从上到下构建这棵树，我们会先将B插入到R中，然后将A插入到B中，最后将C插入到B中。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7376b688e94e92453173318bb421c946.png" alt="在这里插入图片描述"></p>
<h4 id="自下而上地插入节点"><a href="#自下而上地插入节点" class="headerlink" title="自下而上地插入节点"></a>自下而上地插入节点</h4><p>从下往上构建树，首先将A和C插入到B中，然后将B树插入到R中。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3188623eced41062ef96d800e68dc6f2.png" alt="在这里插入图片描述"><br>使用自上而下或自下而上方式构建树的性能可能会有很大差异。这个决定取决于所使用的Applier实现，通常取决于每次插入新子节点时需要通知的节点数量。想象一下，我们要用Compose表示的图形需要在每次插入节点时通知所有祖先节点。在自上而下的构建中，每次插入都可能会通知多个节点（父节点，父节点的父节点…等）。随着每个新层级的插入，这个计数将呈指数级增长。相比之下，如果改为自下而上，您仍然只需要通知直接父节点，因为父节点仍未附加到树上。但如果我们的策略是通知所有子节点，那么情况可能就会反过来。因此，这取决于我们要表示的树以及如何将更改通知到树的顶部或底部。这里唯一关键的一点是选择一种插入策略，而不是两种都选。</p>
<h3 id="如何应用更改"><a href="#如何应用更改" class="headerlink" title="如何应用更改"></a>如何应用更改</h3><p>正如我们之前所述，客户端库提供Applier接口的实现，其中一个示例是<code>UiApplier</code>，用于Android UI。我们可以使用它作为完美的例子来说明“应用节点”是什么以及在这种特定用例中如何生成我们可以在屏幕上看到的组件。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1d10a9f8d71e38acfe4f420db5045072.png" alt="在这里插入图片描述"><br>我们可以看到的第一件事是，泛型类型 <code>N</code> 被固定为 <code>LayoutNode</code>。这是 <code>Compose UI</code> 选择用来表示将呈现的 UI 节点的节点类型。</p>
<p>接下来我们注意到的是它继承了 <code>AbstractApplier</code> 类。这是一个默认实现，它在一个堆栈中存储已访问的节点。每当访问树的下一个节点时，它都会将其添加到堆栈中，每当访问者向上移动时，它将从堆栈顶部删除最后一个访问的节点。这通常是applier之间共用的逻辑，因此将其放在一个共同的父类中是一个好主意。</p>
<p>我们还可以看到在 <code>UiApplier</code> 中 <code>insertTopDown</code> 方法被忽略了，因为<strong>在 Android 中，插入操作将会是自下而上的</strong>。正如我们之前所说，选择一种策略而非两者同时使用非常重要。在这种情况下，自下而上会更为合适，以避免在插入新子节点时出现重复通知。关于性能方面的差异我们之前也已经解释过了。</p>
<p>方法插入、删除或移动节点都是委托给节点本身处理的。<code>LayoutNode</code>是<code>Compose UI</code>模型化UI节点的方式，因此它知道父节点和子节点的所有信息。插入节点意味着将其附加到给定位置的新父节点中（它可以有多个子节点）。移动它本质上是重新排序其父节点的子节点列表。最后，将其删除只需将其从列表中移除。</p>
<h3 id="附加和绘制节点"><a href="#附加和绘制节点" class="headerlink" title="附加和绘制节点"></a>附加和绘制节点</h3><p>现在，我们终于能回答这个真正的问题：将一个节点插入树中（即将其附加到其父节点）是如何让它最终呈现在屏幕上的？答案是：<strong>节点知道如何附加并绘制自己</strong>。</p>
<p><strong>LayoutNode</strong>（布局节点）是针对 Android UI 这一具体用例选择的节点类型。当 <strong>UiApplier</strong> 实现委托将插入操作交给它时，会按照以下顺序发生事情：</p>
<ul>
<li>检查是否满足插入节点的条件。 例如：它还没有父节点。</li>
<li>无效化 <strong>Z</strong> 轴排序的子节点列表。这是一个平行列表，通过 <strong>Z</strong> 轴索引维护所有子节点的排序，以便按顺序绘制它们（较低的 <strong>Z</strong> 轴索引优先）。无效化该列表将使其在需要时重新创建（并排序）。</li>
<li>将新节点附加到其父节点和其<strong>Owner</strong>。</li>
<li><strong>Invalidate</strong> （无效化）</li>
</ul>
<p><strong>Owner</strong> 位于树的<strong>根部</strong>，实现了 <strong>Composable 树与底层 View 系统的连接</strong>。我们可以将其视为与 <strong>Android</strong> 系统的薄集成层。实际上，它是由 <strong>AndroidComposeView</strong>（一个标准 <strong>View</strong>）实现的。所有布局、绘制、输入和 accessibility 都是通过 <code>owner</code> 进行 <strong>hook</strong> 处理的。一个 <strong>LayoutNode</strong> 节点必须附加到 <strong>Owner</strong> 上才能够在屏幕上显示出来，而且它的 <code>owner</code> 必须与其父项的 <code>owner</code> 相同。<strong>Owner</strong> 也是 <strong>Compose UI</strong> 的一部分。在我们附加一个节点之后，可以通过 <strong>Owner</strong> 调用 <code>invalidate</code>，以便渲染 <strong>Composable</strong> 树。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9d369d56e61570e5d1410afc70159a46.png" alt="在这里插入图片描述"></p>
<p>最后，最终的集成点发生在<strong>Owner</strong>被设置时。这发生在我们从<code>Activity</code>、<code>Fragment</code>或<code>ComposeView</code>调用<code>setContent</code>的时候。此时，会创建一个<code>AndroidComposeView</code>，然后被附加到 <strong>View</strong> 视图层次结构中，并将其设置为 <strong>Owner</strong>，以便可以根据需要执行 <strong>invalidate</strong> 操作。</p>
<p>至此，我们终于知道 <strong>Compose UI</strong> 如何为 <strong>Android</strong> 系统实现一棵节点树。</p>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><p>我们在之前的部分中学习了许多关于 <strong>Composer</strong> 的有趣细节。我们知道它如何记录更改以读取或写入 <code>slot table</code> ，知道当组合期间 Composable 函数执行时如何发射这些更改，以及这些记录的更改最终是如何被应用的。但事实上，我们尚未提及谁负责创建组合，以及如何、何时进行组合，以及涉及哪些步骤。因此，组合是我们到目前为止缺失的一块。</p>
<p>我们曾经说过，<strong>Composer</strong> 有一个对 <strong>Composition</strong> 的引用，但这可能会让我们认为<strong>Composition</strong> 是由 <strong>Composer</strong> 创建和拥有的，实际上情况恰恰相反。当创建一个<strong>Composition</strong> 时，它自己会创建一个 <strong>Composer</strong>。<strong>Composer</strong> 通过 <code>currentComposer</code> 机制变得可访问，它将被用于创建和更新由 <strong>Composition</strong> 管理的树形结构。</p>
<p>客户端库连接到 <strong>Jetpack Compose runtime</strong> 的入口点分为<strong>两个</strong>不同的部分：</p>
<ul>
<li><strong>编写 Composable 函数</strong>：这将使它们能够发射所有相关信息，从而将我们的用例与 runtime 连接起来。</li>
<li><strong>Composable</strong> 函数很好，但如果没有 <strong>Composition</strong> 过程，它们将永远不会执行。这就是为什么需要另一个入口点：<strong><code>setContent</code></strong>。这是与目标平台的集成层，在这里会创建并启动一个<strong>Composition</strong>。</li>
</ul>
<h3 id="创建-Composition"><a href="#创建-Composition" class="headerlink" title="创建 Composition"></a>创建 Composition</h3><p>以 <strong>Android</strong> 平台为例，它是通过调用 <strong><code>ViewGroup.setContent</code></strong> 来返回一个新的 <strong>Composition：</strong></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d9fe865f8520de4647a689bb4d347551.png" alt="在这里插入图片描述"><br><strong>WrappedComposition</strong> 是一个装饰器，它知道如何将 <strong>Composition</strong> 链接到一个<strong>AndroidComposeView</strong>，以便将其直接连接到 <strong>Android View 系统</strong>。它启动受控效果来跟踪诸如键盘可见性更改或 accessibility 之类的内容，并将关于 Android <code>Context</code> 的信息以 <code>CompositionLocals</code> 的形式传输暴露给 <strong>Composition</strong> （例如：<code>Context</code>本身、配置、当前<code>LifecycleOwner</code>、当前<code>savedStateRegistryOwner</code>或Owner的View等等）。这就是为何这些内容在我们所有的<strong>Composable</strong> 函数当中是隐式可用的。</p>
<p>请注意，一个指向树的根 <strong>LayoutNode</strong> 的 <strong>UiApplier</strong> 实例被传递给了 <strong>Composition</strong> 对象。（<code>Applier</code> 是一个节点访问者，所以它从根节点开始指向）。这是我们第一次明确看到客户端库负责选择 <code>Applier</code> 的实现。</p>
<p>我们还可以看到最后调用了 <code>composition.setContent(content)</code>。<strong><code>Composition＃setContent</code></strong> 是设置 <strong>Composition</strong> 内容的方法。 （使用<code>content</code>提供的所有信息更新Composition）</p>
<p>另一个非常好的创建 <strong>Composition</strong> 的例子是 <strong>VectorPainter</strong>，它也是 <strong>Compose UI</strong> 的一部分，它用于在屏幕上绘制矢量图形。 <strong>VectorPainter</strong> 会创建并维护它自己的 <strong>Composition</strong>。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d80781ad88d7c9d0f6c73376569f32f5.png" alt="在这里插入图片描述"><br>我们将在以后更深入地探讨这个问题，以讨论Jetpack Compose的高级用例。但是我们可以在这里注意到不同的 <strong>Applier</strong> 策略是如何被选择的：一个<strong>VectorApplier</strong>，它从向量树的根节点开始指向，而这种情况下将是一个<strong>VNode</strong>。</p>
<p>最后，我们还可以在 <strong>Compose UI</strong> 中找到另一个示例，即 <strong>SubcomposeLayout</strong>。它是一种布局，它维护自己的 <strong>Composition</strong>，因此在<strong>测量</strong>阶段可以<strong>子组合</strong>其内容。当我们需要父级的测量来组合其子级时，这非常有用。</p>
<p>无论何种用例，每当创建一个<strong>Composition</strong>时，都可以传递父级 <strong>CompositionContext</strong>对象（见上文）。但请注意，它可能为 <strong>null</strong>。父上下文（如果可用）将用于将新的 <strong>Composition</strong> 以某种逻辑链接到现有的 <strong>Composition</strong>，这样 <strong>Invalidations</strong> 和 <strong>CompositionLocals</strong> 可以在不同的组合中解析，就像它们是同一个组合一样。</p>
<p>创建 <strong>Composition</strong> 时也可以传递一个 <strong>recompose context</strong>，这将是 <strong>Applier</strong> 用于应用更改并最终实现树形结构的 <strong>CoroutineContext</strong>。如果未提供，则默认值为由 <strong>Recomposer</strong> 提供的<strong>CoroutineContext</strong>，即 <strong>EmptyCoroutineContext</strong>。这意味着 <strong>Android</strong> 可能会在<strong>AndroidUiDispatcher.Main</strong> 主线程调度器上进行重组。</p>
<p>在创建 <strong>Composition</strong> 的同时，也必须记得将其<strong>销毁</strong>——即在不再需要它时调用 <code>composition.dispose()</code> 。这是同时也是其 <strong>UI</strong>（或其他用例）被销毁的时刻。我们可以说 <strong>Composition</strong> 作用域是其 <strong>owner</strong> 所有者。有时候<strong>销毁</strong>可能有点隐蔽，例如 <code>ViewGroup.setContent</code> （背后是由生命周期观察者负责销毁），但它总是存在的。</p>
<h3 id="初始组合过程"><a href="#初始组合过程" class="headerlink" title="初始组合过程"></a>初始组合过程</h3><p>每当创建一个新的 <strong>Composition</strong> 时，紧随其后的总是调用 <strong><code>composition.setContent(content)</code></strong> (参见前面的两个片段)。事实上，这就是 <strong>Composition</strong> 最初填充数据的地方（<code>slot table</code>将填充相关数据）。</p>
<p>这个调用会被委托给父级 <strong>Composition</strong> 去触发初始的 <strong>Composition</strong> 过程（记住<strong>Compositions</strong>和<strong>Subcompositions</strong>是通过父级的<strong>CompositionContext</strong>链接在一起的）。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4c7c0f6c03b516400abb95a663cc985a.png" alt="在这里插入图片描述"></p>
<p>对于 <strong>Subcompositions</strong>，<strong>parent</strong> 将是另一个 <strong>Composition</strong>。对于 <strong>root</strong> 组合，<strong>parent</strong> 将是 <strong>Recomposer</strong>。但无论如何，执行初始组合的逻辑始终依赖于 <strong>Recomposer</strong>，因为对于子组合，<code>composeInitial</code>方法的调用会被不断地委托给父组合，直到达到 <strong>root</strong> 根组合。</p>
<p>因此，对于<code>parent.composeInitial(composition, content)</code>的调用可以转换为<code>recomposer.composeInitial(composition, content)</code>，它在此处执行了几件重要的事情来填充初始的 <strong>Composition</strong>：</p>
<ul>
<li>获取所有 <strong>State</strong> 对象当前值的<strong>快照</strong>。这些值将与其他快照的潜在更改隔离开来。这个快照是<strong>可变的</strong>，同时也是并发安全的。它可以安全地修改，而不影响任何其他现有的 <strong>State</strong> 快照，因为任何其他 <strong>State</strong> 对象的更改只会发生在其自身的该快照中，并且在稍后的步骤中，它将原子性的与全局共享状态同步所有这些更改。</li>
<li>可变快照中的 <strong>State</strong> 值，只有在调用 <code>snapshot.enter(block: () -&gt; T)</code> 时传递的 <code>block</code> 代码块中，才能被修改。</li>
<li>在进行快照时，<strong>Recomposer</strong> 还会传递<strong>观察者</strong>，用于观察 <strong>State</strong> 对象的读写，因此当这些操作发生时 <strong>Composition</strong> 可以获得通知。这使得 <strong>Composition</strong> 能够标记受影响的重组范围为已使用，这将在适当的时候使它们重新组合。</li>
<li>进入快照 <code>snapshot.enter(block)</code> 即通过传递以下<code>block</code>执行快照：<code>composition.composeContent(content)</code>。这是<strong>组合实际发生的地方</strong>。进入快照的含义是让 <strong>Recomposer</strong> 知道在组合期间读写任何 <strong>State</strong> 对象都将被跟踪（通知给<strong>Composition</strong>）。</li>
<li>这个步骤将组合过程委托给了 <strong>Composer</strong>。下面会更详细地介绍这个步骤。</li>
<li>当组合完成后，任何对 <strong>State</strong> 对象的更改都只会应用于当前 <strong>State 的快照</strong> ，因此接下来就是将这些更改传播到全局状态，这是通过<code>snapshot.apply()</code>实现的。</li>
</ul>
<p>这是关于 Compose 中初始 Composition 的大致顺序。<a target="_blank" rel="noopener" href="https://blog.csdn.net/lyabc123456/article/details/129192937">所有关于状态快照系统的内容将在以后详细展开。</a></p>
<p>现在，让我们详细说明实际的 <strong>Composition</strong> 过程本身，这个过程委托给了 <strong>Composer</strong>。以下是大致的过程。</p>
<ul>
<li>如果 <strong>Composition</strong> 已经在运行，就不能再启动了。在这种情况下，会抛出异常并丢弃新的<strong>Composition</strong>。不支持重入式<strong>Composition</strong>。</li>
<li>如果存在任何挂起的失效 ，它会将这些复制到由 <strong>Composer</strong> 维护的无效列表中，以等待无效化的 <strong>RecomposeScopes</strong>。</li>
<li>将标志<code>isComposing</code>设置为<code>true</code>，因为 <strong>Composition</strong> 即将开始。</li>
<li>调用<code>startRoot()</code>来启动<strong>Composition</strong>，这将在<code>slot table</code>中启动 <strong>Composition</strong> 的 <code>root group</code> 并初始化其他所需的字段和结构。</li>
<li>调用<code>startGroup</code>来为<code>slot table</code>中的内容启动一个组。</li>
<li>调用 <code>content</code> <strong>lambda</strong> 以发出所有更改。</li>
<li>调用 <code>endGroup</code> 以结束 <code>slot table</code> 中的组。</li>
<li>调用 <code>endRoot()</code> 以结束 <strong>Composition</strong>。</li>
<li>将标志 <code>isComposing</code> 设置为 <code>false</code>，因为 <strong>Composition</strong> 已完成。</li>
<li>清除维护临时数据的其他结构。</li>
</ul>
<h3 id="在初始组合后应用更改"><a href="#在初始组合后应用更改" class="headerlink" title="在初始组合后应用更改"></a>在初始组合后应用更改</h3><p>在初始组合之后，会调用 <code>composition.applyChanges()</code> 通知 <code>Applier</code> 应用在该过程中记录的所有更改。<strong>Composition</strong> 也会调用 <code>applier.onBeginChanges()</code>，遍历所有更改，并将所需的 <code>Applier</code> 和<code>SlotWriter</code> 实例传递给每个更改。最后，在所有更改都应用后，它会调用<code>applier.onEndChanges()</code>。</p>
<p>在此之后，<strong>Compose</strong> 会分发所有已注册的 <strong>RememberedObservers</strong>，这样任何实现 <strong>RememberObserver</strong> 接口的类都可以在进入或离开 <strong>Composition</strong> 时得到通知。例如，<code>LaunchedEffect</code> 或 <code>DisposableEffect</code> 都实现了该接口，因此它们可以将副作用限制在 <strong>Composable</strong> 的组合的生命周期内。</p>
<p>在此之后，所有的 <code>SideEffect</code> 都按照它们被记录的顺序依次触发。</p>
<h3 id="关于组合的附加信息"><a href="#关于组合的附加信息" class="headerlink" title="关于组合的附加信息"></a>关于组合的附加信息</h3><p><strong>Composition</strong> 能感知到重组时挂起的无效操作，并且也知道自己是否正在进行组合。这个信息可以用于立即应用无效性（当它正在组合时），否则就推迟应用它们。当正在进行组合时，<strong>Recomposer</strong> 也可以利用这个信息来跳过重组。</p>
<p>runtime 依赖于 <strong>Composition</strong> 的一种变体：<strong>ControlledComposition</strong> ，它添加了一些额外的功能，以便可以从外部控制它。这样，<strong>Recomposer</strong> 可以协调无效性和进一步的重组。<code>composeContent</code> 或 <code>recompose</code> 等函数就是很好的例子。如果需要的话，<strong>Recomposer</strong> 可以在组合中触发这些操作。</p>
<p><strong>Composition</strong> 提供了一种方法来检测是否正在观察一组对象，以便在这些对象变化时强制重组。 例如，<strong>Recomposer</strong> 在父组合中的 <strong>CompositionLocal</strong> 变化时，可以使用此功能强制在子组合中进行重组。记住，在这种情况下，<strong>Compositions</strong> 是通过父元素 <strong>CompositionContext</strong> 来连接的。</p>
<p>有时候在组合期间会发现错误，这种情况下可以终止组合，这基本上会重置<strong>Composer</strong>及其所有引用、堆栈和其他一切。</p>
<p><strong>Composer</strong> 在不插入、重用任何东西，也没有无效操作提供者（无效会导致重组）的情况下，假定它正在跳过重组。并且当前的 <code>currentRecomposeScope</code>不需要重组。</p>
<h3 id="Recomposer"><a href="#Recomposer" class="headerlink" title="Recomposer"></a>Recomposer</h3><p>我们已经知道了初始组合是如何进行的，并且了解了一些关于<strong>RecomposeScopes</strong>和失效（invalidation）的知识。但是，我们仍然几乎不知道<strong>Recomposer</strong>实际上是如何工作的。它是如何创建的，何时开始运行？它是如何开始监听失效以自动触发重组的？</p>
<p><strong>Recomposer</strong> 控制 <strong>ControlledComposition</strong>，并在需要时触发重组来最终应用更新。它还确定要在哪个线程上进行组合或重组，以及要用于应用更改的线程。</p>
<h3 id="创建-Recomposer"><a href="#创建-Recomposer" class="headerlink" title="创建 Recomposer"></a>创建 Recomposer</h3><p>客户端库进入Jetpack Compose的入口是创建一个<strong>Composition</strong>并在其上调用<code>setContent</code>（参见上面的“创建Composition”部分）。在创建<strong>Composition</strong>时需要为其提供 <code>parent</code>。由于 <strong>root</strong> Composition 的父级是<strong>Recomposer</strong>，因此这也是创建它的时刻。</p>
<p>这个入口是平台和 <strong>Compose runtime</strong> 之间的连接，并且是由客户端提供的代码。在 <strong>Android</strong> 平台中，客户端就是指 <strong>Compose UI</strong> 库。该库创建一个 <strong>Composition</strong>（内部创建其自己的<strong>Composer</strong>），以及一个<strong>Recomposer</strong>用作其父级。</p>
<blockquote>
<p>请注意，正如我们之前了解的那样，每个平台的每个潜在用例都可能创建自己的 <strong>Composition</strong>，同样，它也可能创建自己的 <strong>Recomposer</strong>。</p>
</blockquote>
<p>当我们想要在 <strong>Android</strong> 的 <strong>ViewGroups</strong> 中使用 <strong>Compose</strong> 时，我们调用 <strong><code>ViewGroup.setContent</code></strong> 方法，最终在一些间接操作之后，会将 <strong>parent context</strong> 的创建委派给一个 <strong>Recomposer</strong> 工厂：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9634bf582e251b7703c876acf7668cba.png" alt="在这里插入图片描述"></p>
<p>该工厂为当前窗口创建一个 <strong>Recomposer</strong>。我认为创建过程非常有趣，可以探索 Android 如何解决与 Compose 的集成。</p>
<p>调用 <code>createRecomposer</code> 需要传递对根视图的引用，因为创建的 <strong>Recomposer</strong> 将具有生命周期感知能力，这意味着它将链接到 <strong>View</strong> 视图树的根部的 <strong>ViewTreeLifecycleOwner</strong>。这将允许在View 视图树被 <strong>unattached</strong> 时取消（关闭）<strong>Recomposer</strong>，例如，这对于避免泄漏重组过程非常重要。此过程将被建模为一个挂起函数，否则可能会泄漏。</p>
<blockquote>
<p>接下来讲述Compose UI的情况：在Compose UI中，UI上发生的所有事情都是使用<code>AndroidUiDispatcher</code>协调&#x2F;调度的，因此它与一个<code>Choreographer</code>实例和一个用于主线程<code>Looper</code>的<code>handler</code>相关联。此调度程序在处理程序回调或<code>Choreographer</code>的动画帧阶段期间执行事件分派，以先到者为准。它还有一个关联的<code>MonotonicFrameClock</code>，使用<code>suspend</code>来协调帧渲染。这是Compose中驱动整个UX的部分，像动画这样的东西非常依赖它以实现与系统帧同步的平滑体验。</p>
</blockquote>
<p>工厂函数的第一件事是创建一个<strong>PausableMonotonicFrameClock</strong>。这是<strong>AndroidUiDispatcher</strong>单调时钟的包装器，它添加了对手动暂停<code>withFrameNanos</code>事件的支持，直到它被恢复。这使得它非常适用于在特定时间段内<strong>不应该生成帧的情况</strong>，例如，当托管 UI 的窗口不再可见时。</p>
<p>任何<strong>MonotonicFrameClock</strong>也是一个<strong>CoroutineContext.Element</strong>，这意味着它可以与其他<strong>CoroutineContexts</strong>组合使用。</p>
<p>在实例化 <strong>Recomposer</strong> 时，我们必须为其提供 <strong>CoroutineContext</strong>。此上下文是使用<strong>AndroidUiDispatcher</strong>的当前线程上下文和刚刚创建的可暂停帧时钟的组合创建的。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a73cefa6a60760a3a977dc2e1c9f9763.png" alt="在这里插入图片描述"></p>
<p>这个组合上下文将被 <strong>Recomposer</strong> 用于创建一个内部 <strong>Job</strong>，以确保在关闭 <strong>Recomposer</strong> 时可以取消所有组合或重组的效果。例如，当Android窗口被销毁或<strong>unattached</strong>时，将需要此操作。<strong>该上下文将用于在组合&#x2F;重组之后应用更改</strong>，并且将是<code>LaunchedEffect</code>使用的默认上下文，以运行副作用。这使得副作用会在我们用于应用更改的相同线程中启动，在Android中通常是主线程。当然，我们始终可以在我们的副作用中随意跳出主线程。</p>
<blockquote>
<p>所有副作用处理程序都是可组合函数，因此会发出记录的更改。<code>LaunchedEffect</code>实际会被记录并在需要时写入<code>slot table</code>，因此它是可感知<strong>Composition</strong>生命周期的，不像 <code>SideEffect</code>。</p>
</blockquote>
<p>最后，使用相同的 <strong>combined context</strong> 创建了一个协程作用域：即 <code>val runRecomposeScope = CoroutineScope(contextWithClock)</code>。这个作用域将用于启动重组作业（一个挂起函数），它将等待失效并相应地触发重组。让我们来瞅一眼代码：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d2a6f0e648e7d9b320a46068c94fbfd1.png" alt="在这里插入图片描述"></p>
<p>这里一个观察者被添加到视图树的生命周期上，并且它使用 <code>pausableClock</code> 在视图树为 <code>started</code> 和 <code>stopped</code> 状态时进行恢复和暂停事件分发。它还会在<code>onDestroy</code>时关闭（取消）<strong>Recomposer</strong>，并在<code>onCreate</code>时启动重组作业。</p>
<p>重组作业是由 <code>recomposer.runRecomposeAndApplyChanges()</code> 启动的，它就是前面提到的挂起函数，它将等待任何相关 <strong>Composers</strong>（及其 <strong>RecomposeScopes</strong>）的失效，重组它们，最终将新更改应用于它们关联的 <strong>Composition</strong>。</p>
<p>这个工厂函数展示了<strong>Compose UI</strong>如何生成与<strong>Android</strong>生命周期相连的<strong>Recomposer</strong>。它很好地展示了<strong>Recomposer</strong>和<strong>Composition</strong>在与平台进行集成时的创建方式。 我们再次复习一下如何在设置<strong>ViewGroups</strong>的内容时创建<strong>Composition</strong>：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/360732e1378b9712049d7b8ef123109e.png" alt="在这里插入图片描述"><br>这里的 <code>parent</code> 将是一个 <strong>Recomposer</strong>，并且将由<code>setContent</code>的调用方（对于此用例来说是<code>AbstractComposeView</code>）提供。</p>
<h3 id="重组过程"><a href="#重组过程" class="headerlink" title="重组过程"></a>重组过程</h3><p><code>recomposer.runRecomposeAndApplyChanges()</code> 函数被调用以开始等待无效化并在发生无效化时自动重新组合。让我们探索学习所涉及的不同步骤。</p>
<p>在之前的部分中，我们学习了 <strong>snapshot State</strong> 如何在其自己的快照中进行修改，但稍后需要通过<code>snapshot.apply()</code>将这些更改传播到<strong>全局状态</strong>进行<strong>同步</strong>。当调用<code>recomposer.runRecomposeAndApplyChanges()</code>时，它首先注册了一个<strong>观察者</strong>来进行这种变化传播。当发生这种变化时，这个<strong>观察者</strong>会唤醒并将所有这些更改添加到快照失效列表中，这些列表将传播到所有已知的 <strong>Composer</strong>，以便它们可以记录组合的哪些部分需要重组。简单来说，<strong>这个观察者是触发状态更改时自动重组的一个跳板</strong>。</p>
<p>在注册<strong>快照应用观察者</strong>之后，<strong>Recomposer</strong> 使所有 <strong>Compositions</strong> 失效，以假设所有内容都已更改为起点。在此之前发生的任何更改都没有被跟踪，因此这是从头开始的方法。然后，它会暂停，直到有工作可用于重组。 “有可用工作” 意味着有任何未处理的 <strong>State</strong> 快照失效或来自 <strong>RecomposeScopes</strong> 作用域的组合失效。</p>
<p>接下来 <strong>Recomposer</strong> 会使用创建它时提供的单调时钟，并调用<code>parentFrameClock.withFrameNanos &#123;&#125;</code>来等待下一帧。从这里开始的剩余工作都将在那一刻完成（而不是之前）。这样做的目的是将更改聚合到帧中。</p>
<p>在这个块中，<strong>Recomposer</strong> 首先为任何潜在的等待器(比如动画)分派单调的时钟帧。这可能会产生新的失效结果，也需要进行跟踪(例如在动画结束时切换一个有条件的Composable)。</p>
<p>现在是真正行动的时候了。<strong>Recomposer</strong> 获取所有 <strong>挂起的快照失效</strong>，换句话说，自上次调用重组以来修改的所有 <strong>State</strong> 值，并将所有这些更改记录在 <strong>Composer</strong> 中作为挂起的重组。</p>
<p>还可以通过 <strong><code>composition.invalidate()</code></strong> 使 <strong>composition</strong> 失效，例如当一个<strong>State</strong>被写入Composable lambda 时。对于其中的每一个，<strong>Recomposer</strong> 都会执行重组(下面将对此进行讨论)，并将其添加到待应用更改的<strong>composition</strong>列表中。</p>
<p>重组意味着重新计算组合状态(<code>slot table</code>)和构建树(<code>Applier</code>) 。重新组合将重用所有这些代码，因此没有必要重复流程遵循的所有步骤。</p>
<p>之后，它会发现由于组合的值更改而需要组合的潜在跟踪重组，并安排它们进行重组。例如，如果一个父组合中的 <code>CompositionLocal</code> 发生变化，并在子组合中读取。</p>
<p>最后，它遍历所有要应用更改的 <strong>Compositions</strong>，并对它们调用 <code>composition.applyChanges()</code>。之后，它更新 <strong>Recomposer</strong> 的状态。</p>
<h3 id="并发重组"><a href="#并发重组" class="headerlink" title="并发重组"></a>并发重组</h3><p><strong>Recomposer</strong>具有并发执行重组的能力，即使 Compose UI 没有使用这个特性。不过，任何其他客户端库都可以根据需要依赖它。</p>
<p><strong>Recomposer</strong> 提供了 <strong><code>runRecomposeAndApplyChanges</code></strong> 函数的并发对应物，称为 <strong><code>runRecomposeConcurrentlyAndApplyChanges</code></strong>。这是另一个用于等待状态快照失效并像前者那样触发自动重组的挂起函数，但唯一的区别是后者将在外部提供的<code>CoroutineContext</code>中的执行失效组合的重组：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/24da0de3fe1a32e8fe0bc583ba6e9c52.png" alt="在这里插入图片描述"></p>
<p>这个挂起函数使用传递的上下文创建自己的<code>CoroutineScope</code>，并使用它来生成和协调所有为并发重组而创建的所有 <strong>child jobs</strong> 。</p>
<h3 id="Recomposer-状态"><a href="#Recomposer-状态" class="headerlink" title="Recomposer 状态"></a>Recomposer 状态</h3><p><strong>Recomposer</strong> 在其生命周期中会切换一系列状态：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7e634fa2159beb4ab24ba47906b32f2c.png" alt="在这里插入图片描述"><br>下面是这些状态的含义：</p>
<ul>
<li><strong>ShutDown</strong>：Recomposer 被取消，清理工作完成。不能再使用。</li>
<li><strong>ShuttingDown</strong>：Recomposer 已被取消，但仍在清理过程中。不能再使用。</li>
<li><strong>Inactive</strong>：Recomposer 将忽略来自 Composers 的无效，并且不会触发重组。必须调用<code>runRecomposeAndApplyChanges</code>来开始监听。这是 Recomposer 创建后的初始状态。</li>
<li><strong>InactivePendingWork</strong>：有可能 Recomposer 是不活动的，但已经有一些等待帧的挂起效果。帧将在 Recomposer 开始运行时立即生成。</li>
<li><strong>Idle</strong>：Recomposer 正在跟踪组合和快照失效，但目前没有工作要做。</li>
<li><strong>PendingWork</strong>：Recomposer 已经收到了待完成工作的通知，并且已经在执行它或等待执行它的机会。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>存储 <code>Composition</code> 的内存数据结构有两种 <code>slot table</code> 和 <code>change list</code></strong></p>
<ul>
<li><strong><code>slot table</code>（插槽表）是一个为快速线性访问而优化的内存结构，<code>runtime</code> 使用它来存储组合的当前状态。它在初始组合时填充数据，并在每次重新组合时更新。</strong></li>
<li><strong><code>change list</code> 则是对节点树进行实际更改的内容。每次 <code>Composable</code> 函数的状态发生更改时，对应的更改操作会被添加到 <code>change list</code> 中。它可以理解为一个补丁文件，一旦应用，它就会更新树。所有要执行的更改都会先被记录，然后再被应用。</strong></li>
</ul>
</li>
<li><p><strong><code>slot table</code> 将数据存储在两个线性数组中。其中一个保存关于<code>Composition</code>中可用的 <code>group</code> 的信息，另一个存储属于每个 <code>group</code> 的插槽（<code>slot</code>）。</strong></p>
<ul>
<li><strong>存储 <code>groups</code> 的数组实际上是一种 <code>group</code> 树的线性表达方式。</strong></li>
<li><strong><code>slots</code> 数组存储 <code>groups</code> 数组中的每一个 <code>group</code> 的相关数据。这是实际 <code>Composition</code> 组合数据存储的地方。</strong></li>
</ul>
</li>
<li><p><strong><code>slot table</code>基于 “<code>Gap buffer</code>”（间隙缓冲区）的思想。<code>Gap</code> 可以看成一系列连续的位置，并且可以移动。当需要插入新数据时，<code>gap</code> 可以保证移动的数据量会被最小化。</strong></p>
<ul>
<li><p><strong><code>slot table</code> 使用 <code>SlotReader</code>和<code>SlotWriter</code> 进行读写。表可以同时有多个活动的 <code>Reader</code>，但只能有一个活动的<code>Writer</code>，只有在表未被写入时才能够从中读取。</strong> <strong><code>Reader</code> 被用来从数组中读取有关<code>group</code>和它们的<code>slot</code>的信息。<code>Writer</code> 能够添加、替换、移动和删除 <code>groups</code> 和 <code>slots</code>。读写操作结束后，<code>Reader</code>或<code>Writer</code>都会被关闭。</strong></p>
</li>
<li><p><strong><code>Gap</code>可以想象成一个可滑动可调整大小的线性数组区间，<code>Writer</code> 维护着每个<code>Gap</code>的起始位置、结束位置和长度，它可以通过更新起始位置和结束位置来移动<code>Gap</code>的位置。</strong></p>
</li>
</ul>
</li>
<li><p><strong><code>change list</code> 最终是对 <code>slot table</code> 进行更改的。<code>change list</code> 就是延迟执行的 <code>lambdas</code>，它们从 <code>slot table</code> 中添加、删除、替换或移动节点，并通知 <code>Applier</code> 更新实例化的节点树。组合完成之后，<code>Applier</code> 就会批量的应用它们。</strong></p>
</li>
<li><p><strong><code>ReusableComposeNode</code>：</strong></p>
<ul>
<li><p><strong><code>Layout</code> 使用 <code>ReusableComposeNode</code> 来将 <code>LayoutNode</code> 发射到组合中。它不是立即创建并添加节点，只是在告知 <code>runtime</code> 如何在组合的当前位置创建、初始化和插入节点。</strong></p>
</li>
<li><p><strong><code>ReusableComposeNode</code> 将一切委托给<code>currentComposer</code>实例。会启动一个可替换的<code>group</code>，以便在存储时来包装Composable的内容。<code>remember</code> Composable 函数使用 <code>currentComposer</code> 来将用户提供的lambda返回值 缓存（记住）到 Composition 中。缓存测量是首先会在 <code>slot table</code> 中查找这个值。如果未找到，它就会计划安排一次对该值更新操作，找到就返回。</strong></p>
</li>
</ul>
</li>
<li><p><strong>重组作用域：</strong></p>
<ul>
<li><strong>每次创建一个重启的 <code>group</code>时，<code>Composer</code>都会为其创建一个<code>RecomposeScope</code>，并将其设置为 <code>Composition</code> 的 <code>currentRecomposeScope</code>。</strong></li>
<li><strong><code>RecomposeScope</code>对组合的一个区域进行建模，它可用于手动使可组合对象失效和触发重新组合。失效是通过<code>composer</code>请求的，如 <code>composer.currentRecomposeScope().invalidate()</code> 。</strong></li>
<li><strong><code>Composer</code>维护所有已失效的重组作用域的堆栈。只有当 Compose 发现 <code>Composable</code> 从它的 <code>State</code> 快照中执行读操作时，<code>Composer</code> 才会启用 <code>RecomposeScope</code>。（<code>Composer</code>具有对当前快照的引用）</strong></li>
</ul>
</li>
<li><p><strong><code>Applier</code></strong>：</p>
<ul>
<li><p><strong><code>Composer</code> 将组合后记录的所有更改的应用委托给 <code>Applier</code>。<code>Applier</code> 执行<code>Changes</code>列表，并更新<code>slot table</code>。<code>runtime</code> 不关心 <code>Applier</code> 具体的实现，它只依赖抽象的 <code>Applier</code> 接口契约。</strong></p>
</li>
<li><p><strong><code>Applier</code> 会遍历整个树，访问和应用所有节点。<code>Applier</code> 提供了两种插入节点的方式：自上而下地插入节点 和 自下而上地插入节点。这二者的性能差异在于：每次插入新的节点时，是想通知其所有的父节点还是其所有的子节点。只能选择一种插入策略，而不是两种都选。</strong></p>
</li>
<li><p><strong><code>Applier</code> 在 <code>Android</code> 平台的实现是 <code>UiApplier</code>，此时它的节点的泛型类型被固定为 <code>LayoutNode</code>，这是 <code>Compose UI</code> 选择用来表示将呈现的 <code>UI</code> 节点的节点类型。在 <code>Android</code> 平台采用的插入策略是自下而上。具体的插入、删除或移动节点都是委托给<code>LayoutNode</code>节点本身处理的。</strong></p>
</li>
</ul>
</li>
<li><p><strong><code>Owner</code>：</strong></p>
<ul>
<li><strong><code>Owner</code> 位于<code>LayoutNode</code>树的根部，实现了 <code>Composable</code> 树与底层 <code>View</code> 系统的连接。它是由 <code>AndroidComposeView</code>（一个标准 View）实现的。</strong></li>
<li><strong>所有布局、绘制、输入和 accessibility 都是通过 <code>Owner</code> 进行 <code>hook</code> 处理的。</strong></li>
<li><strong>一个 <code>LayoutNode</code> 节点必须附加到 <code>Owner</code> 上才能够在屏幕上显示出来，而且它的 <code>owner</code> 必须与其父项的 <code>owner</code> 相同。</strong></li>
<li><strong>通过 <code>Owner</code> 调用 <code>invalidate</code>，就可以渲染 Composable 树。</strong></li>
<li><strong><code>Owner</code>被设置的时机是：从<code>Activity、Fragment</code>或<code>ComposeView</code>调用<code>setContent</code>的时候。此时，会创建一个<code>AndroidComposeView</code>，将其附加到 <code>View</code> 视图树中，并将其设置为 <code>Owner</code>。</strong></li>
</ul>
</li>
<li><p><strong><code>Composition</code>：</strong></p>
<ul>
<li><p><strong><code>Composer</code> 会持有一个对 <code>Composition</code> 的引用，但是 <code>Composer</code> 是被 <code>Composition</code> 创建时自己创建的。</strong></p>
</li>
<li><p><strong><code>Composition</code> 创建的时机：在 Android 平台中，它是通过调用 <code>ViewGroup.setContent</code> 来返回一个新的 <code>Composition</code>。</strong></p>
</li>
<li><p><strong>在创建 <code>Composition</code> 对象时，会传入一个指向树的根节点 <code>LayoutNode</code> 的 <code>UiApplier</code> 实例。（Applier 是从根节点开始访问节点树的）</strong></p>
</li>
<li><p><strong><code>Composition#setContent</code> 是设置 <code>Composition</code> 内容的方法。每次在创建 <code>Composition</code> 对象后紧随其后的都会调用这个方法。这个调用会被委托给父级 <code>Composition</code> 去触发初始的 <code>Composition</code> 过程。</strong></p>
</li>
<li><p><strong>每当创建一个<code>Composition</code>时，都可以传递父级 <code>CompositionContext</code>对象，它可以将新的 <code>Composition</code> 以某种逻辑链接到现有的 <code>Composition</code>。其作用是将子组合和父组合连接到一起（作为树）。<code>Composition</code>本身也作为一个<code>group</code>被写入到<code>slot table</code> 中。</strong></p>
</li>
<li><p><strong>创建 <code>Composition</code> 时也可以传递一个 <code>recompose context</code>，它是 <code>Applier</code> 用于应用更改并最终实现树形结构的 <code>CoroutineContext</code>。默认值为由 <code>Recomposer</code> 提供的 <code>EmptyCoroutineContext</code>（可能在<code>AndroidUiDispatcher.Main</code> 主线程上调度重组）</strong></p>
</li>
<li><p><strong><code>Composition</code> 的销毁：通过调用 <code>composition.dispose()</code>。在Android平台它是通过生命周期观察者在背后隐式的调用的。</strong></p>
</li>
</ul>
</li>
<li><p><strong>初始组合：</strong></p>
<ul>
<li><p><strong>初始组合的执行逻辑始终依赖于 <code>Recomposer</code>：因为对于子组合，<code>composeInitial</code>方法的调用会被不断地委托给父组合，直到达到 <code>root</code> 根组合。对于 <code>Subcompositions</code>，<code>parent</code> 将是另一个 <code>Composition</code>。而对于 <code>root</code> 组合，<code>parent</code> 就是 <code>Recomposer</code>。</strong></p>
</li>
<li><p><strong>在初始组合之后，会调用 <code>composition.applyChanges()</code> 通知 <code>Applier</code> 应用在该过程中记录的所有更改。</strong></p>
</li>
</ul>
</li>
<li><p><strong><code>Recomposer</code> 的创建时机：</strong></p>
<ul>
<li><strong>在 Android 的 <code>ViewGroups</code> 中使用 Compose 时，我们调用 <code>ViewGroup.setContent</code> 方法，最终在一些间接操作之后，会将 <code>parent</code> context 的创建委派给一个 <code>Recomposer</code> 工厂。</strong></li>
<li><strong>该工厂为当前窗口创建一个 <code>Recomposer</code>，并传递对根视图的引用，因为 <code>Recomposer</code> 需要通过 View 视图树的根部的 <code>ViewTreeLifecycleOwner</code> 来获得生命周期感知能力。</strong></li>
<li><strong>实例化 <code>Recomposer</code> 时，需要提供 <code>CoroutineContext</code>，它包含了<code>AndroidUiDispatcher</code>的当前线程上下文和单调时钟。</strong> <strong>该上下文将被 <code>Recomposer</code> 用于创建一个内部 <code>Job</code>，以确保在关闭 <code>Recomposer</code> 时可以取消所有组合或重组的效果。例如，当Android窗口被销毁或unattached时，将需要此操作。它同时是<code>LaunchedEffect</code>使用的默认上下文。同时该上下文会创建协程作用域来启动重组Job，以等待失效并触发重组。</strong></li>
</ul>
</li>
<li><p><strong>重组过程：</strong></p>
<ul>
<li><strong>重组作业是由 <code>recomposer.runRecomposeAndApplyChanges()</code>启动的。</strong></li>
<li><strong><code>Recomposer</code>通过向视图树注册一个生命周期观察者，它在 <code>started</code> 和 <code>stopped</code> 状态时进行恢复和暂停事件分发。这个观察者还会在<code>onDestroy</code>时关闭 <code>Recomposer</code>，并在<code>onCreate</code>时启动重组作业。</strong></li>
<li><strong><code>Recomposer</code>通过注册快照应用观察者来获取所有挂起的快照失效，遍历所有要应用更改的 <code>Compositions</code>，并对它们调用 <code>composition.applyChanges()</code>。</strong></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime/">https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20UI/" title="Compose UI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose UI</div></div><div class="info-2"><div class="info-item-1">通过 Compose runtime 集成 UICompose UI 是一个 Kotlin 多平台框架。它提供了通过可组合函数发出 UI 的构建块和机制。除此之外，这个库还包括 Android 和 Desktop 源代码，为 Android 和 Desktop 提供集成层。  JetBrains积极维护Desktop代码库，而Google维护Android和通用代码库。Android和Desktop源代码库都依赖于通用源代码库。到目前为止，Web还没有出现在Compose UI中，因为它是使用DOM构建的。  当使用 Compose runtime 集成 UI 时，目标是构建用户可以在屏幕上体验的布局树。这个树是通过执行发出 UI 的 Composable 函数来创建和更新的。用于树的节点类型只有 Compose UI 知道，所以 Compose runtime 可以不知道它。即使 Compose UI 本身已经是一个Kotlin多平台框架，它的节点类型到目前为止只被 Android 和 Desktop 支持。其他库，如 Compose for Web...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime%20%E9%AB%98%E7%BA%A7%E7%94%A8%E4%BE%8B/" title="Compose runtime 高级用例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Compose runtime 高级用例</div></div><div class="info-2"><div class="info-item-1">Compose runtime vs Compose UI在深入讨论之前，非常重要的一点是要区分 Compose UI 和 Compose runtime。Compose UI 是 Android 的新 UI 工具包，具有 LayoutNodes 的树形结构，它们稍后在画布上绘制其内容。Compose runtime 提供底层机制和许多状态&#x2F;组合相关的原语。 随着 Compose 编译器 支持完整的 Kotlin 平台谱系，现在可以在几乎任何地方（只要它运行Kotlin）使用 runtime来管理 UI 或任何其他树形结构。注意“其他树形结构”部分：Compose runtime 中几乎没有直接提到 UI（或Android）。虽然该运行时肯定是为了支持该用例而创建和优化的，但它仍然足够通用，可以构建任何类型的树结构。事实上，它在这方面与 React JS 非常相似，React JS 的主要用途是在 Web上创建 UI，但它在合成器或 3D 渲染器等领域找到了更广泛的用途。大多数自定义渲染器重用 React...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#slot-table-%E5%92%8C-change-list"><span class="toc-number">1.</span> <span class="toc-text">slot table 和 change list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slot-table-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">slot table 深入了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#change-list"><span class="toc-number">3.</span> <span class="toc-text">change list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%96%82-Composer"><span class="toc-number">4.</span> <span class="toc-text">投喂 Composer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%9B%B4%E6%94%B9%E8%BF%9B%E8%A1%8C%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.</span> <span class="toc-text">对更改进行建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%86%99%E5%85%A5%E6%97%B6%E9%97%B4"><span class="toc-number">6.</span> <span class="toc-text">优化写入时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99-groups"><span class="toc-number">7.</span> <span class="toc-text">读写 groups</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%80%BC"><span class="toc-number">8.</span> <span class="toc-text">记忆值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.</span> <span class="toc-text">重组作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composer-%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">Composer 中的副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8CompositionLocals"><span class="toc-number">11.</span> <span class="toc-text">存储CompositionLocals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%BA%90%E4%BF%A1%E6%81%AF"><span class="toc-number">12.</span> <span class="toc-text">存储源信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-CompositionContext-%E9%93%BE%E6%8E%A5-Compositions"><span class="toc-number">13.</span> <span class="toc-text">通过 CompositionContext 链接 Compositions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8DState%E5%BF%AB%E7%85%A7"><span class="toc-number">14.</span> <span class="toc-text">访问当前State快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%AF%BC%E8%88%AA"><span class="toc-number">15.</span> <span class="toc-text">节点导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E8%AF%BB%E5%86%99%E5%90%8C%E6%AD%A5"><span class="toc-number">16.</span> <span class="toc-text">保持读写同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%94%B9"><span class="toc-number">17.</span> <span class="toc-text">应用更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%8A%82%E7%82%B9%E6%A0%91%E6%97%B6%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">18.</span> <span class="toc-text">构建节点树时的性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%9C%B0%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">18.1.</span> <span class="toc-text">自上而下地插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%9C%B0%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">18.2.</span> <span class="toc-text">自下而上地插入节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E6%9B%B4%E6%94%B9"><span class="toc-number">19.</span> <span class="toc-text">如何应用更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%92%8C%E7%BB%98%E5%88%B6%E8%8A%82%E7%82%B9"><span class="toc-number">20.</span> <span class="toc-text">附加和绘制节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composition"><span class="toc-number">21.</span> <span class="toc-text">Composition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Composition"><span class="toc-number">22.</span> <span class="toc-text">创建 Composition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%BB%84%E5%90%88%E8%BF%87%E7%A8%8B"><span class="toc-number">23.</span> <span class="toc-text">初始组合过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%88%9D%E5%A7%8B%E7%BB%84%E5%90%88%E5%90%8E%E5%BA%94%E7%94%A8%E6%9B%B4%E6%94%B9"><span class="toc-number">24.</span> <span class="toc-text">在初始组合后应用更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%84%E5%90%88%E7%9A%84%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">25.</span> <span class="toc-text">关于组合的附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recomposer"><span class="toc-number">26.</span> <span class="toc-text">Recomposer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Recomposer"><span class="toc-number">27.</span> <span class="toc-text">创建 Recomposer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%84%E8%BF%87%E7%A8%8B"><span class="toc-number">28.</span> <span class="toc-text">重组过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%87%8D%E7%BB%84"><span class="toc-number">29.</span> <span class="toc-text">并发重组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recomposer-%E7%8A%B6%E6%80%81"><span class="toc-number">30.</span> <span class="toc-text">Recomposer 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">31.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>