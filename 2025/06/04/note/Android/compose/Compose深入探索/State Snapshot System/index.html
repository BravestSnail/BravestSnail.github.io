<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>State Snapshot System | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Jetpack Compose 有一种特殊的方式来表示状态和传播状态变化，从而驱动最终的响应式体验：状态快照系统（State snapshot system）。这种响应式模型使我们的代码更加强大和简洁，因为它允许组件根据它们的输入自动重组，并且只在必要时重组，避免了我们过去在Android View 系统中手动通知这些更改所需的所有样板文件。 什么是 Snapshot StateSnapshot">
<meta property="og:type" content="article">
<meta property="og:title" content="State Snapshot System">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/State%20Snapshot%20System/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="Jetpack Compose 有一种特殊的方式来表示状态和传播状态变化，从而驱动最终的响应式体验：状态快照系统（State snapshot system）。这种响应式模型使我们的代码更加强大和简洁，因为它允许组件根据它们的输入自动重组，并且只在必要时重组，避免了我们过去在Android View 系统中手动通知这些更改所需的所有样板文件。 什么是 Snapshot StateSnapshot">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.124Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.124Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "State Snapshot System",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/State%20Snapshot%20System/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.124Z",
  "dateModified": "2025-06-04T12:46:35.124Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/State%20Snapshot%20System/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'State Snapshot System',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">State Snapshot System</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">State Snapshot System</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.124Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.124Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Jetpack Compose 有一种特殊的方式来表示状态和传播状态变化，从而驱动最终的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%93%8D%E5%BA%94%E5%BC%8F&spm=1001.2101.3001.7020">响应式</a>体验：<strong>状态快照系统</strong>（<strong>State snapshot system</strong>）。这种响应式模型使我们的代码更加强大和简洁，因为它允许组件根据它们的输入自动重组，并且只在必要时重组，避免了我们过去在Android View 系统中手动通知这些更改所需的所有样板文件。</p>
<h3 id="什么是-Snapshot-State"><a href="#什么是-Snapshot-State" class="headerlink" title="什么是 Snapshot State"></a>什么是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Snapshot&spm=1001.2101.3001.7020">Snapshot</a> State</h3><p><strong>Snapshot state</strong>（<strong>快照状态</strong>）是指可以被记录并观察其变化的隔离状态。当我们调用像<code>mutableStateOf、mutableStateListOf、mutableStateMapOf、derivedStateOf、produceState、collectAsState</code>等函数时，我们所得到的状态就是快照状态。所有这些函数都返回某种类型的状态，开发人员经常称其为快照状态。</p>
<p>“<strong>Snapshot state</strong>” 这个术语的命名是因为它是 <strong>Jetpack Compose runtime</strong> 定义的状态快照系统的一部分。这个系统建模和协调状态变化和变化传播。它是以分离的方式编写的，因此理论上可以被其他想要依赖于可观察状态的库使用。</p>
<p>关于变化传播，我们在之前了解到的一件事情是所有 Composable 声明和表达式都会被 Jetpack Compose 编译器包装，以自动跟踪其体内的任何快照状态读取。这就是快照状态如何被（自动）观察的方式。目标是每当 Composable 读取的状态发生变化时，runtime 就会使其 <strong>RecomposeScope</strong> 失效，以便在下一次重组时再次执行它。</p>
<p>这是由 Compose 提供的基础设施代码，因此它不需要存在于任何<strong>客户端代码库</strong>中。<strong>runtime</strong> 的客户端，如 <strong>Compose UI</strong>，可以完全不需要了解失效和状态传播的方式，或者如何触发重组，而只需要关注提供与该状态配合使用的构建块：即 <strong>Composable</strong> 函数。</p>
<p>但是快照状态不仅仅是自动通知更改以触发重组的问题。使用 “<strong>snapshot</strong>” 这个单词的一个很重要的原因是：<strong>状态隔离</strong>。这代表了我们在并发上下文中应用的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&spm=1001.2101.3001.7020">隔离级别</a>。</p>
<p>想象一下在不同线程之间处理可变状态会怎样。这很容易变得一团糟。需要严格的协调和同步来确保状态的完整性，因为它可以在同时从不同的线程中读取或修改。这为冲突、难以检测的bug和竞争条件敞开了大门。</p>
<p>传统意义上，编程语言以不同的方式处理这个问题，其中之一是不可变性。不可变数据在创建后永远不会被修改，这使它在并发场景下绝对安全。另一个有效的方法可以是 actor 系统。该系统专注于跨线程的<strong>状态隔离</strong>。Actor 保留其自己的状态副本，通过消息实现通信&#x2F;协调。如果该状态是可变的，则需要存在一些协调来使全局程序状态一致。Compose 快照系统不是基于 actor 系统，但实际上更接近于该方法。</p>
<p>Jetpack Compose 使用可变状态，因此 Composable 函数可以自动响应状态更新。仅使用不可变状态的库是没有意义的。这意味着它需要解决在并发场景中共享状态的问题，因为组合可以在<strong>多个线程</strong>中实现。Compose解决此问题的方法就是状态快照系统，它基于状态隔离和后续的变更传播，以便可以在多个线程之间安全地使用可变状态。</p>
<p>快照状态系统是使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrency_control">并发控制系统</a>建模的，因为它需要以安全的方式<strong>协调跨线程的状态</strong>。在并发环境中共享可变状态并不容易，这是一个通用的问题，与库的实际用例无关。</p>
<p>在 Jetpack Compose 中 State 是一个接口，任何快照状态对象都会实现这个接口。以下是<strong>State</strong>接口的代码形式：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9557081ef2cb0cd16fe889ac65b50db5.png" alt="在这里插入图片描述"></p>
<p>这个协议被标记为 <code>@Stable</code>，因为 Jetpack Compose 仅提供和使用稳定的实现（出于设计原因），概括一下，这意味着该接口的任何实现必须确保：</p>
<ul>
<li><strong>对相同的两个 <strong>State</strong> 实例调用 <code>equals</code> 方法总是返回相同的结果。</strong></li>
<li><strong>当类型的公开属性值更改时，会通知组合。</strong></li>
<li><strong>它所有的公开属性值类型也是稳定的。</strong></li>
</ul>
<p>建议读一下<a target="_blank" rel="noopener" href="https://dev.to/zachklipp/a-historical-introduction-to-the-compose-reactive-state-model-19j8">Zach Klipp的这篇文章</a>，介绍了一些相关的想法。我非常推荐这篇文章。</p>
<p>接下来首先了解一些关于并发控制系统的知识。这将有助于我们更容易地理解为什么Jetpack Compose状态快照系统采用这种模型。</p>
<h3 id="并发控制系统"><a href="#并发控制系统" class="headerlink" title="并发控制系统"></a>并发控制系统</h3><p>状态快照系统是按照并发控制系统实现的，因此让我们先介绍这个概念。</p>
<p>在计算机科学中，“并发控制”是关于确保并发操作正确结果的一种方法，这意味着协调和同步。并发控制由一系列规则组成，确保整个系统的正确性。但是，协调总是伴随着一定的代价。协调通常会影响性能，因此关键挑战是设计一种尽可能高效但不会显著降低性能的方法。</p>
<p>一个并发控制的例子是数据库管理系统（DBMS）中的事务系统，这个上下文中的并发控制确保在并发环境中执行的任何数据库事务都是以安全的方式进行的，不违反数据库的数据完整性。目标是维护正确性。这里的“安全”涵盖的内容包括确保事务是原子性的、可以安全地撤销、已提交事务的效果永远不会丢失，以及已中止事务的效果不会留在数据库中。这是一个复杂的问题。</p>
<p>并发控制不仅在DBMS中经常出现，在编程语言中也会出现，例如用于实现事务内存。事务内存试图通过允许一组加载和存储操作以原子方式执行来简化并发编程。实际上，在Compose状态快照系统中，当状态更改从一个快照传播到其他快照时，状态写入被应用为单个原子操作。像这样分组的操作简化了并行系统&#x2F;进程中共享数据的并发读写之间的协调。在此基础上，原子更改可以轻松地中止、撤销或重现。即：拥有可重现更改历史，以可能重新生成程序状态的任何版本。</p>
<p>并发控制系统有不同的类别：</p>
<ul>
<li>乐观：不阻塞任何读或写操作，并对这些操作的安全性持乐观态度，如果提交时将违反所需规则，则中止事务以防止违反。中止的事务立即重新执行，这意味着有开销。当平均中止事务的数量不太高时，这种策略可能是一个很好的选择。</li>
<li>悲观：如果操作违反规则，则阻止事务中的操作，直到违反的可能性消失。</li>
<li>半乐观：这是其他两种的混合解决方案。只在某些情况下阻止操作，并对其他情况持乐观态度（然后在提交时中止）。</li>
</ul>
<p>每个类别的性能因因素而异，例如平均事务完成速率（吞吐量）、所需的并行性水平和其他因素，例如死锁的可能性。非乐观类</p>
<h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制 (MVCC)"></a>多版本并发控制 (MVCC)</h3><p>Jetpack Compose 中的<strong>全局状态</strong>是跨组合和线程共享的。组合函数应该能够并行运行（可以随时进行并行重组），如果它们并行执行，则可以同时读取或修改快照状态，因此需要进行状态隔离。</p>
<p>并发控制的主要特性之一实际上是<strong>隔离性</strong>。该特性确保了在并发访问数据的情况下的正确性。实现隔离的最简单方法是阻止所有 readers 直到 writers 完成，但这会对性能产生极大的影响。<strong>MVCC</strong>（Multiversion concurrency control）可以做得更好。</p>
<p>为了实现隔离性，<strong>MVCC</strong> 保留了数据的<strong>多个副本</strong>（快照），因此每个线程都可以在给定时刻使用一个隔离的状态快照来工作。我们可以将它们理解为<strong>状态的不同版本</strong>（“<strong>多版本</strong>”）。线程所做的修改对其他线程来说是不可见的，直到所有本地更改完成并传播。</p>
<blockquote>
<p>在并发控制系统中，这种技术被称为“<strong>快照隔离</strong>”，并且它被定义为用于确定每个“事务”看到哪个版本的隔离级别。</p>
</blockquote>
<p><strong>MVCC</strong> 还利用了不可变性，因此每当写入数据时，都会创建数据的新副本，而不是修改原始数据。这导致在内存中存储了相同数据的多个版本，就像对象的所有更改历史一样。在 Compose 中，这些称为“<strong>状态记录</strong>”。</p>
<p><strong>MVCC</strong> 还具有的一个特点是它创建了<strong>时间点一致的视图</strong>。这通常是备份文件的一个特性，它表示给定备份上所有对象的引用保持一致。在 <strong>MVCC</strong> 中，通常通过事务 <strong>ID</strong> 来确保这一点，因此任何读操作都可以引用相应的 <strong>ID</strong> 来确定使用哪个版本的状态。这实际上是 Jetpack Compose 中的工作方式。<strong>每个快照都被分配了自己的</strong> <strong>ID</strong>。快照 <strong>ID</strong> 是单调递增的值，因此它们自然地被排序。由于快照是通过它们的 <strong>ID</strong> 区分的，因此读取和写入是相互隔离的，无需进行锁定。</p>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>一个快照可以在任何时候被创建。它反映了程序在给定时刻（创建快照时）的当前状态（所有快照状态对象）。可以创建多个快照，它们都会获得<strong>自己独立的程序状态副本</strong>。也就是说，当前所有快照状态对象在那个时间点的状态副本（实现 State 接口的对象）的副本。</p>
<p>这种方法使得状态修改是安全的，因为在一个快照中更新一个状态对象不会影响到其他快照中同一个状态对象的副本。<strong>快照之间是隔离的</strong>。在有多个线程的并发场景中，每个线程都将指向不同的快照，因此指向不同的状态副本。</p>
<p>Jetpack Compose runtime 提供了 <strong>Snapshot</strong> 类来模拟程序的<strong>当前状态</strong>。任何代码只需要调用它的静态方法：<strong><code>val snapshot = Snapshot.takeSnapshot()</code></strong> 即可获取到一个快照。这将获取所有状态对象当前值的快照，并且这些值将被保留，直到 <strong><code>snapshot.dispose()</code></strong> 方法被调用。这将决定快照的生命周期。</p>
<p>快照有其<strong>生命周期</strong>。每当我们使用完一个快照时，它都需要被处理掉。如果我们不调用 <strong><code>snapshot.dispose()</code></strong> ，我们将泄漏所有与该快照相关的资源及其保留状态。快照在<strong>创建</strong>和<strong>释放</strong>状态之间被视为处于<strong>活动状态</strong>。</p>
<p>当一个快照被创建时，它被赋予一个 <strong>ID</strong>，以便所有在该快照上的状态可以轻松地与其他潜在版本的相同状态区分开来。这允许为程序状态进行版本控制，或者换句话说，<strong>根据版本（多版本并发控制）使程序状态保持一致</strong>。</p>
<p>最好的理解快照是通过代码。我将直接从<a target="_blank" rel="noopener" href="https://dev.to/zachklipp/introduction-to-the-compose-snapshot-system-19cn">Zach Klipp的这篇非常值得学习且详细的帖子</a>中提取一段代码来说明：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b6d8144570d0fb619e4a3e61f1c2a28b.png" alt="在这里插入图片描述"><br>其中 <code>Dog</code> 类的 <code>name</code> 是一个 <code>mutableStateOf(&quot;&quot;)</code> 的实现。</p>
<p>这里函数 <code>snapshot.enter</code>，通常称为“<strong>进入快照</strong>”，这会<strong>在快照的上下文中运行一个 lambda 表达式</strong>，因此快照成为任何状态的真实来源：从 lambda 表达式读取的所有状态将从快照中获取其值。这个机制允许 Compose 和任何其他客户端库在给定快照的上下文中运行任何处理状态的逻辑。这个过程在本地线程中进行，直到调用 <code>enter</code> 返回。其他任何线程都不会受到任何影响。</p>
<p>在上面的例子中，我们可以看到更新后的狗名为“<code>Fido</code>”，但是如果我们从快照的上下文（<code>enter</code>调用）读取它，它会返回“<code>Spot</code>”，这是在快照被创建时它所拥有的值。</p>
<p>当然，在使用完快照后必须记得调用 <strong><code>snapshot.dispose()</code></strong> 来释放状态，下面是完整代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: MutableState&lt;String&gt; = mutableStateOf(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dog = Dog()</span><br><span class="line">    dog.name.value = <span class="string">&quot;Spot&quot;</span></span><br><span class="line">    <span class="keyword">val</span> snapshot = Snapshot.takeSnapshot()</span><br><span class="line">    dog.name.value = <span class="string">&quot;Fido&quot;</span></span><br><span class="line">  </span><br><span class="line">    println(dog.name.value) <span class="comment">// ---&gt; Fido</span></span><br><span class="line">    snapshot.enter &#123; println(dog.name.value) &#125; <span class="comment">// 进入快照 ---&gt; Spot</span></span><br><span class="line">    println(dog.name.value) <span class="comment">// ---&gt; Fido</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When finished with the snapshot, it must always be disposed. </span></span><br><span class="line">    snapshot.dispose()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，在<code>enter</code>函数内部，可以根据快照的类型（只读 vs 可变）读取和写入状态。</p>
</blockquote>
<p>通过 <strong><code>Snapshot.takeSnapshot()</code></strong> 创建的快照是 <strong>只读</strong> 的。它所包含的所有状态都不能被修改。如果我们试图写入快照中的任何状态对象，将会抛出异常。</p>
<p>但并非所有的操作都是读取状态，我们可能还需要更新它（写入）。Compose 提供了 <strong>Snapshot</strong> 契约的一个特定实现：<strong>MutableSnapshot</strong>，它允许修改它所持有的状态。除此之外，还有其他可用的实现。以下列举了 <strong>Snapshot</strong> 所有不同类型的实现。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/5f2961f513cb34c0b4ca386723aede32.png" alt="在这里插入图片描述"></p>
<p>让我们简要介绍一下不同类型的快照：</p>
<ul>
<li><p><strong>ReadonlySnapshot</strong>：快照中持有的状态对象是<strong>只读的</strong>，只能读取而不能修改。</p>
</li>
<li><p><strong>MutableSnapshot</strong>：快照中持有的状态对象<strong>既可以读取也可以修改</strong>。</p>
</li>
<li><p><strong>NestedReadonlySnapshot</strong>和<strong>NestedMutableSnapshot</strong>：用于 Child 的只读和可变快照，因为快照可以形成一棵树。<strong>一个快照可以有任意数量的嵌套快照</strong>。稍后会更详细地介绍。</p>
</li>
<li><p><strong>GlobalSnapshot</strong>：持有<strong>全局共享程序状态的可变快照</strong>。它实际上是所有快照的 root 快照。</p>
</li>
<li><p><strong>TransparentObserverMutableSnapshot</strong>：这是一个特殊情况。它不应用任何状态隔离，并且仅存在于在读取&#x2F;写入状态对象时通知读取和写入观察者。它上面的所有状态记录都会自动标记为无效，因此它们不可被任何其他快照看到&#x2F;读取。这种类型的快照的<strong>ID</strong>始终为其父级的<strong>ID</strong>，因此为它创建的任何记录实际上都与父级关联。在这种意义上，它是“透明的”，因为在其中执行的所有操作都像在父快照中执行一样。</p>
</li>
</ul>
<h3 id="Snapshot-Tree-快照树"><a href="#Snapshot-Tree-快照树" class="headerlink" title="Snapshot Tree (快照树)"></a>Snapshot Tree (快照树)</h3><p>正如我们上面解释的那样，<strong>快照形成了一棵树</strong>。因此，我们可以在不同的快照类型中找到 <strong>NestedReadonlySnapshot</strong> 和 <strong>NestedMutableSnapshot</strong>。<strong>任何快照都可以包含任意数量的嵌套快照</strong>。树的<strong>根</strong>是 <strong>GlobalSnapshot</strong>，保存全局状态。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4dab9a926ad9a4239c65a8f0be7b1062.png" alt="在这里插入图片描述"></p>
<p><strong>嵌套快照</strong>类似于快照的独立副本，可以<strong>独立销毁&#x2F;释放</strong>。这允许<strong>在保持父快照处于活动状态的同时销毁&#x2F;释放它</strong>。它们在Compose中使用<strong>子组合</strong>（<strong>subcomposition</strong>）时经常出现。</p>
<blockquote>
<p>简短回顾一下。我们之前提到过子组合是在父组合中创建的内联组合，其唯一目的是支持独立的失效。组合和子组合也形成了一棵树。</p>
</blockquote>
<p>在创建延迟列表或 <strong>BoxWithConstraints</strong> 时，会创建嵌套快照的子组合。我们还可以在 <strong>SubcomposeLayout</strong> 或 <strong>VectorPainter</strong> 中找到子组合。</p>
<p>当需要进行<strong>子组合</strong>时，会创建一个<strong>嵌套的快照</strong>来存储和隔离其状态，因此在子组合消失时嵌套快照可以被销毁，同时保持父级组合和父级快照处于活动状态。对嵌套快照进行的任何更改，都将会传播到其父级。</p>
<p>所有的快照类型都提供了一个函数来获取一个嵌套快照并将其附加到父快照上，例如 <strong><code>Snapshot#takeNestedSnapshot()</code></strong> 或 <strong><code>MutableSnapshot#takeNestedMutableSnapshot()</code></strong> 。</p>
<p>一个 Child 只读快照可以从任何快照类型生成。而可变快照只能从另一个可变快照生成（或从全局快照生成，它也可被视为一个可变快照）。</p>
<h3 id="快照和线程"><a href="#快照和线程" class="headerlink" title="快照和线程"></a>快照和线程</h3><p>将快照视为独立于任何线程范围之外的结构是非常重要的。线程确实可以有一个当前的快照，但是<strong>快照不一定与线程绑定</strong>。线程可以随意进入和离开快照，另一个线程可以进入子快照。实际上，快照的预期使用案例之一是并行工作。可以产生多个子线程，每个线程都有自己的快照。</p>
<p>一旦我们定义了可变的快照，我们也将学习子快照如何通知父快照其更改以保持一致性。所有线程的更改都将彼此隔离，并且不同线程的冲突更新将被检测和处理。嵌套快照允许这种工作分解是递归的。所有这些都可能解锁诸如并行组合之类的功能。</p>
<p>可以通过 <strong><code>Snapshot.current</code></strong> 获取<strong>当前线程的快照</strong>。如果有，则返回当前线程的快照；否则返回<strong>全局快照</strong>（保存全局状态）。</p>
<p>Compose运行时具有观察到写入的状态时触发重新组合的能力。了解这个机制与我们之前描述的状态快照系统是如何连接的将是有益的。让我们开始学习如何先观察读取。</p>
<h3 id="观察读写"><a href="#观察读写" class="headerlink" title="观察读写"></a>观察读写</h3><p>Compose runtime 在被观察的状态被写入时，有能力触发重组。</p>
<p>每当我们获取快照时（例如 <strong><code>Snapshot.takeSnapshot()</code></strong>），我们得到的返回值是一个 <strong><code>ReadonlySnapshot</code></strong> 。由于这个快照中的状态对象不能被修改，只能被读取，快照中的所有状态都会被保留，直到它被销毁。<strong><code>takeSnapshot</code></strong> 函数的 lambda 允许我们传递一个 <code>readObserver</code>（作为可选参数）观察者，每当在 <code>enter</code> 调用中从快照中读取任何状态对象时，都会通知该观察者。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1bec1265a17243d329b50230e2321f8c.png" alt="在这里插入图片描述"></p>
<p><strong>snapshotFlow</strong> 函数可以作为使用 <code>readObserver</code> 一个例子：<strong><code>fun &lt;T&gt; snapshotFlow(block: () -&gt; T): Flow&lt;T&gt;</code></strong>。该函数将 <code>State&lt;T&gt;</code> 对象转换为 <code>Flow</code>。当 <code>Flow</code> 被收集时，它会运行其 <code>block</code> 块并发出其中读取的 <code>State</code> 对象的结果。当其中一个 <code>State</code> 对象被修改时，<code>Flow</code> 会将新值发出给其收集器。为了实现这种行为，它需要记录所有状态读取，以便在这些状态对象中的任何一个发生更改时重新执行 <code>block</code> 块。为了跟踪这些读取，它采用一个只读快照并传递一个读取观察者，以便将它们存储在一个 <code>Set</code> 中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SnapshotFlow.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">snapshotFlow</span><span class="params">(block: () -&gt; <span class="type">T</span>)</span></span>: Flow&lt;T&gt; = flow &#123; </span><br><span class="line">    <span class="keyword">val</span> readSet = mutableSetOf&lt;Any&gt;()</span><br><span class="line">    <span class="keyword">val</span> readObserver: (Any) -&gt; <span class="built_in">Unit</span> = &#123; readSet.add(it) &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Snapshot.takeSnapshot(readObserver) </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Do something with the Set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只读快照不仅在读取某些状态时通知其<code>readObserver</code>，还会通知其父级的<code>readObserver</code>。嵌套快照上的读取必须对所有父级和其观察者可见，所以快照树上所有的观察者都会被通知。</p>
<p>现在让我们开始观察写操作。</p>
<p>观察写入也是可能的，因此只有在创建<strong>可变快照</strong>时才能传递 <code>writeObserver</code>（状态更新）。可变快照是允许修改其持有的状态的快照。我们可以通过调用 <code>Snapshot.takeMutableSnapshot()</code> 来获取一个可变快照。在这里，我们可以传递可选的读和写观察器以便在任何读取或写入时得到通知。</p>
<p>观察读写的一个好例子就是 <strong>Recomposer</strong>，它能够跟踪 <strong>Composition</strong> 中的任何读写操作，以在需要时自动触发重组。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/11ee6f31f2ffc3ee25a67415ddf45ee2.png" alt="在这里插入图片描述"></p>
<p><code>composing</code> 函数在创建初始组合（<strong>Composition</strong>）和每次重组时都会调用。这个逻辑依赖于一个 <code>MutableSnapshot</code>，它允许状态不仅可以被读取，还可以被写入，并且 <code>enter</code> 调用的 <code>block</code> 块中的任何读取或写入都被通知给组合（<strong>Composition</strong>）中。（换句话说，也就是可变状态的读写操作可以被组合追踪到）</p>
<p>这里作为参数传递的 <code>block</code> 代码块，实际上是运行组合或重组的代码，因此它执行树中的所有 <strong>Composable</strong> 函数来计算更改列表。又因为这些操作都是发生在 <code>enter</code> 函数内部，因此会自动跟踪任何读取或写入操作。</p>
<p>每当快照状态写入被追踪到组合中时，读取完全相同的快照状态的相应的 <strong>RecomposeScopes</strong> 将被无效化并触发重组。</p>
<p>在组合结束时，<code>applyAndCheck(snapshot)</code>调用会将组合期间发生的任何更改传播到其他快照和全局状态。</p>
<p>下面是观察者在代码中的样子，它们是简单的函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readObserverOf</span><span class="params">(composition: <span class="type">ControlledComposition</span>)</span></span>: (Any) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value -&gt; composition.recordReadOf(value) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeObserverOf</span><span class="params">(composition: <span class="type">ControlledComposition</span>, modifiedValues: <span class="type">IdentityArraySet</span>&lt;<span class="type">Any</span>&gt;?)</span></span>: (Any) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; value -&gt;</span><br><span class="line">        composition.recordWriteOf(value)</span><br><span class="line">        modifiedValues?.add(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些比较实用的函数可以用来在当前线程中观察读取和写入。这就是 <strong><code>Snapshot.observe(readObserver, writeObserver, block)</code></strong> 函数。例如，<strong><code>derivedStateOf</code></strong> 函数就使用它来响应提供的块中的所有对象读取。<code>Snapshot.observe()</code> 是唯一使用 <strong>TransparentObserverMutableSnapshot</strong> 的地方。创建此类型的父（根）快照的唯一目的是向观察者通知读取，如前面所述。Comose团队添加这种类型，是为了避免在一些特殊情况下快照中产生一个回调列表。</p>
<h3 id="MutableSnapshot"><a href="#MutableSnapshot" class="headerlink" title="MutableSnapshot"></a>MutableSnapshot</h3><p><strong>MutableSnapshot</strong> 是在处理可变快照状态时使用的快照类型，在这种情况下，我们需要跟踪写入以自动触发重组。</p>
<p>在可变快照中，<strong>任何状态对象</strong>都将拥有快照在被拍摄时的<strong>相同的值</strong>，除非你在快照中<strong>本地修改了状态对象</strong>。在 <strong>MutableSnapshot</strong> 中进行的所有更改都与其他快照所做的更改<strong>隔离</strong>。更改从树的底部向上传播。子嵌套的可变快照需要先应用其更改，然后将其传播到父级或全局快照（如果它是树的根）。这是通过调用 <strong><code>NestedMutableSnapshot＃apply</code></strong> 来完成的。（或者 <strong><code>MutableSnapshot＃apply</code></strong>，如果是非嵌套的话）</p>
<p>以下段落直接摘自Jetpack Compose runtime 的 kdocs：</p>
<p><em>Composition uses mutable snapshots to allow changes made in Composable functions to be temporarily isolated from the global state and is later applied to the global state when the composition is applied. If MutableSnapshot.apply fails applying this snapshot, the snapshot and the changes calculated during composition are disposed and a new composition is scheduled to be calculated again.</em><br><em>（翻译：组合使用可变快照，以便在 Composable 函数中进行的更改在一段时间内与全局状态隔离，并在应用组合时稍后应用于全局状态。如果 MutableSnapshot.apply 无法应用此快照，则该快照和组合期间计算的更改将被丢弃，并计划重新计算新的组合。）</em></p>
<p>因此，在应用组合（回顾一下：我们应用变更是在组合的最后一步通过<strong>Applier</strong>来完成的）时，将应用可变快照中的任何更改并将其通知其父级或最终全局快照。如果应用这些更改时出现错误，则会安排新的组合。</p>
<p>可变快照也有生命周期。它始终通过调用 <code>apply</code> 和 <code>dispose</code> 来结束。这既是将状态修改传播到其他快照的必要条件，也是为了避免泄漏。</p>
<p>通过 <code>apply</code> 传播的更改应用是<strong>原子性的</strong>（<strong>atomically</strong>），这意味着全局状态或父快照（如果其嵌套）会将所有这些更改视为<strong>单个原子更改</strong>。这将会清理一下状态更改的历史记录，以便更容易识别、重现、中止或还原。这就是我们前面在并发控制系统部分所描述的事务内存的作用。</p>
<p>如果可变快照被丢弃但从未应用，则其所有未处理的状态更改都将被丢弃。</p>
<p>这里有一个实际的例子，展示了在客户端代码中如何使用 <code>apply</code>：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b544704261e60c9826bc38c83d8d4dbb.png" alt="在这里插入图片描述"></p>
<p>当我们从 <code>enter</code> 调用内部打印时，值为 “<code>Another street</code>”，因此修改是可见的。这是因为我们在快照的上下文中运行。但是，如果我们在 <code>enter</code> 调用之后立即打印（在外部），则该值似乎已恢复为原始值。这是因为 <strong>MutableSnapshot</strong> 中的更改与任何其他快照<strong>隔离</strong>。调用 <code>apply</code> 之后，<strong>更改会传播</strong>，然后我们最终可以看到再次打印 <code>streetname</code> 时输出的是修改后的值。</p>
<p>注意，只有在 <code>enter</code> 调用中完成的状态更新才会被跟踪和传播。</p>
<p>还存在另一种简化版本的语法：<strong><code>Snapshot.withMutableSnapshot</code></strong> ，它将隐式的确保 <code>apply</code> 会在最后被调用。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a9c792792210a856ce21d6d8f79f0689.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>最后调用 <code>apply</code> 的方式可能会让我们想起 <strong>Composer</strong> 是如何记录和应用更改列表的。这又是同样的概念。每当我们需要理解树中的变更列表时，就需要记录&#x2F;延迟这些变更，这样我们就可以以正确的顺序应用(触发)它们，并在那一刻强制一致性。这是程序知道所有更改的唯一时机，或者换句话说，这是它拥有一个全局视角的时刻。</p>
</blockquote>
<p>也可以注册应用观察器来观察最终的修改更改。这可以通过调用 <strong><code>Snapshot.registerApplyObserver</code></strong> 来实现。</p>
<h3 id="GlobalSnapshot-和-Nested-Snapshot"><a href="#GlobalSnapshot-和-Nested-Snapshot" class="headerlink" title="GlobalSnapshot 和 Nested Snapshot"></a>GlobalSnapshot 和 Nested Snapshot</h3><p><strong>GlobalSnapshot</strong> 是一种可变快照，恰好保存全局状态。它将按照上面描述的从下到上的顺序从其他快照获取更新。</p>
<p><strong>GlobalSnapshot</strong> 不能嵌套。因为只存在一个 <strong>GlobalSnapshot</strong>，它实际上是所有快照的最终根。它保存当前的<strong>全局(共享)状态</strong>。因此，不能应用全局快照(它没有<code>apply</code>调用)。</p>
<p>要在全局快照中应用更改，它必须是 “advanced” 的。这是通过调用 <strong><code>Snapshot.advanceGlobalSnapshot()</code></strong> 来完成的，它清除前一个全局快照并创建一个新快照，该快照接受前一个全局快照的所有有效状态。在这种情况下，Apply 观察者也会得到通知，因为即使机制不同，这些更改也会被有效地“应用”。同样，也不可能对其调用 <code>dispose()</code>。销毁全局快照也可以通过“advanced” 的方式完成。</p>
<p>在 Jetpack Compose 中，全局快照是在快照系统<strong>初始化</strong>期间创建的。在 <strong>JVM</strong> 中，当 <strong><code>SnapshotKt.class</code></strong> 被 <strong>Java</strong> 或 <strong>Android</strong> runtime 初始化时就会发生这种情况。</p>
<p>在此之后，在创建 <strong>Composer</strong> 时会启动一个<strong>全局快照管理器</strong>，然后每个组合（包括初始组合和任何进一步的重组）创建自己的嵌套可变快照并将其附加到树中，因此它可以存储和隔离组合的所有状态。<strong>Composition</strong> 也将利用这个机会注册读写观察者来跟踪对 <strong>Composition</strong> 的读写。还记得前面介绍的 <strong><code>composing</code></strong> 函数吗：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c49f1bffd62359faffadc242b85ccfab.png" alt="在这里插入图片描述"></p>
<p>最后，任何子组合都可以创建自己的嵌套快照并将其附加到树中，以在保持父元素活动的同时支持失效。这将为我们提供快照树的完整蓝图。</p>
<p>另一个有趣的细节是，当 <strong>Composer</strong> 被创建后，在创建 <strong>Composition</strong> 时，会调用 <strong><code>GlobalSnapshotManager.ensureStarted()</code></strong> 。这是与平台集成的一部分 (<strong>Compose UI</strong>)，它将开始观察所有对全局状态的写入，并在 <strong>AndroidUiDispatcher.Main</strong> 上下文中定时调度快照应用通知。</p>
<h3 id="StateObject-和-StateRecord"><a href="#StateObject-和-StateRecord" class="headerlink" title="StateObject 和 StateRecord"></a>StateObject 和 StateRecord</h3><p>多版本并发控制确保每次写入状态时，都会创建一个新版本(写时复制)。Jetpack 组合状态快照系统遵循这一点，因此最终可能存储同一个快照状态对象的多个版本。</p>
<p>这种设计对性能有三个方面的重要意义。</p>
<ul>
<li>首先，<strong>创建快照</strong>的成本是 <strong>O(1)</strong> 复杂度，而不是 <strong>O(N)</strong> （其中<strong>N</strong>是状态对象的数量）。</li>
<li>其次，<strong>提交快照</strong>的成本是 <strong>O(N)</strong> 复杂度，其中 <strong>N</strong> 是快照中发生突变的对象的数量。</li>
<li>第三，快照本身不会持有快照数据的列表(只有修改对象的临时列表)，因此状态对象可以自由地被垃圾收集器（GC）收集，而不需要通知快照系统。</li>
</ul>
<p>在内部，<strong>快照状态对象</strong>被建模为一个 <strong>StateObject</strong>，在多版本中，为该对象存储的每一个版本的存储形式的都是一个 <strong>StateRecord</strong>。每条记录都保存状态的单个版本的数据。每个快照所看到的版本（记录）对应于拍摄快照时可用的最新有效版本。(快照 <strong>ID</strong> 最高的有效快照)</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8a78c3fc100d9182181dab3eab29069e.png" alt="在这里插入图片描述"><br>但是怎样才能使状态记录有效呢?</p>
<p>“有效” 在特定的快照下才有意义。记录与创建记录的快照 <strong>ID</strong> 相关联。一个快照的状态记录在满足如下条件时是有效的：如果状态记录的 <strong>ID</strong> 小于等于快照 <strong>ID</strong> (即在当前或上一个快照中创建的)，并且不属于快照的<code>invalid</code>集合，也没有被明确标记为<code>invalid</code>。前一个快照中的任何有效记录都会自动复制到新快照中。</p>
<p>这就引出了一个问题：什么会使记录成为所提到的无效集合的一部分或显式标记为无效呢？</p>
<ul>
<li>在当前快照<strong>之后</strong>创建的记录被认为是无效的，因为它们是为在此快照之后创建的快照而创建的。</li>
<li>当前快照创建时，如果为快照创建的记录已打开，则记录被添加到无效集合中，所以它们也被视为无效。</li>
<li>在应用之前被销毁的快照中创建的记录被明确标记为无效。</li>
</ul>
<p>一个无效的记录对任何快照都不可见，因此它无法被读取。当从 Composable 函数中读取快照状态时，该记录不会被考虑在内，而会返回其最新的有效状态。</p>
<p>回到状态对象。下面是在状态快照系统中它们的建模方式的简要示例。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7d7cb1bb2d8a00fe0c971883e03d5a6e.png" alt="在这里插入图片描述"></p>
<p>任何通过任何方式创建的可变快照状态对象都将实现此接口。例如，由 <code>mutableStateOf</code>、<code>mutableStateListOf</code> 或 <code>derivedStateOf</code> 运行时函数返回的状态等。</p>
<p>让我们来看一下 <code>mutableStateOf(value)</code> 函数。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8d6ac11769a299e9d474b52a33b75594.png" alt="在这里插入图片描述"></p>
<p>这个调用返回一个 <strong>SnapshotMutableState</strong> 的实例，它本质上是一个可观察的可变状态，换句话说，它是一个可以更新的状态，并会自动通知观察者的状态。这个类是一个 <strong>StateObject</strong>，因此它维护一个记录的链接列表，用来存储状态的不同版本（在这个例子中是<code>value</code>）。每次读取状态时，将遍历记录列表，以找到并返回最新的有效记录。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3636eff4198669fbbede0d74a034fb2b.png" alt="在这里插入图片描述"></p>
<p>如果我们回顾一下 <strong>StateObject</strong> 的定义，我们可以看到它有一个指针指向记录链表的第一个元素，每个记录都指向下一个。它还允许在列表中预先添加一个新记录（使其成为新 <strong><code>firstStateRecord</code></strong>）。</p>
<p><strong>StateObject</strong> 定义中的另一个函数是 <code>mergeRecords</code>。我们之前提到过系统在可能的情况下可以自动合并冲突。这就是这个函数的作用。合并策略很简单，稍后将详细介绍。</p>
<p>让我们稍微了解一下 <strong>StateRecord</strong></p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8555f1f6ebdcf422354b86fdc08aac02.png" alt="在这里插入图片描述"><br>这里我们可以看到每个记录都关联了一个快照 <strong>ID</strong>。这个 <strong>ID</strong> 是属于创建该记录的那个快照的 <strong>ID</strong> 。这将确定该记录是否对于遵循上述要求的给定快照是有效的。</p>
<p>我们说过每当一个对象被读取时，会遍历给定快照状态（<strong>StateObject</strong>）的 <strong>StateRecords</strong> 列表，查找最新的有效记录（具有最高的快照 <strong>ID</strong>）。同样地，当快照被创建时，每个快照状态对象的最新有效状态都会被捕获，并且这将是新快照的整个生命周期中使用的状态（除非它是可变快照且状态在本地被修改）。</p>
<p><strong>StateRecord</strong> 还有一个 assign 函数，它从另一个<strong>StateRecord</strong>对象给其赋值并创建它。</p>
<p><strong>StateRecord</strong> 也是一个契约（接口）。每种现有 <strong>StateObject</strong> 类型定义了不同的实现，因为记录存储了每种类型的 <strong>StateObject</strong> 的相关信息，这些信息对于每个类型（每个使用情况）都不同。</p>
<p>跟随 <strong><code>mutableStateOf</code></strong> 的例子，我们知道它返回的是一个 <strong><code>SnapshotMutableState</code></strong>，它是一个<strong>StateObject</strong>。它将维护一个非常特定类型的记录链表：<strong><code>StateStateRecord</code></strong>。这个记录只是一个包装在 <strong>T</strong> 类型值上的包装器，因为在这种情况下，这就是我们需要在每个记录中存储的所有信息。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3e1da2644fe67b34a41d2270be6528eb.png" alt="在这里插入图片描述"></p>
<p>另一个好的例子可以是 <strong><code>mutableStateListOf</code></strong> 。它创建了一个 <strong><code>SnapshotStateList</code></strong>，这是 <strong>StateObject</strong> 的另一个实现。该状态模拟了一个可观察的可变列表（实现了Kotlin集合的<code>MutableList</code>契约），因此其记录将具有由自身定义的 <strong><code>StateListStateRecord</code></strong> 类型。此记录使用一个<code>PersistentList</code>（参见Kotlin不可变集合）来保存状态列表的一个版本。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/252135a783e4110a133793ad9ad772ae.png" alt="在这里插入图片描述"></p>
<h3 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h3><p>换句话说，也就是读写状态记录。“当读取一个对象时，将遍历给定快照状态（<strong>StateObject</strong>）的<strong>StateRecords</strong>列表，查找最近的有效记录（具有最高的快照<strong>ID</strong>）”。让我们看看这在代码中是如何实现的。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/98906083588b32e915e8a77596203028.png" alt="在这里插入图片描述"></p>
<p>这是来自 <strong><code>compose.material</code></strong> 库的 <strong>TextField</strong> Composable 组件。它会记住一个可变状态用于保存文本值，所以每次值更新时，该 Composable 都会重组以在屏幕上显示新的字符。</p>
<p>我们暂时不考虑 <code>remember</code> 的调用，因为它不是我们在此讨论的重点。这里使用的是 <code>mutableStateOf</code> 函数，用于创建快照状态：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d1ff9905484611d653a9c57792cd24e4.png" alt="在这里插入图片描述"></p>
<p>这最终创建了一个 <strong>SnapshotMutableState</strong> 状态对象，该对象获取了 <strong><code>value: T</code></strong> 和 <strong><code>SnapshotMutationPolicy&lt;T&gt;</code></strong> 作为参数。它将包装该值（存储在内存中），并在需要更新该值时使用冲突策略来检查所传递的 <strong>新值</strong> 是否与 <strong>当前值</strong> 不同。以下是该类中 <code>value</code> 属性的定义：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f8175fca15ebf6e2358096a8e72e211e.png" alt="在这里插入图片描述"></p>
<p>每当我们使用 <code>getter</code> 访问 <code>TextField</code> Composable 内部值时（例如 <code>textFieldValueState.value</code>），它将通过下一个状态记录（链表中的第一个记录）的引用 <code>next</code> 来调用 <code>readable</code> 方法开始迭代。<code>readable</code> 函数通过<strong>迭代</strong>查找当前（最新的）有效的可读状态，同时通知任何已注册的<strong>读取观察者</strong>。对于每个新迭代项，它将按照先前部分中定义的有效条件进行检查。当前快照将是当前线程的快照或者全局快照（如果当前线程未关联到任何快照的话）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the current readable state record for the current snapshot. </span></span><br><span class="line"><span class="comment"> * It is assumed that [this] is the first record of [state]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : StateRecord&gt;</span> T.<span class="title">readable</span><span class="params">(state: <span class="type">StateObject</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">val</span> snapshot = Snapshot.current</span><br><span class="line">    snapshot.readObserver?.invoke(state)</span><br><span class="line">    <span class="keyword">return</span> readable(<span class="keyword">this</span>, snapshot.id, snapshot.invalid) ?: sync &#123; </span><br><span class="line">        <span class="keyword">val</span> syncSnapshot = Snapshot.current</span><br><span class="line">        readable(<span class="keyword">this</span>, syncSnapshot.id, syncSnapshot.invalid)</span><br><span class="line">    &#125; ?: readError()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是 <code>mutableStateOf</code> 的快照状态是如何读取的。对于其他可用的可变快照状态实现（例如由<code>mutableStateListOf</code>返回的实现），情况也是类似的。</p>
<p>当我们想要更新状态时，我们可以使用该状态的 <code>setter</code> 方法来实现。下面是示例代码：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9a190a7b9cb0d12d69173b3baca58929.png" alt="在这里插入图片描述"></p>
<p><code>withCurrent</code> 函数在底层调用了 <code>readable</code> 函数，以便运行提供的代码块并将当前最新的可读状态记录作为参数传递给它。</p>
<p>接下来，它会使用提供的 <code>SnapshotMutationPolicy</code> 检查新值是否等效于当前值。如果它们不相等，就会开始写入过程。这项工作是由 <code>overwritable</code> 函数完成的。</p>
<p>这里我有意地不深入讲解实现细节，因为它们在未来可能会发生变化。但是，我会简要地解释一下：它使用<strong>可写状态记录</strong>运行block块，并提出一个候选记录，该候选记录将是当前最新的有效记录。如果它对于当前快照有效，就使用它来进行写入，否则它将创建一个新的记录并将其添加到列表的开头，使其成为新的初始记录。该block块对其进行实际修改。</p>
<p>最后，它会通知任何已注册的写观察器者。</p>
<h3 id="删除或复用废弃的记录"><a href="#删除或复用废弃的记录" class="headerlink" title="删除或复用废弃的记录"></a>删除或复用废弃的记录</h3><p>通过多版本并发控制，我们可以存储同一状态的多个版本（记录），但这引入了一个有趣的挑战：<strong>删除已过时且永远不会被读取的版本</strong>。我们将在一会儿解释 Compose 如何解决这个问题，但让我们先介绍 “<strong>打开快照</strong>”（open snapshots） 的概念。</p>
<p>任何新的快照都会被添加到一个<strong>打开</strong>（open）的快照集合中，直到主动关闭它。在快照保持打开状态时，它的所有状态记录都被认为对于其他快照无效（不可读取）。关闭快照意味着所有它的记录自动变为有效（可读取）以供创建任何新的快照使用。</p>
<p>一旦我们了解了这一点，让我们来了解一下 Compose 如何回收过时的记录：</p>
<ol>
<li>它跟踪最低的打开快照。Compose 跟踪一组打开的快照 <strong>ID</strong>。这些 <strong>ID</strong> 是单调递增的，不断增加。</li>
<li>如果一条记录是有效的但在最低的打开快照中不可见，则可以安全地重用它，因为它永远不会被任何其他快照选择。</li>
</ol>
<p>复用被覆盖的记录通常会导致可变状态对象中只有 1 或 2 个记录，这会显著提高性能。随着快照的应用，被覆盖的记录将被下一个快照复用。如果一个快照在应用之前被销毁，则所有记录都被标记为无效（丢弃），这意味着它们可以立即被复用。</p>
<h3 id="变更传播"><a href="#变更传播" class="headerlink" title="变更传播"></a>变更传播</h3><p>在解释可变快照中的更改是如何传播之前，回顾一下“closing”和“advancing”快照的含义可能很有用，以便我们理解这两个术语。</p>
<p>关闭快照实际上就是将其 <strong>ID</strong> 从打开的快照 <strong>ID</strong> 集合中删除，其结果是所有与该 <strong>ID</strong> 相关联的状态记录（记录）将变为可见&#x2F;可读，以便由创建的任何新快照读取。这使得关闭快照成为传播状态更改的有效方法。</p>
<p>关闭快照时，很多时候我们希望立即创建一个新的快照来代替它。这就是所谓的 “advancing”。新创建的快照会获得一个新的 <strong>ID</strong>，该 <strong>ID</strong> 通过递增前一个 <strong>ID</strong> 生成。然后将此 <strong>ID</strong> 添加到打开的快照 <strong>ID</strong> 集合中。</p>
<p>正如我们所学到的，全局快照永远不会应用，而总是在前进，这样可以使其所有更改对新创建的全局快照可见。可变快照也可以在其嵌套快照应用更改时前进。</p>
<p>现在我们已经很好地理解了这一点，我们已经准备好学习可变快照中的更改是如何传播的。</p>
<p>在<strong>可变快照</strong>上调用<code>snapshot.apply()</code>时，对其范围内的状态对象所做的所有局部更改都将传播到父快照(如果是嵌套可变快照)或全局状态。</p>
<blockquote>
<p>调用<code>apply</code>或<code>dispose</code>将划定快照的生命周期。应用的可变快照也可以在之后被释放。但是，在<code>dispose</code>之后调用<code>apply</code>将抛出异常，因为这些更改已经被丢弃。</p>
</blockquote>
<p>根据我们所描述的，要传播所有本地更改(对所拍摄的新快照可见)，只需<strong>从活动快照集中删除快照</strong>就足够了。无论何时创建快照，当前打开的快照的副本都会作为无效快照集传入(也就是说，任何尚未应用的快照都不应该对新快照可见)。只需从打开的快照集中删除快照 <code>id</code>，就足以让每个新快照将在此快照期间创建的<code>recrods</code>视为有效的，因此，当读取它们对应的状态对象时，就可以返回它们。</p>
<p>但是只有在确定没有状态冲突(碰撞写入)之后才应该这样做，因为需要首先解决这些问题。</p>
<p>当应用快照时，应用快照所做的更改将与其他快照的更改一起添加。状态对象有一个记录的链表，所有的更改都聚合在其中。这为写入冲突打开了大门，因为多个快照可能会尝试对相同的状态对象应用更改。当一个可变快照想要应用(通知&#x2F;传播)它的本地更改时，它会尝试检测潜在的写冲突并尽可能合并这些冲突。</p>
<p>这里我们有两个场景:</p>
<h4 id="没有挂起的本地更改"><a href="#没有挂起的本地更改" class="headerlink" title="没有挂起的本地更改"></a>没有挂起的本地更改</h4><p>如果快照中没有挂起的本地更改:</p>
<ul>
<li>可变快照被主动关闭(将其从打开的快照<code>id</code>集中移除，使其所有状态记录对新快照自动可见&#x2F;可读)。</li>
<li>全局快照是“advanced”的(与关闭相同，但也将被创建的新的全局快照所取代)。</li>
<li>利用这个机会检查全局快照中是否有任何状态更改，这样可变快照就可以将这些更改通知给任何潜在的应用程序观察者。</li>
</ul>
<h4 id="有挂起的本地更改"><a href="#有挂起的本地更改" class="headerlink" title="有挂起的本地更改"></a>有挂起的本地更改</h4><p>当有挂起的更改时：</p>
<ul>
<li>使用乐观方法检测冲突并计算合并的记录(记住并发控制类别)。碰撞将尝试自动合并，否则将被丢弃。</li>
<li>对于每个挂起的本地更改，它都会检查它是否与当前值不同。如果不是，则忽略更改并保持当前值。</li>
<li>如果是实际的更改(不同)，则检查已经计算的乐观合并，以决定是保留以前的、当前的还是应用的记录。它实际上可以创建所有这些的合并。</li>
<li>如果它必须执行记录的合并，它将创建一个新记录(不可变性)并将快照<code>id</code>分配给它(将其与可变快照关联)，然后将其前置到记录的链表中，使其有效地成为列表中的第一个记录。</li>
</ul>
<p>如果在应用更改时出现任何失败，它将回退到没有挂起的本地更改时所做的相同流程。这是关闭可变快照以使其记录对任何新快照可见，推进全局快照(关闭并用一个新快照替换它)，因此它包括刚刚关闭的可变快照中的所有更改，并通知任何apply观察者检测到的任何全局状态更改。</p>
<p>对于嵌套的可变快照，过程略有不同，因为它们不会将更改传播到全局快照，而是传播到它们的父快照。出于这个原因，它们将其所有已修改的状态对象添加到父对象的已修改集。由于所有这些更改都需要由父快照可见，因此嵌套可变快照将自己的<code>id</code>从无效快照的父快照集中删除。</p>
<h3 id="合并写冲突"><a href="#合并写冲突" class="headerlink" title="合并写冲突"></a>合并写冲突</h3><p>为了进行合并，可变快照迭代它的修改状态列表(本地更改)，对于每一个更改，它执行以下操作:</p>
<ul>
<li>获取父快照或全局状态中的当前值(状态记录)。</li>
<li>在应用更改之前获取先前的值。</li>
<li>获取应用更改后对象的状态。</li>
<li>尝试自动合并他们三个。这被委托到状态对象中，状态对象依赖于提供的<strong>合并策略</strong>(参见前文的 <strong>StateObject</strong> 定义)。</li>
</ul>
<p>事实是 runtime 中没有一个可用的策略支持正确的合并，因此碰撞更新将导致 runtime 异常并将该问题通知用户。为了避免陷入这种情况，Compose 通过使用唯一 <code>key</code> 访问状态对象（可组合函数中记住的状态对象通常具有唯一访问属性）来保证不可能发生冲突。给定 <code>mutableStateOf</code> 使用<code>StructuralEqualityPolicy</code> 进行合并，它通过等号(&#x3D;&#x3D;)深度比较对象的两个版本，因此所有的属性都会被比较，包括唯一的对象 <code>key</code> ，使得两个对象不可能碰撞。</p>
<p>自动合并冲突的更改是一个潜在的优化，Compose 还没有使用，但其他库可以使用。</p>
<p>可以通过实现 <strong>SnapshotMutationPolicy</strong> 这个接口提供一个自定义的冲突策略。从 Compose 文档中找到的一个可以作为策略参考的例子是，将<code>MutableState&lt;Int&gt;</code>作为一个计数器。该策略假设将状态值更改为相同的不会被视为更改，因此使用 <code>counterPolicy</code> 对可变状态的任何更改永远不会导致应用冲突。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2712c55cfbf574cb4c58fbbdc316e3b7.png" alt="在这里插入图片描述"></p>
<p>当两个值相同时，它们被认为是等效的，因此将保留当前值。请注意合并是如何获得的，将新应用的值与前一个值之间的差加到当前值之上，因此当前值总是反映存储的总量。</p>
<p>这一段是摘自官方文档的解释：<em>As the name of the policy implies, it can be useful when counting things, such as tracking the amount of a resource consumed or produced while in a snapshot. For example, if snapshot A produces 10 things and snapshot B produces 20 things, the result of applying both A and B should be that 30 things were produced.</em> （正如策略的名称所暗示的那样，它在计数时非常有用，例如跟踪快照中消耗或产生的资源的数量。例如，如果快照A产生了10个产物，快照B产生了20个产物，那么同时应用A和B的结果应该是产生了30个产物。）</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/72a86d653f2b3179d963aa486985c316.png" alt="在这里插入图片描述"></p>
<p>我们有一个使用计数器策略进行比较的单一可变状态，以及两个尝试修改它并应用更改的快照。这将是碰撞的完美场景，但考虑到我们的 counter 策略，任何碰撞都是完全避免的。</p>
<p>这只是如何提供自定义 <code>SnapshotMutationPolicy</code> 以避免冲突的一个简单示例，因此我们可以了解要点。另一个不可能发生冲突的实现可能是只能添加元素而不能删除元素的集合。其他有用的类型(如rope)也可以类似地转换为无冲突的数据类型，前提是它们的工作方式和预期结果受到一定的限制。</p>
<p>我们还可以提供自定义策略，接受冲突，但通过使用<code>merge</code>函数合并数据来解决冲突。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>Snapshot state 的思想是状态隔离、快照隔离。</strong></p>
</li>
<li><p><strong>基于 MVCC(多版本并发控制) 实现：</strong></p>
<ul>
<li><strong>保留数据的多个副本&#x2F;快照，每个线程在给定时刻使用一个隔离的本地副本来工作。</strong></li>
<li><strong>每个线程都将指向不同的快照，因此指向不同的状态副本。</strong></li>
<li><strong>每当写入数据时，都会创建数据的新副本，而不是修改原始数据。</strong></li>
<li><strong>内存中存储了相同数据的多个版本，或历史记录，Compose中叫状态记录 StateRecord</strong></li>
<li><strong>每个快照都被分配一个 ID，即作为事务 ID，快照 ID 是单调递增的。</strong></li>
<li><strong>读取和写入根据快照 ID 区分，相互隔离，无需进行锁定。</strong></li>
</ul>
</li>
<li><p><strong>快照生命周期：</strong></p>
<ul>
<li><strong>在调用 <code>Snapshot.takeSnapshot()</code> 时被创建，在调用 <code>snapshot.dispose()</code> 时被销毁。快照在创建和释放状态之间被视为处于活动状态。</strong></li>
<li><strong>快照不使用时，应该被销毁，否则可能泄漏相关资源。</strong></li>
</ul>
</li>
<li><p><strong><code>snapshot.enter</code>：通常称为“进入快照”，这会在快照的上下文中运行一个 lambda 表达式，一旦进入这个 lambda 中，在其范围内对状态的读取和写入都是隔离的，基于当前快照。 它允许在本地线程，与其他线程隔离。</strong></p>
</li>
<li><p><strong>常见类型的快照：</strong></p>
<ul>
<li><p><strong><code>ReadonlySnapshot</code>：只读快照</strong></p>
</li>
<li><p><strong><code>MutableSnapshot</code>：可读可写</strong></p>
</li>
<li><p><strong><code>NestedReadonlySnapshot</code>和<code>NestedMutableSnapshot</code>：嵌套快照。用于快照树中的 Child 的只读和可变快照。可以在保持父快照处于活动状态的同时独立销毁&#x2F;释放。进行子组合时，会创建一个嵌套的快照。如<code>SubcomposeLayout</code>中。</strong></p>
</li>
<li><p><strong><code>GlobalSnapshot</code>：全局共享状态的可变快照。所有快照的 root 快照。它不能嵌套，全局只有一个。</strong></p>
</li>
</ul>
</li>
<li><p><strong>Snapshot Tree ：快照可以形成一棵树，树的根是 <code>GlobalSnapshot</code>。</strong></p>
</li>
<li><p><strong>快照和线程相互独立：</strong></p>
<ul>
<li><strong>线程可以有一个当前的快照，但是快照不一定与线程绑定。线程可以随意进入和离开一个快照。</strong></li>
<li><strong><code>Snapshot.current</code> 获取当前线程的快照。它返回当前线程的快照，或者全局快照。</strong></li>
</ul>
</li>
<li><p><strong>快照的读写监听：</strong></p>
<ul>
<li><strong>如 <code>Snapshot.takeSnapshot(readObserver)</code> 可以为只读快照设置一个观察者。每当在 <code>snapshot.enter</code> 调用中从快照中读取任何状态对象时，都会通知该观察者。</strong></li>
<li><strong>可变快照可以同时设置 <code>readObserver</code> 和 <code>writeObserver</code> 观察读取和写入操作。</strong></li>
<li><strong><code>derivedStateOf</code> 函数的内部就是使用 <code>Snapshot.observe(readObserver, writeObserver, block)</code> 来在当前线程中观察读取和写入。</strong></li>
</ul>
</li>
<li><p><strong><code>Recomposer</code> 跟踪 <code>Composition</code> 中的任何读写操作，自动触发重组。这是通过向可变快照注册读写观察者实现的。</strong></p>
<ul>
<li><strong><code>Snapshot.takeMutableSnapshot(readObserver, writeObserver)</code> 在<code>Recomposer</code>进行初始组合和每次重组时都会调用它。</strong></li>
<li><strong>它在<code>snapshot.enter(block)</code>中运行组合或重组的<code>block</code>代码，因此可以被监听到。</strong></li>
<li><strong>每当快照状态写入被<code>Recomposer</code>追踪&#x2F;观察到时，读取相同的快照状态的相应的 <code>RecomposeScopes</code> 将被无效化并触发重组。</strong></li>
</ul>
</li>
<li><p><strong>快照更改的应用：</strong></p>
<ul>
<li><p><strong><code>snapshot.apply()</code> 可以应用快照更改（针对可变快照），它是原子性的操作。</strong></p>
</li>
<li><p><strong>调用 <code>apply()</code> 之后，对快照的修改会传播到其他快照。对其范围内的状态对象所做的所有局部更改都将传播到父快照(如果是嵌套可变快照)或全局状态。</strong></p>
</li>
<li><p><strong><code>Snapshot.withMutableSnapshot&#123;&#125;</code> 是会隐式调用 <code>apply()</code> 的简化版本。</strong></p>
</li>
</ul>
</li>
<li><p><strong>全局快照：</strong></p>
<ul>
<li><strong>全局快照的创建是在 <code>SnapshotKt.class</code> 类被<code>JVM</code>初始化时。</strong></li>
<li><strong>创建 <code>Composer</code> 时会启动一个全局快照管理器，在创建 <code>Composition</code> 时，会调用 <code>GlobalSnapshotManager.ensureStarted()</code> 将开始观察所有对全局状态的写入。</strong></li>
<li><strong>每个组合创建自己的嵌套可变快照并将其附加到快照树中，而全局快照是这个树的根，因此全局快照管理器可以存储和隔离组合的所有状态。</strong></li>
</ul>
</li>
<li><p><strong>快照状态的内部表示：</strong></p>
<ul>
<li><strong>MVCC 确保每次写入状态时，都会创建一个新版本(写时复制)。</strong></li>
<li><strong>快照状态对象的内部实现是一个 <code>StateObject</code>，在多版本中，为该对象存储的每一个版本的存储形式的都是一个 <code>StateRecord</code>。</strong></li>
<li><strong>每个记录都保存状态的一个版本的信息，每个记录与创建记录的快照 <code>ID</code> 相关联，快照 <code>ID</code> 是递增的，这样每个版本的记录形成一个按 <code>ID</code> 递增的单链表。</strong></li>
<li><strong>每个快照所看到的版本（记录）对应于拍摄快照时可用的最新有效版本。</strong></li>
<li><strong>最新有效版本是指处于该快照之前创建的记录且该记录不是<code>invalid</code>也没有被加入<code>invalid</code>列表中。</strong></li>
</ul>
</li>
<li><p><strong>状态读写：</strong></p>
<ul>
<li><strong>当读取一个对象时，将遍历给定快照状态（<code>StateObject</code>）的<code>StateRecords</code>列表，查找最近的有效记录（具有最高的快照<code>ID</code>）</strong></li>
<li><strong>写入时使用当前最新的有效记录作为候选记录。如果它对于当前快照有效，就使用它来进行写入，否则它将创建一个新的记录并将其添加到列表的开头，使其成为新的初始记录。</strong></li>
<li><strong>读写完毕后都会通知任何已注册的读观察者和写观察器者。</strong></li>
</ul>
</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6d9a9bbe48b69d7a0b9cdb2725592d3d.png" alt="在这里插入图片描述"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/State%20Snapshot%20System/">https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/State%20Snapshot%20System/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E3%80%81%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/" title="Compose中的动态加载、插件化技术探索"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Compose中的动态加载、插件化技术探索</div></div><div class="info-2"><div class="info-item-1">在传统的 Android 开发模式中，由于界面过分依赖于 Activity、Fragment这样的组件，一个业务模块中往往会存在着大量的 Activity 类，因此诞生了很多的插件化框架，这些插件化框架基本都是想方设法的使用各种Hook&#x2F;反射手段来解决使用未注册的组件问题。在进入 Jetpack Compose 的世界以后，Activity 的角色被淡化了，由于一个 Composable 组件就可以承担一个屏幕级的显示，因此我们的应用中不再需要那么多的 Activity 类，只要你喜欢，你甚至可以打造一个单 Activity 的纯 Compose 应用。 本文主要尝试探索几种可以在 Jetpack Compose 中实施插件化&#x2F;动态加载的可行性方案。 以 Activity占坑的方式访问插件中的 Composable 组件这种方式其实传统 View 开发也可以做，但是由于 Compose 中我们可以只使用一个Activity，而其余页面均使用 Composable...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/compose/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8FUI/" title="什么是声明式UI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">什么是声明式UI</div></div><div class="info-2"><div class="info-item-1">到底什么是声明式UI，声明式可以理解为一种编程思维，只要是基于这种编程思维来使用的，都可以称之为声明式UI框架。 过程式思维拿View来举例，View更多是一种过程式的思维，我们在描述一个View的时候是不会描述它的状态的，或者只会描述它的初始状态。如果后续想要更新View的状态只能获取到View的实例，再通过相应的方法改变它的状态。这就是过程式的思维。 声明式思维声明式思维的工作流程类似于刷新网页。即我们仍然正常地去描述一个控件，但是需要附带上它的状态。然后当有任何状态发生改变时，只需要像刷新网页一样，让整个界面的所有元素都刷新一遍，自然所有状态都得到更新了。事实上，所有的声明式UI框架都会采取优化措施，避免刷新整个界面，而是只更新状态有变的控件。 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Snapshot-State"><span class="toc-number">1.</span> <span class="toc-text">什么是 Snapshot State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">并发控制系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-MVCC"><span class="toc-number">3.</span> <span class="toc-text">多版本并发控制 (MVCC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshot"><span class="toc-number">4.</span> <span class="toc-text">Snapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Snapshot-Tree-%E5%BF%AB%E7%85%A7%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">Snapshot Tree (快照树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">快照和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%AF%BB%E5%86%99"><span class="toc-number">7.</span> <span class="toc-text">观察读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutableSnapshot"><span class="toc-number">8.</span> <span class="toc-text">MutableSnapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GlobalSnapshot-%E5%92%8C-Nested-Snapshot"><span class="toc-number">9.</span> <span class="toc-text">GlobalSnapshot 和 Nested Snapshot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StateObject-%E5%92%8C-StateRecord"><span class="toc-number">10.</span> <span class="toc-text">StateObject 和 StateRecord</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%8A%B6%E6%80%81"><span class="toc-number">11.</span> <span class="toc-text">读写状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%88%96%E5%A4%8D%E7%94%A8%E5%BA%9F%E5%BC%83%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">12.</span> <span class="toc-text">删除或复用废弃的记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%9B%B4%E4%BC%A0%E6%92%AD"><span class="toc-number">13.</span> <span class="toc-text">变更传播</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E6%8C%82%E8%B5%B7%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%94%B9"><span class="toc-number">13.1.</span> <span class="toc-text">没有挂起的本地更改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%8C%82%E8%B5%B7%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%94%B9"><span class="toc-number">13.2.</span> <span class="toc-text">有挂起的本地更改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%86%99%E5%86%B2%E7%AA%81"><span class="toc-number">14.</span> <span class="toc-text">合并写冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">15.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>