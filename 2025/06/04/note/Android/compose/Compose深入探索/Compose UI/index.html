<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Compose UI | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="通过 Compose runtime 集成 UICompose UI 是一个 Kotlin 多平台框架。它提供了通过可组合函数发出 UI 的构建块和机制。除此之外，这个库还包括 Android 和 Desktop 源代码，为 Android 和 Desktop 提供集成层。  JetBrains积极维护Desktop代码库，而Google维护Android和通用代码库。Android和Deskto">
<meta property="og:type" content="article">
<meta property="og:title" content="Compose UI">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20UI/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="通过 Compose runtime 集成 UICompose UI 是一个 Kotlin 多平台框架。它提供了通过可组合函数发出 UI 的构建块和机制。除此之外，这个库还包括 Android 和 Desktop 源代码，为 Android 和 Desktop 提供集成层。  JetBrains积极维护Desktop代码库，而Google维护Android和通用代码库。Android和Deskto">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.123Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.123Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Compose UI",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20UI/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.123Z",
  "dateModified": "2025-06-04T12:46:35.123Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20UI/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compose UI',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Compose UI</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Compose UI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.123Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.123Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="通过-Compose-runtime-集成-UI"><a href="#通过-Compose-runtime-集成-UI" class="headerlink" title="通过 Compose runtime 集成 UI"></a>通过 Compose runtime 集成 UI</h3><p>Compose UI 是一个 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Kotlin&spm=1001.2101.3001.7020">Kotlin</a> 多平台框架。它提供了通过可组合函数发出 UI 的构建块和机制。除此之外，这个库还包括 Android 和 Desktop 源代码，为 Android 和 Desktop 提供集成层。</p>
<blockquote>
<p>JetBrains积极维护Desktop代码库，而Google维护Android和通用代码库。Android和Desktop源代码库都依赖于通用源代码库。到目前为止，Web还没有出现在Compose UI中，因为它是使用DOM构建的。</p>
</blockquote>
<p>当使用 Compose runtime 集成 UI 时，目标是构建用户可以在屏幕上体验的布局树。这个树是通过执行发出 UI 的 Composable 函数来创建和更新的。用于树的节点类型只有 Compose UI 知道，所以 Compose runtime 可以不知道它。即使 Compose UI 本身已经是一个Kotlin多平台框架，它的节点类型到目前为止只被 Android 和 Desktop 支持。其他库，如 Compose for Web 使用不同的节点类型。出于这个原因，客户端库发出的节点类型必须只有客户端库知道，并且 runtime 将从树中插入、删除、移动或替换节点的操作委托给客户端库。我们将在后面讨论这个问题。</p>
<p>初始组合和后续的重组过程都参与了布局树的构建和更新过程。这些过程执行我们的 Composable 函数，这使它们能够安排从树中插入、删除、移动或替换节点的更改。这将创建一个更改列表，稍后将使用 Applier 遍历这些更改，以检测影响树结构的更改，并将这些更改映射到树的实际更改，以便最终用户可以体验它们。 如果我们在初始的组合过程中，这些更改将插入所有节点，从而建立我们的布局树。如果我们在重组过程中，他们会被更新。当我们的可组合函数的输入数据（即参数或读取的可变状态）发生变化时，将触发重组。</p>
<h3 id="从-Compose-UI-的角度来看组合"><a href="#从-Compose-UI-的角度来看组合" class="headerlink" title="从 Compose UI 的角度来看组合"></a>从 Compose UI 的角度来看组合</h3><p>如果我们以 Android 集成为例，从 Compose UI 库进入 runtime 的更频繁的入口点发生在我们调用<code>setContent</code> 时，可能是针对我们的一个屏幕。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2b8f502072f1a258cf5b02cdfdb858ab.png" alt="在这里插入图片描述"></p>
<p>但是屏幕 (例如Android中的<code>Activity</code>&#x2F;<code>Fragment</code>) 并不是我们可以找到<code>setContent</code>调用的唯一地方。它也可以发生在我们的视图层次结构的中间，例如，通过 <code>ComposeView</code> (例如在一个混合 Android App里)。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a14af4308237ea9cb4ec1b51a380acb6.png" alt="在这里插入图片描述"><br>在本例中，我们通过编程方式<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE&spm=1001.2101.3001.7020">创建视图</a>，但它也可以是应用程序中通过XML定义的任何布局层次结构的一部分。</p>
<p><code>setContent</code>函数创建了一个新的 <strong>root Composition</strong>，然后尽可能地重用它。我把它们称为“根”组合，因为每个组合都有一个独立的 Composable 树。这些组合之间没有任何联系。每个组合将像它所代表的 UI 一样简单或复杂。</p>
<p>在这种思维模式下，我们可以想象应用程序中有多个节点树，每个节点树都链接到不同的 <strong>Composition</strong>。让我们想象假如有一个包含 3 个<code>Fragment</code>的 Android 应用，其中<code>Fragment1</code>和<code>Fragment3</code>调用<code>setContent</code>来 <code>hook</code> 它们的 Composable 树，而<code>Fragment2</code>在它的布局上声明了多个<code>ComposeView</code>(并调用<code>setContent</code>)。在这种情况下，我们的应用程序将有 5 个根 <strong>Composition</strong>，它们都完全独立。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8e3b58b35c2c2ba5d3afdb8c4e3af145.png" alt="在这里插入图片描述"><br>为了创建这些布局层次结构，相关的 <strong>Composer</strong> 将运行组合过程。相应 <code>setContent</code> 调用的所有 <strong>Composable</strong> 函数都将执行并发出它们的更改。对于 <strong>Compose UI</strong> ，这些更改就是插入、移动或替换 UI 节点，而这些操作通常是由构建 UI 的 block 代码块发出的。即：<strong>Box</strong>，<strong>Column</strong>，<strong>LazyColumn</strong> 等。即使这些 <strong>Composables</strong> 函数通常属于不同的库（<code>foundation</code>、<code>material</code>），它们最终都被定义为 <strong><code>Layout</code></strong>（<code>compose-ui</code>），这意味着它们发出相同的节点类型：<strong>LayoutNode</strong>。</p>
<p><strong>LayoutNode</strong> 在之前介绍过，它是 UI block 的表示形式，因此在 <strong>Compose UI</strong> 中，它是用于根 <strong>Composition</strong> 最常用的节点类型。</p>
<p>任何 <strong>Layout Composable</strong> 函数都会将 <strong>LayoutNode</strong> 节点发射到 <strong>Composition</strong> 中，这是通过 <strong>ReusableComposeNode</strong> 发射的。（请注意，<strong>ComposeUiNode</strong> 是一个通用接口协议，<strong>LayoutNode</strong> 接口实现了它）</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a946be050ad8710bd1e65bd217a214a7.png" alt="在这里插入图片描述"></p>
<p>这里发出一个更改，将可重用的节点插入或更新到 composition 中。这将适用于我们使用的任何 UI 构建 block 块。</p>
<blockquote>
<p>可重用节点是 Compose runtime 中的一种优化。当节点的键（<code>key</code>）发生变化时，可重用节点允许 Compose 在重组时更新节点内容（就地更新），而不是将其丢弃并创建一个新节点。为了实现这一点，Composition 就像正在创建新的内容一样，但是 <code>slot table</code> 在重组时被遍历。这种优化仅适用于那些在发射调用过程中，可以完全被 <code>set</code> 和 <code>update</code> 操作描述的节点，或者换句话说，不包含隐藏内部状态的节点。这对于 <strong>LayoutNode</strong> 是正确的，但对于 <strong>AndroidView</strong> 就不是这样了。因此，<strong>AndroidView</strong> 使用标准的 <strong>ComposeNode</strong> 而不是可重用节点。</p>
</blockquote>
<p>在上面代码中，我们可以看到 <strong>ReusableComposeNode</strong> 会创建节点（通过<code>factory</code>工厂函数），初始化它（ <code>update</code> lambda），并创建一个可替换的<code>group</code>组来包装所有内容。该<code>group</code>会被分配一个唯一的<code>key</code>，以便稍后可以识别它。通过可替换的<code>group</code>内的 <code>content</code> lambda 的调用而发出的任何节点，实际上都将成为该节点的子节点。</p>
<p>在 <code>update</code> block 块内的 <code>set</code> 方法调用会安排其后的 lambda 执行。这些 lambda 执行的时机是：节点第一次创建时，或对应属性的值自上次被 <code>remembered</code> 后已更改时。</p>
<p>这就是 <strong>LayoutNode</strong> 是如何被提供给我们应用中的多个 <strong>Compositions</strong> 的。这可能会让我们认为任何 <strong>Composition</strong> 都只包含 <strong>LayoutNode</strong>。但这是错误的！在 <strong>Compose UI</strong> 中，还有其他类型的 <strong>Compositions</strong> 和节点类型需要考虑。虽然 <strong>LayoutNodes</strong> 是最常用的节点类型，但还有其他类型的节点，比如 <strong>ModifierNode</strong>、<strong>AttachNodes</strong> 等等。它们都是由 Composable 函数发出，但是不同于 LayoutNode，它们可能只代表对树上现有节点的修改而非全新节点的插入或替换。因此，runtime 需要有一些机制来处理这些不同类型的节点并将它们合并到同一棵树中。</p>
<h3 id="从-Compose-UI-的角度来看子组合（Subcomposition）"><a href="#从-Compose-UI-的角度来看子组合（Subcomposition）" class="headerlink" title="从 Compose UI 的角度来看子组合（Subcomposition）"></a>从 Compose UI 的角度来看子组合（Subcomposition）</h3><p><strong>Composition</strong> 不仅仅存在于 <strong>root</strong> 级别。我们也可以在<strong>Composable 树</strong>的更深层次中创建<strong>Composition</strong>，并将其链接到其父<strong>Composition</strong>。这就是Compose所谓的 <strong><code>Subcomposition</code></strong> 。</p>
<p>我们在前面学到的一件事是，<strong>Composition</strong>可以连接为<strong>树形结构</strong>。也就是说，<strong>每个Composition 都有一个指向其父 CompositionContext 的引用</strong>，该引用代表其父 <strong>Composition</strong>（当root的parent为Recomposer本身时除外）。这就是 runtime 如何确保<code>CompositionLocals</code>和无效化可以像单个Composition一样在树中向下传播的方式。</p>
<p>在Compose UI中，创建 <strong>Subcomposition</strong> 主要有两个原因：</p>
<ul>
<li><strong>推迟初始组合过程，直到某些信息已知。</strong></li>
<li><strong>修改子树生成的节点类型。</strong></li>
</ul>
<p>让我们来讨论一下这两个原因。</p>
<h4 id="延迟初始组合过程"><a href="#延迟初始组合过程" class="headerlink" title="延迟初始组合过程"></a>延迟初始组合过程</h4><p>我们有一个关于 <strong>SubcomposeLayout</strong> 例子，它类似于 <strong>Layout</strong>，会在布局阶段创建和运行一个独立的 <strong>Composition</strong>。这允许子 <strong>Composables</strong> 依赖于其计算的任何结果。例如，<strong>BoxWithConstraints</strong> 组件就是使用 <strong>SubcomposeLayout</strong>实现的，它在 block 块中公开其接收的父约束，以便可以根据它们调整其内容。以下是从官方文档中提取的示例，在<strong>BoxWithConstraints</strong> 中根据可用的最大高度在两个不同的 Composables 之间做出选择：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6b948844dd600f5c0efd8c73156937dd.png" alt="在这里插入图片描述"><br><strong>Subcomposition</strong> 的创建者可以控制初始组合过程发生的时间，而 <strong>SubcomposeLayout</strong> 决定在<strong>布局阶段</strong>进行它，而不是在根组合时。</p>
<p><strong>Subcomposition</strong> 允许独立于父 <strong>Composition</strong> 进行重组。例如，在 <strong>SubcomposeLayout</strong>中，每当发生 layout 布局时，传递给其 lambda 的参数可能会发生变化，这将触发重组。另一方面，如果从 Subcomposition 中读取的状态发生更改，则将在执行初始组合后为父组合安排重组。</p>
<p>从发出的节点方面考虑，<strong>SubcomposeLayout</strong> 也会发出一个 <strong>LayoutNode</strong>，因此子树使用的节点类型将与父 <strong>Composition</strong> 使用的节点类型相同。这引出了以下问题：是否可以在单个 <strong>Composition</strong> 中支持<strong>不同的节点类型</strong>？</p>
<p>好吧，从技术上来讲是可以实现的，只要相应的 <strong>Applier</strong> 允许。这取决于节点类型的含义。如果使用的节点类型是多个子类型的共同父级，则可以支持不同的节点类型。即便如此，这样做可能会使<strong>Applier</strong> 的逻辑更加复杂。事实上，在 <strong>Compose UI</strong> 中可用的 <strong>Applier</strong> 实现都被固定为<strong>单个节点类型</strong>。</p>
<p>也就是说，<strong>Subcomposition</strong> 实际上<strong>可以在子树中支持完全不同的节点类型</strong>，这是我们前面列出的使用 <strong>Subcomposition</strong> 的第二个原因。</p>
<h4 id="更改子树中的节点类型"><a href="#更改子树中的节点类型" class="headerlink" title="更改子树中的节点类型"></a>更改子树中的节点类型</h4><p><strong>Compose UI</strong> 中有一个很好的例子可以解释这个概念：创建和显示<strong>矢量图形</strong>的Composable（例如：<code>rememberVectorPainter</code>）。</p>
<p><strong>Vector Composables</strong> 是一个很好的研究案例，因为它们还创建了自己的 <strong>Subcomposition</strong> 来将矢量图形建模为一棵树。在组合时，<strong>Vector Composable</strong> 会发出一个不同于<strong>LayoutNode</strong>的节点类型来提供给其 <strong>Subcomposition</strong>：<strong>VNode</strong> 类型。这是一个递归类型，用于建模独立的 <code>Paths</code> 或 <code>Paths</code> 组。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d773991bf4ae93550824448cad10f425.png" alt="在这里插入图片描述"></p>
<p>这里有一件有趣的事情需要思考，通常我们使用 <strong>VectorPainter</strong> 在 <strong>Image</strong>、<strong>Icon</strong> 或其他类似的 Composable 组件中来绘制这些矢量图形，就像我们在上面的代码片段中看到的那样。这意味着包含它的 Composable 是一个 <strong>Layout</strong>，因此它会发出一个 <strong>LayoutNode</strong> 到其关联的 <strong>Composition</strong> 中。但同时，<strong>VectorPainter</strong> 创建了自己的 <strong>Subcomposition</strong> 来模拟矢量图形的树形结构，并将其链接到前一个 <strong>Composition</strong> 中（前者会成为其父级）。以下是一个图形示例：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ff57e99520d284f9eadebf0cce2fe65d.png" alt="在这里插入图片描述"></p>
<p>这种配置使得 vector 子树(<code>Subcomposition</code>)可以使用不同的节点类型：<code>VNode</code>。</p>
<p><strong>Vectors</strong> 通过 <strong>Subcomposition</strong> 进行建模，因为通常可以从父组合中访问某些 <code>CompositionLocals</code> 以在 <strong>vector Composable</strong> 调用中使用（例如：<code>rememberVectorPainter</code>）。诸如主题颜色或density之类的东西就是很好的例子。</p>
<p>用于矢量图的<strong>子组合</strong>（<strong>Subcomposition</strong>）会在其对应的 <strong>VectorPainter 离开父 Composition 时被销毁</strong> 。我们将在后面学习更多有关 Composable 生命周期的知识，但请记住，任何 <strong>Composable</strong> 都会在某个时刻进入和离开 <strong>Composition</strong>。</p>
<p>现在我们已经对使用 Compose UI 的应用（Android 或 Desktop）中树的外观有了更完整的了解，其中通常存在 <strong>root Composition</strong> 和 <strong>Subcomposition</strong>。</p>
<h3 id="反映-UI-中的变化"><a href="#反映-UI-中的变化" class="headerlink" title="反映 UI 中的变化"></a>反映 UI 中的变化</h3><p>在前面，我们已经了解了 UI 节点是如何通过初始化合成和后续的重组合成被发射到 runtime 中的。此时，runtime 会接管这些节点，并执行其工作。但这只是一面，还需要存在某种集成来在实际的 UI 中反映所有这些发射的更改，以便用户可以体验它们。这个过程通常被称为节点树的 <strong>Materialization</strong> (中文翻译过来可以叫<strong>实体化</strong>、<strong>实例化</strong>、<strong>具体化</strong>)，这也是客户端库（Compose UI）的职责之一。</p>
<h3 id="不同类型的-Appliers"><a href="#不同类型的-Appliers" class="headerlink" title="不同类型的 Appliers"></a>不同类型的 Appliers</h3><p><strong>Applier</strong> 是一个抽象层，runtime 依赖于它最终实现树中的任何更改。这反转了依赖关系，使 runtime 完全不依赖于使用库的平台。这个抽象层允许客户端库（如Compose UI）hook 自己的 Applier 实现，并使用它们自己的节点类型来集成平台。下面是一个简单的图示：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/44ac9a8a0fda62cbf82aa17ca43f7805.png" alt="在这里插入图片描述"></p>
<p>（<em>顶部的两个方框（<strong>Applier</strong>和<strong>AbstractApplier</strong>）是 <strong>Compose runtime</strong> 的一部分。底部列出了一些 <strong>Applier</strong> 实现，它们由 <strong>Compose UI</strong> 提供。</em>）</p>
<p><strong>AbstractApplier</strong> 是 <strong>Compose runtime</strong> 提供的基本实现，用于在不同 <strong>applier</strong> 之间<strong>共享逻辑</strong>。它将<strong>已访问</strong>的节点存储在一个<strong>栈</strong>中，并维护对当前访问节点的引用，以便知道应该在哪个节点上执行操作。每当沿着树访问到一个新节点时，<strong>Composer</strong> 通过调用 <strong><code>applier#down(node:N)</code></strong> 来通知 <strong>Applier</strong>。这会将节点<strong>压入栈</strong>中，<strong>Applier</strong> 可以对其运行任何所需的操作。</p>
<p>每当访问者需要返回到父节点时，<strong>Composer</strong> 就会调用 <strong><code>applier#up()</code></strong>，这将从<strong>堆栈中弹出</strong>上次访问的节点。</p>
<p>让我们通过一个相当简单的例子来理解它。假设我们有以下需要 <strong>materialize</strong> 的 <strong>Composable</strong> 树：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b09dd55e9b413a0f5fa0c0861814d030.png" alt="在这里插入图片描述"></p>
<p>当 <code>condition</code> 改变时，<strong>Applier</strong> 将会：</p>
<ul>
<li>接收一个 <code>down()</code> 调用以访问 <code>Column</code>节点。</li>
<li>然后是另一个 <code>down()</code> 调用以进入 <code>Row</code> 节点。</li>
<li>接着是删除（或插入，具体取决于<code>condition</code>）可选子 <code>Text</code> 节点。</li>
<li>然后是一个 <code>up()</code> 调用以返回到父节点（<code>Column</code>）。</li>
<li>最后，删除（或插入）第二个条件文本 <code>Text</code> 节点。</li>
</ul>
<p><strong>AbstractApplier</strong> 提供了<strong>堆栈</strong>和 <code>down</code> 和 <code>up</code> 操作，因此子 <strong>applier</strong> 可以共享相同的导航逻辑，而不管它们使用的节点类型如何。这提供了节点之间的父子关系，因此在导航树时，从技术上讲，它消除了特定节点类型维护此关系的需要。即使如此，特定的节点类型仍然可以自由地实现自己的父子关系，如果它们碰巧需要它们用于特定于客户库的更特定的原因。</p>
<blockquote>
<p>这实际上是 <strong>LayoutNode</strong> 的情况，因为并非所有操作都在组合期间执行。例如，如果由于某种原因需要重绘节点，则 <strong>Compose UI</strong> 会遍历父节点，以查找创建绘制节点所需的层的节点，以便在其上调用<code>invalidate</code>。所有这些操作都发生在组合之外，因此 Compose UI 需要一种方法来自由遍历树形结构。</p>
</blockquote>
<p>让我们回顾一下在上一篇文章中，我们提到了 <strong>Applier</strong> 如何以<strong>从上到下</strong>或<strong>从下到上</strong>的两种方式来构建节点树。我们还描述了每种方法的性能影响，并且这些影响取决于每次插入新节点时需要通知的节点数。（ <a target="_blank" rel="noopener" href="https://blog.csdn.net/lyabc123456/article/details/129138077">可以点击这里回顾其中的<strong>构建节点树时的性能</strong>部分</a> ）我想回顾一下这一点，因为Compose UI中实际上有两种构建节点树的策略的例子。这些策略由库使用的两种 <strong>Applier</strong> 实现。</p>
<p>Jetpack Compose 提供了两个 <strong>AbstractApplier</strong> 的实现来将 <strong>Android</strong> 平台与 <strong>Jetpack Compose runtime</strong> 集成：</p>
<ul>
<li><strong>UiApplier</strong>：用于呈现大多数 <strong>Android UI</strong> 。它将节点类型固定为 <strong>LayoutNode</strong>，因此它将实现我们树中的所有 <strong><code>Layouts</code></strong> 布局。</li>
<li><strong>VectorApplier</strong>：用于呈现矢量图形。它将节点类型固定为 <strong>VNode</strong>，以表示和实现矢量图形。</li>
</ul>
<p>如前面介绍的那样，这是两种节点类型。</p>
<blockquote>
<p>到目前为止，这是 Android 提供的唯一两个实现，但是对于一个平台来说，可用的实现并不一定是固定的。如果需要表示不同于现有节点树的节点树，则未来可能会在 Compose UI 中添加更多实现。</p>
</blockquote>
<p>根据访问的节点类型，将使用不同的 <strong>Applier</strong> 实现。例如：如果我们有一个使用 <strong><code>LayoutNodes</code></strong> 提供的 <strong>root Composition</strong>，以及使用 <strong><code>VNodes</code></strong> 提供的 <strong>Subcomposition</strong>，那么两个 <strong>Applier</strong> 都将被用于将完整的 UI 树实例化。</p>
<p>让我们快速浏览一下两种 Applier 用于构建树的策略。</p>
<p><strong>UiApplier</strong> 采用<strong>自下而上</strong>的方式插入节点。这是为了<strong>避免新节点进入树时出现重复通知</strong>。</p>
<p>这里再贴一遍前一篇中的自下而上插入策略图示以使其更清晰。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3188623eced41062ef96d800e68dc6f2.png" alt="在这里插入图片描述"></p>
<p>自下而上构建树的方式是先将 <strong>A</strong> 和 <strong>C</strong> 插入 <strong>B</strong>，然后将 <strong>B</strong> 树插入 <strong>R</strong> 中，从而完成树的构建。这意味着每次插入新节点时，只通知<strong>直接父节点</strong>。这对于 <strong>Android UI</strong>（也就是 <strong>UiApplier</strong>）特别有意义，因为我们通常有很多<strong>嵌套</strong>（特别是在 <strong>Compose UI</strong> 中，过度绘制不是问题），因此需要通知许多祖先。</p>
<p>另一方面，<strong>VectorApplier</strong> 是一个<strong>自上而下</strong>构建树的示例。如果我们想使用自上而下的策略构建上面的示例树，我们会先将 <strong>B</strong> 插入到 <strong>R</strong> 中，然后将 <strong>A</strong> 插入到 <strong>B</strong> 中，最后将 <strong>C</strong> 插入到 <strong>B</strong> 中。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7376b688e94e92453173318bb421c946.png" alt="在这里插入图片描述"><br>在这种策略中，每次插入一个新节点时，我们都需要通知它的<strong>所有祖先节点</strong>。但在矢量图形的情况下，没有必要将通知传播到任何节点，因此两种策略的性能都是相等的，因此完全有效。没有一个很强的理由支持从上往下的构建比从下往上的构建更好。每当一个新的子节点被插入到一个 <strong><code>VNode</code></strong> 中时，该节点的监听器（listener）会被通知，但是它的子节点或父节点不会被通知。</p>
<p>既然我们已经很好地了解了 Compose UI 库使用的两种不同的 Applier 实现，那么接下来是时候了解它们是如何最终实现UI中的变化的了。</p>
<h3 id="实体化-插入一个新的-LayoutNode"><a href="#实体化-插入一个新的-LayoutNode" class="headerlink" title="实体化&#x2F;插入一个新的 LayoutNode"></a>实体化&#x2F;插入一个新的 LayoutNode</h3><p>下面是 Compose UI 使用的 <strong>UiApplier</strong> 的简化版：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/01e4010e3d44fc60108b26ec9af63f72.png" alt="在这里插入图片描述"></p>
<p>在这个实现中，我们清楚地看到节点类型被固定为 <strong>LayoutNode</strong>，以及所有插入、删除或移动节点的操作都委托给当前访问的节点。这是有道理的，因为 <strong>LayoutNode</strong> 知道如何实现自身，因此 runtime 可以对此保持无感知。</p>
<p>这个 <strong>LayoutNode</strong> 是一个纯 Kotlin 类，没有任何 <strong>Android</strong> 依赖，因为它只建模了一个 UI 节点，而且应该被多个平台（Android、Desktop）使用。它维护其子节点列表，并提供插入、删除或移动（重新排序）子节点的操作。所有的 <strong>LayoutNodes</strong> 被连接成一棵树，所以每个 <strong>LayoutNode</strong> 都有一个指向其父节点的<strong>引用</strong>，并且它们全部连接到同一个 <strong>Owner</strong>。每个新加入的节点都需要满足这个要求。下面是我们之前的文章中提到是层次结构图。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/cb73084bd20bb5295c71ac50972d489e.png" alt="在这里插入图片描述"><br>这里的 <strong>Owner</strong> 是一个抽象层，因此每个平台可以不同的方式实现它。它有望成为与平台的集成点。在 <strong>Android</strong> 中，它是一个 <strong><code>View</code></strong> (<strong><code>AndroidComposeView</code></strong>)，因此它是我们的 <strong>Composable 树</strong>（<strong>LayoutNodes</strong>） 和 <strong>Android View</strong> 系统之间的底层连接。</p>
<p>无论何时节点被<code>attach</code>、<code>detach</code>、<code>reoder</code>、<code>remeasure</code>或如何<code>update</code>，都可以通过使用旧的 <strong>Android View</strong> API 的 <strong>Owner</strong> 触发失效，因此最新的更改将在下一个绘制阶段反映在屏幕上。这就是奇迹发生的过程。</p>
<p>让我们深入研究一下 <strong><code>LayoutNode#insertAt</code></strong> 操作的简化，以便了解如何插入新节点并实现新节点。（注意，这里故意省略一些细节，因为实现细节可能会随着时间的推移而不断变化。）</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/162c469e4e11106dd9d12f3d1b9b8e1e.png" alt="在这里插入图片描述"></p>
<p>在进行了几次安全检查以确保该节点没有在树中，也没有附加，然后将当前节点设置为插入的新节点的父节点。然后，新节点被添加到它的新父节点维护的子节点列表中。在此之上，按照 <strong>Z</strong> 轴索引中排序的子元素列表将会被失效。这是一个并行列表，它维护所有按照 <strong>Z</strong> 轴索引排序的子元素，因此它们可以按顺序绘制（<strong>Z</strong> 轴 index 较低的先绘制）。使列表无效会使它重新排序。在插入一个新节点之后，这是必要的，因为 <strong>Z</strong> 轴索引不仅由布局中 <code>placeable.place()</code> 调用的顺序（它们被摆放的顺序）决定，而且还可以通过修饰符设置为任意值。如 <code>Modifier.zIndex()</code> 。(这相当于在布局中，当过时的 <strong>Views</strong> 被放置在其他 <strong>Views</strong> 之后时，如何将它们显示在其他 <strong>Views</strong> 之上，以及如何将它们的 <strong>Z</strong> 轴索引设置为任意值)。</p>
<p>接下来我们看到的是一个涉及某种 “<strong>outer</strong>” 和 “<strong>inner</strong>” 的 <strong>LayoutNodeWrappers</strong> 的赋值。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e74d601a19e877150ff0eaaebbe114e1.png" alt="在这里插入图片描述"></p>
<p>这与一个Node节点、其修饰符、及其子节点如何被测量和绘制有关。（由于涉及一些复杂性，因此将后面独立的小节中详细描述）</p>
<p>最后就是附加节点的时候了（attach），这意味着将其分配给与其新的父节点相同的 <strong>Owner</strong>。下面是<code>attach</code>调用的简化，它在插入的节点上调用 <code>instance.attach(owner)</code> :</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/439c52469742d2aeaa9f5d65f307a418.png" alt="在这里插入图片描述"></p>
<p>在这里，我们发现有一个防御代码，它强制要求所有子节点都被分配与其父节点相同的 <strong>Owner</strong>。由于 <code>attach</code> 函数会在子节点上递归调用，因此挂在该节点上的完整子树最终将附加到同一个 <strong>Owner</strong>。也就是说，将来自同一个 Composable 树的任何节点所需的所有失效强制通过同一个 <strong>View</strong> 进行传递，这样它就可以处理所有协调。在防御代码之后，<strong>owner</strong>对象被保存到当前节点中。</p>
<p>此时，如果附加的节点包含任何语义元数据，就会通知 <strong>Owner</strong>。这可能发生在插入节点或删除节点时。如果更新了节点的值，或者，添加或删除了语义修饰符而没有添加或删除实际的节点，也会发生这种情况。在 <strong>Android</strong> 中，<strong>Owner</strong> 有一个专门的 accessibility 委托，负责转发通知，因此它可以处理更改，更新语义树，并与 Android SDK accessibility API 进行连接。</p>
<blockquote>
<p>语义树是一个并行的树，以一种可以被辅助功能服务和测试框架理解的方式描述UI。有两棵并行的语义树，我们将在后面的部分详细描述它们。</p>
</blockquote>
<p>然后，主动请求了对新节点及其父节点进行重新测量（即<code>requestRemeasure()</code>）。这是整个过程中非常重要的一步，因为它有效地<strong>实体化</strong>了节点：任何重新测量请求都通过 <strong>Owner</strong> 传递，如此它就可以在需要时，使用 <strong>View</strong> 原语来调用 <strong><code>invalidate()</code></strong> 或者 <strong><code>requestLayout()</code></strong> 。这样就使得节点最终显示在屏幕上了。</p>
<h3 id="完成闭环"><a href="#完成闭环" class="headerlink" title="完成闭环"></a>完成闭环</h3><p>为了完整闭环，当在 <code>Activity</code>、<code>Fragment</code> 或 <code>ComposeView</code> 中调用 <code>setContent</code> 函数时，<strong>Owner</strong> 将被附加到视图层次结构中。这是目前唯一缺失的部分。</p>
<p>让我们通过一个简单的例子来回顾一下整个过程。假设我们有以下树形结构，其中调用了 <strong><code>Activity#setContent</code></strong> ，因此会创建一个 <strong><code>AndroidComposeView</code></strong> 并将其附加到视图层次结构中。同时我们已经有了一些 <strong>LayoutNodes</strong>：一个根节点（<code>(LayoutNode(A)</code>）和一个子节点（<code>LayoutNode(B)</code>）。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0d87755d33d9557b8802c5b7010cf1f7.png" alt="在这里插入图片描述"></p>
<p>现在，让我们假设 <strong>Applier</strong> 调用 <strong><code>current.insertAt(index, instance)</code></strong> 来插入（实例化）一个新节点<code>LayoutNode(C)</code>。这将连接新节点，并通过 <strong>Owner</strong> 请求自己和新父节点的重新测量。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c9011c23aeb548cfd639def4bf1f1bf5.png" alt="在这里插入图片描述"></p>
<p>当这种情况发生时，大多数情况下会调用 <strong><code>AndroidComposeView#invalidate</code></strong>。 就算如果有两个节点（当前节点和父节点）在同一时刻对相同的 <strong>View</strong>（<strong>Owner</strong>）发起失效操作，也没有关系，因为无效化就是将 <strong>View</strong> 标记为 <strong>dirty</strong> (脏的) 。在两个帧之间，你可以多次执行此操作，但在任何情况下，<strong>View</strong> 都将仅在下一个<strong>绘制阶段</strong>重绘<strong>一次</strong>。在那个时候，<strong><code>AndroidComposeView#dispatchDraw</code></strong> 将被调用，这是 Compose UI 执行所有请求节点的实际<strong>重新测量</strong>和<strong>布局</strong>的地方。如果在这个<strong>重新测量</strong>过程中，根节点的<strong>大小</strong>发生了变化，则会调用 <strong><code>AndroidComposeView#requestLayout()</code></strong> ，以便重新触发 <strong><code>onMeasure</code></strong> 并能够影响所有 <strong>View</strong> 兄弟节点的大小</p>
<p>测量和布局完成后，<strong><code>dispatchDraw</code></strong> 调用将最终调用根 <strong>LayoutNode</strong> 的 <strong><code>draw</code></strong> 函数，它知道如何将自己绘制到 <strong>Canvas</strong> 画布上并触发其所有子节点的绘制。</p>
<p>如果在节点<strong>正在测量</strong>时发出了<strong>重新测量</strong>节点的请求，则会被<strong>忽略</strong>。如果节点已经安排了重新测量，则同样会发生这种情况。</p>
<p>节点通常是先进行<strong>测量</strong>，然后是<strong>布局</strong>，最后是<strong>绘制</strong>。这是基本的顺序。</p>
<p>这就是插入&#x2F;实例化新节点以便用户可以在屏幕上体验的过程。</p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除一个或多个子节点看起来非常相似。<strong>UiApplier</strong> 调用 <strong><code>current.removeAt(index, count)</code></strong> 方法将删除任意数量的子项委托给当前节点本身。然后，当前节点（父节点）从最后一个开始迭代要删除的所有子项。对于每个子项，它从当前节点的子项列表中删除该子项，触发 <strong>Z</strong> 轴索引子项列表的重新排序，并将子项及其所有后代从树中分离。为此，它将它们的 <strong>owner</strong> 引用重置为 <strong>null</strong>，并请求对父项的重新测量，因为它将受到删除的影响。</p>
<p>与添加新节点时一样，如果由于移除节点而导致语义发生了更改，<strong>Owner</strong> 将被通知。</p>
<h3 id="移动节点"><a href="#移动节点" class="headerlink" title="移动节点"></a>移动节点</h3><p>换句话说，也就是重新排列子节点。当 <strong>UiApplier</strong> 调用 <strong><code>current.move(from, to, count)</code></strong> 来移动一个或多个子节点时，它也会遍历它们并对要移动的每个节点调用 <strong><code>removeAt</code></strong>（如上所述）。然后，它将节点再次添加到其新位置。最后，它请求对当前节点（父节点）进行重新测量。</p>
<h3 id="清除所有节点"><a href="#清除所有节点" class="headerlink" title="清除所有节点"></a>清除所有节点</h3><p>这与删除多个节点相同。它迭代所有子节点（从最后一个开始），并分别分离每个子节点，从而请求父节点重新测量。</p>
<h3 id="Compose-UI-中的测量"><a href="#Compose-UI-中的测量" class="headerlink" title="Compose UI 中的测量"></a>Compose UI 中的测量</h3><p>我们已经知道何时以及如何请求重新测量。现在是了解测量实际工作原理的时候了。</p>
<p>任何 <strong>LayoutNode</strong> 都可以通过 <strong>Owner</strong> 请求重新测量，例如当一个子节点被添加、删除或移动时。此时，视图（<strong>Owner</strong>）被标记为 “<strong>dirty</strong>”（无效，invalidate），节点会被添加到<strong>一个需要重新测量和重新布局的节点列表</strong>中。在下一次绘制过程中，<strong><code>AndroidComposeView#dispatchDraw</code></strong> 将被调用（就像对于任何无效的 <strong>ViewGroup</strong> 一样），<strong>AndroidComposeView</strong> 将遍历列表并使用代理执行这些操作。</p>
<p>对于每个被安排进行重新测量和重新布局的节点，会按照以下顺序执行3个步骤：</p>
<ol>
<li>检查节点是否需要重新测量，并在需要时进行测量。</li>
<li>在测量完成后，检查节点是否需要重新布局，并在需要时进行布局。</li>
<li>最后，检查是否有任何节点需要<strong>延迟</strong>测量请求，并在下一次绘制周期中安排重新测量。也就是将它们添加到下一次需要重新测量和重新布局的节点列表中，从而回到步骤1。当在进行测量时发生测量请求时，这些测量请求会被延迟。</li>
</ol>
<p>在对每个节点进行测量时（步骤1），它将委托给外部的 <strong>LayoutNodeWrapper</strong>。还记得吗？我们说过我们会详细介绍 <strong>LayoutNode</strong> 的内部和外部包装器，所以现在就来介绍一下。但在此之前，有一个小细节：如果测量导致节点的大小发生变化，并且该节点具有父级，则它将根据需要为父级请求重新测量或重新布局。</p>
<p>我们现在来了解一下包装器，以便了解测量的过程。</p>
<p>回到 <strong><code>LayoutNode＃insertAt</code></strong> 函数（由 <strong>UiApplier</strong> 调用以插入新节点），我们观察到与外部和内部 <strong>LayoutNodeWrappers</strong> 相关的赋值操作。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/f1650ef6baedcdc023ea7f1149e1679f.png" alt="在这里插入图片描述"><br>每个 <strong>LayoutNode</strong> 都有一个外部的和一个内部的 <strong>LayoutNodeWrapper</strong>。<strong>外部</strong>的负责<strong>测量</strong>和<strong>绘制</strong>当前节点，<strong>内部</strong>的负责对其<strong>子节点</strong>执行相同的操作。</p>
<p>这很棒，但是很遗憾也不完整。实际上，节点可以应用修饰符，而<strong>修饰符</strong>也可以<strong>影响测量</strong>，因此在测量节点时还需要考虑修饰符。例如：<code>Modifier.padding</code>直接影响节点子项的测量。除此之外，修饰符甚至可以影响链式连接在它们后面的其他修饰符的大小。例如：<code>Modifier.padding(8.dp).background(Color.Red)</code>，只有应用 padding 填充后的空间会被涂成红色。这意味着需要将修饰符的测量大小存储在某个地方。但是 <strong>Modifier</strong> 是一个<strong>无状态</strong>的东西，因此需要一个包装器来保存其状态。因此，<strong>LayoutNode</strong> 不仅具有外部和内部包装器，还具有每个应用于它的修饰符的包装器。所有包装器（外部的、修饰符的和内部的）都被链接在一起，以便按顺序解决和应用。</p>
<blockquote>
<p>一个修饰符的包装器包括其测量大小，还包括其他受测量影响的 hooks，例如执行绘制的 hooks（用于 <code>Modifier.drawBehind()</code> 等修饰符）或与触摸检测相关的 hooks。</p>
</blockquote>
<p>下面是所有包装器如何链接在一起的方式。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/73cf5cdd9438609327c8d6161d55336f.png" alt="在这里插入图片描述"></p>
<ol>
<li>父 LayoutNode 使用它的 measurePolicy（在 Layout composable 中定义，稍后会详细介绍）来测量它所有子节点的外部包装器（outer wrapper）。</li>
<li>每个子节点的外部包装器包装（wraps）链中的第一个修饰符（modifier）。</li>
<li>第一个修饰符包装第二个修饰符。</li>
<li>第二个修饰符包装第三个修饰符。</li>
<li>第三个修饰符包装内部包装器（inner wrapper）（假设该节点有 3 个修饰符）。</li>
<li>这将带我们回到第 1 步：内部包装器使用当前节点的 measurePolicy 来测量每个子节点的外部包装器。</li>
</ol>
<p>这确保了测量按顺序进行，并且还考虑了修饰符。请注意，这种包装仅适用于 Compose 1.2 开始的<strong>LayoutModifiers</strong>，因为其他类型的修饰符被包装为更简单的抽象。由于 Jetpack Compose 团队在不断更新迭代，所以你实际看到的源码可能与本文有所出入。本文所讨论的这种包装大概限定在Compose 1.3 之前的版本。 但是，无论最终使用的抽象是什么，方法都是相似的。</p>
<p>在绘制方面，它的工作方式也相同，但在最后一步中，内部包装器只是按 Z 轴索引的顺序迭代子项列表，并对它们的每一个调用绘制方法。</p>
<p>现在让我们回到 <code>insertAt</code> 函数中的 <code>LayoutNodeWrapper</code> 赋值部分。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/e74d601a19e877150ff0eaaebbe114e1.png" alt="在这里插入图片描述"><br>请看这个节点插入时的外部包装器被当前节点（它的新父节点）的内部包装器包装，这由我们上面的图表中的第一步和最后一步表示。</p>
<blockquote>
<p>当附加一个新节点时，所有的 <strong>LayoutNodeWrappers</strong> 都会收到通知。由于它们是有状态的，因此它们有一个生命周期，因此它们在任何附加和分离上都会被通知，以防它们需要初始化和处理任何东西。其中一个示例是 focus 修饰符，它们在附加时发送 focus 事件。</p>
</blockquote>
<p>每当需要重新测量一个节点时，此操作被委托给该节点的 <strong>外部 LayoutNodeWrapper</strong>，它<strong>使用父节点的测量策略进行测量</strong>。然后，它<strong>按照链条依次重新测量其每个修饰符</strong>，最后再<strong>使用当前节点的测量策略</strong>进入 <strong>内部 LayoutNodeWrapper</strong> 以<strong>重新测量其子节点</strong>。</p>
<p>在测量节点时，任何在测量 lambda（<code>measurePolicy</code>）内读取的可变状态都会被记录。这将使 lambda 在所涉及的状态变化时重新执行自己。毕竟，测量策略是从外部传递的，可以依赖于Compose 状态。（自动读取快照状态的内容部分我们将在以后展开探索）</p>
<p>测量完成后，会将上次测量的大小与当前大小进行比较，如果有变化，则会请求重新测量父节点。</p>
<h3 id="测量策略"><a href="#测量策略" class="headerlink" title="测量策略"></a>测量策略</h3><p>当需要测量节点时，相应的 <strong>LayoutNodeWrapper</strong> 依赖于发出节点时提供的测量策略。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/bc1b94a019be5665ac1479d340b67512.png" alt="在这里插入图片描述"></p>
<p>但是请注意 <code>measurePolicy</code> 实际上是如何从外部传递的。<strong>LayoutNode</strong> 始终不知道用于测量自身及其子节点的测量策略。Compose UI 期望 <strong>Layout</strong> 的任何实现都提供它们自己的测量策略，因为每个用例都不同。</p>
<p>每当 <strong>LayoutNode</strong> 的测量策略更改时，都会请求重新测量。</p>
<p>如果你以前在 Jetpack Compose 中创建过任何自定义布局，这可能听起来有点熟悉。测量策略是我们在创建自定义布局时传递给它的 lambda。</p>
<p>最简单的策略之一可能是由 <strong>Spacer</strong> Composable 设置的策略：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/80586c23479d75eac6a8439a2f6111a1.png" alt="在这里插入图片描述"></p>
<p>后面的 lambda 定义了策略。它实际是 <strong><code>MeasurePolicy#measure</code></strong> 函数的实现，该函数使用布局子元素的 <code>measurables</code> 列表(在本例中该参数被忽略了)，以及每个子元素应该遵守的约束 <code>constraints</code>。这些约束用于确定布局的宽度和高度。当它们被固定（被设置为精确的宽度或高度）时，<strong>Spacer</strong> 基本上会设置它们 （在本例中是<code>maxWidth == minWidth</code>和<code>maxHeight == minHeight</code>）。否则，它默认两个维度都为 <code>0</code>。这实际上意味着 <strong>Spacer</strong>总是需要通过父元素或修饰符获得一些施加的大小限制。这是有道理的，因为 <strong>Spacer</strong> 这个组件本身不包含任何子元素，它的唯一用途就是用作填充空白间隙，所以它不能适应其包装的内容。</p>
<p>另一个可能更完整的测量策略的例子可以在 <strong>Box</strong> Composable 中找到：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/36fcac63a6b900798c5d430e8f20f20b.png" alt="在这里插入图片描述"><br>此策略取决于 <strong>Box</strong> 的对齐设置(默认为<strong>TopStart</strong>，因此它将从上到下和从左到右对齐子元素)，以及是否需要对内容施加父元素最小约束。在 Compose 中有很多组件是在 <strong>Box</strong> 基础之上定义的，或者在布局中包含了它，如 <strong>Crossfade</strong>, <strong>Switch</strong>, <strong>Surface</strong>, <strong>FloatingActionButton</strong>, <strong>IconButton</strong>, <strong>AlertDialog</strong>等等。我们不能全部提到，但由于这个原因，传播最小约束的选项保持开放，以便让每个组件都可以自己决定。</p>
<p>请记住，这些都是实现细节，因此可能会随着时间而改变。尽管如此，它可以作为一个学习的例子。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a898c7d8f3aa65c6791e14ab86b1c8b3.png" alt="在这里插入图片描述"><br>这意味着，如果 <strong>Box</strong> 根本没有子元素，它将适应父元素(或修饰符)施加的最小宽度和高度。在此之后，如果将最小约束设置为要传播给子节点（即<code>propagateMinConstraints=true</code>），它将接受所施加的约束。否则，它会取消最小宽度和高度的限制，让子节点可以自己决定：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a77f5a20ee986bab9f9e9dd669400eee.png" alt="在这里插入图片描述"></p>
<p>在约束准备好之后，它会检查是否只有一个子元素，如果是这样，它会继续测量并放置它:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c301d826119b1546da6bec716846646a.png" alt="在这里插入图片描述"></p>
<p>我们在这里发现了一个有趣的区别。我们有两种场景：调整<strong>Box</strong>的大小以包装其内容，或者调整<strong>Box</strong>的大小以匹配其父元素。</p>
<p>当唯一的子元素没有被设置为匹配父元素的大小（例如<code>Modifier.fillMaxSize()</code>）时，<strong>Box</strong> 将根据其包装的内容调整其大小。要做到这一点，它首先使用施加的约束来测量子对象。这会返回施加这些限制后，子元素的大小。然后 <strong>Box</strong> 使用该大小来确定自己的大小。 <strong>Box</strong> 的宽度将是约束中的<code>minWidth</code>和子元素宽度二者的最大值。高度也是一样。这实际上意味着 <strong>Box</strong> 永远不会比它的单个子元素更小。</p>
<p>另一方面，当 <strong>Box</strong> 被设置为匹配父大小时，它将其宽度和高度设置为与父约束所施加的最小宽度和高度完全相同的值。</p>
<p>但这只适用于只有一个子元素的情况。如果有更多会发生什么？当然，该策略也对此作出了规定。它首先测量所有被设置为不匹配父节点大小的子节点，以获得 Box 的大小：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/50c221932a41095fcbb62c11cd40e18f.png" alt="在这里插入图片描述"></p>
<p>这个代码片段中的第一行初始化了一个 <code>placeables</code> 对象的数组，以跟踪所有测量的子对象，因为它最终需要摆放它们。</p>
<p>在此之后，它遍历所有子节点，以计算父节点施加的最小约束与每个子节点为这些约束所采取的宽度和高度之间可能存在的最大宽度和高度。这得使 <strong>Box</strong> 能够在它的子元素超过所施加的最小约束时，适应它的子元素，或者以其他方式将最小约束设置为它的大小。由于此过程需要测量每个子元素，因此它在这个过程中将每个子元素的测量结果 <code>placeable</code> 添加到 <code>placeables</code> 列表中。请注意，在此过程中，任何被设置为匹配父节点大小的子节点都将被忽略，因为它们将在下一步中用于测量Box。</p>
<p>当测量的子元素设置为匹配父元素大小时，有一些有趣的要点值得注意：如果到目前为止计算的<strong>Box</strong> 拥有无边界的约束（unbounded constraints），则会将测量子元素的最小约束设置为 <code>0</code>。这意味着每个子元素都可以决定自己想要多窄。只有前面计算的 <code>boxWidth</code> 或<code>boxHeight</code> 等于无穷大时才有可能出现此情况，这是由于当父组件（Box的父组件）约束中施加的最小维度约束是无界的时才会发生这种情况。如果不是这种情况，则将使用已经计算好的 <code>boxWidth</code> 和 <code>boxHeight</code> 作为测量子元素的最小约束：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/5ac49aa23de3e0522026cf0bc37a3993.png" alt="在这里插入图片描述"></p>
<p>在上面代码片段的最底部，我们可以看到所有与父节点大小匹配的子节点使用计算出的约束进行测量，并添加到 <code>placeables</code> 列表中。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7e443d5bef90c9f857cd52025f2482ed.png" alt="在这里插入图片描述"></p>
<p>有很多 Compose UI 中的测量策略示例。即使我们无法列出并描述所有这些示例，但学习这个示例应该有助于更详细地了解它们的工作原理。</p>
<p>MeasurePolicy 包括一些方法来计算布局的内在尺寸。也就是说，在没有约束条件的情况下，估计布局的大小。</p>
<h3 id="Intrinsic-固有特性测量"><a href="#Intrinsic-固有特性测量" class="headerlink" title="Intrinsic 固有特性测量"></a>Intrinsic 固有特性测量</h3><p><strong>Intrinsic</strong>测量在我们实际测量一个子元素之前提供估计尺寸时非常有用。一个例子是：如果我们想要将一个子元素的高度与它的最高兄弟节点的高度匹配，我们在测量阶段如何实现呢，如果兄弟节点还没有被测量过？</p>
<p>有一种方法是使用子组合（subcomposition），但有时我们并不需要那样。我们也可以考虑测量<strong>两次</strong>，但这是不可能的：Compose 强制对 Composables 进行<strong>一次测量</strong>（出于性能原因）。试图进行第二次测量会抛出异常。</p>
<p><strong>Intrinsic</strong>测量可以是一个很好的妥协解决方案。任何 <strong>LayoutNode</strong> 节点都有一个测量策略，正如我们已经了解到的那样，但它也有一个依赖于前者的<strong>Intrinsic</strong>测量策略。这种依赖关系使得任何依赖节点<strong>Intrinsic</strong>测量的祖先在节点的测量策略更改时重新计算它们的布局。</p>
<p><strong>LayoutNode</strong> 上分配的这个<strong>Intrinsic</strong>测量策略提供了计算以下内容的方法：</p>
<ul>
<li>给定<strong>高度</strong>的 <strong><code>minIntrinsicWidth</code></strong></li>
<li>给定<strong>宽度</strong>的 <strong><code>minIntrinsicHeight</code></strong></li>
<li>给定<strong>高度</strong>的 <strong><code>maxIntrinsicWidth</code></strong></li>
<li>给定<strong>宽度</strong>的 <strong><code>maxIntrinsicHeight</code></strong></li>
</ul>
<p>如你所见，我们总是需要提供<strong>相反的尺寸</strong>才能计算我们需要的尺寸。这是<strong>因为我们没有任何约束条件，所以我们可以向库提供的唯一线索是一个尺寸（这样它可以计算另一个尺寸）以正确地绘制布局内容的大小</strong>。</p>
<p>通过阅读每个函数的官方文档，我们可以更清楚地看到这一点：</p>
<ul>
<li><strong><code>minIntrinsicWidth</code></strong> 函数提供给定特定高度的情况下，布局可以占用的最小宽度，以使布局内容能够正确绘制。</li>
<li><strong><code>minIntrinsicHeight</code></strong> 函数提供给定特定宽度的情况下，布局可以占用的最小高度，以使布局内容能够正确绘制。</li>
<li><strong><code>maxIntrinsicWidth</code></strong> 函数提供最小宽度，以便将其进一步增加不会降低最小固有高度。</li>
<li><strong><code>maxIntrinsicHeight</code></strong> 函数提供最小高度，使得进一步增加高度不会降低最小固有宽度。</li>
</ul>
<p>我们可以使用 <strong><code>Modifier.width(intrinsicSize: IntrinsicSize)</code></strong>（或其高度对应项）作为了解 <strong>Intrinsics</strong> 的示例。请注意，这是与通常的 <strong><code>Modifier.width(width: Dp)</code></strong> 不同的变体。后者用于声明节点的精确首选宽度，而前者用于声明节点的首选宽度，以匹配其自身的最小或最大 <strong>Intrinsic</strong> 宽度。下面是它的实现方式。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6ddedce282ed816fc54af12dd039e42b.png" alt="在这里插入图片描述"></p>
<p>我们可以通过 <strong><code>Modifier.width(IntrinsicSize.Max)</code></strong> 这样的方式来使用。在这种情况下，它会选择 <strong>MaxIntrinsicWidthModifier</strong>，它会覆写最小固有宽度以匹配最大固有宽度，并且还会固定内容约束以匹配传入 <code>maxHeight</code> 约束的最大固有宽度。内容约束在使用 intrinsics modifier 进行测量时被使用。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/52ab89a1d8cdd97fa1fa7a543614280d.png" alt="在这里插入图片描述"></p>
<p>这很不错，但我们可能需要从最终用户的角度理解它的最终效果，以便更好地理解。当我们使用这个修饰符时，UI看起来是什么样子的，或者它的行为是什么样的？我们可以查看 <strong>DropdownMenu</strong> Composable 的实现方式，它依赖于 <strong>DropdownMenuContent</strong> 来在 <strong>Column</strong> 中显示菜单项。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7ca6e832de5af883abe592dcc560e746.png" alt="在这里插入图片描述"></p>
<p>这将设置 <strong>Column</strong> 的首选宽度以匹配所有子元素（菜单项）的最大固有宽度。这样做实际上强制下拉菜单与其最宽的子元素的宽度匹配。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0680c4eeed10f5eca609e1b5555f20b3.png" alt="在这里插入图片描述"></p>
<p>你可以阅读官方的 intrinsics measurement 文档了解更多实际用例的例子。</p>
<h3 id="布局约束"><a href="#布局约束" class="headerlink" title="布局约束"></a>布局约束</h3><p>布局约束可以来自父 <strong>LayoutNode</strong> 节点或者一个修饰符。<strong>Layout</strong> 或 <code>layout</code> 修饰符使用约束来测量其子布局。为了选择约束，约束提供了一个宽度和高度的最小和最大值的范围（<code>px</code>单位）。测量的布局（子项）必须适配这些约束。</p>
<ul>
<li><strong>minWidth &lt;&#x3D; chosenWidth &lt;&#x3D; maxWidth</strong></li>
<li><strong>minHeight &lt;&#x3D; chosenHeight &lt;&#x3D; maxHeight</strong></li>
</ul>
<p>大多数现有布局要么将未修改的约束条件向下传递给其子项，要么将<code>min</code>约束条件设置为 <code>0</code>。前面提到的 <strong>Box</strong> 就是后一种情况的例子。我们可以通过另一个场景展示这一点：</p>
<p>有时，父节点或修饰符希望要求其子项提供其首选大小。在这种情况下，它可以传递无限大的<code>maxWidth</code>或<code>maxHeight</code>约束条件（即 <code>Constraints.Infinity</code>）。当一个子节点被定义为填充所有可用空间时，为该维度传递一个无限约束就像是向子节点发出了一个信号，让它自己决定要占用多大的空间。假设我们有以下的 <strong>Box</strong>：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/5b731420c222866219cf2f3623da95d2.png" alt="在这里插入图片描述"></p>
<p>默认情况下，这个 <strong>Box</strong> 会填满所有可用的高度。但如果我们把它放在一个 <strong>LazyColumn</strong> 中（由于它是可滚动的，因此会使用无限高度约束来测量子节点），<strong>Box</strong> 将会根据 <strong>Text</strong> 的高度来包裹其内容。这是因为填充无限高度没有意义。在核心布局组件中，对于子节点在这些情况下自适应其内容大小非常普遍。然而，这最终取决于布局是如何定义的。</p>
<p><strong>LazyColumn</strong> 也可以作为学习如何使用不受限制的 <strong>Constraints</strong> 的一个好案例。它依赖于一个更通用的布局称为 <strong>LazyList</strong>，后者使用子组合（<strong>SubcomposeLayout</strong>）来测量子项。当我们需要基于可用大小延迟组合 items 时，子组合非常有用。在这种情况下，是屏幕大小，因为 <strong>LazyList</strong> 只组合屏幕上<strong>可见</strong>的项。以下是测量其大小时如何创建约束条件的：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1e13f7be51189293fc1c2bdf45f7e9d0.png" alt="在这里插入图片描述"><br>每次需要测量子项时，都会使用这些约束。首先，它将对项目的内容进行<strong>子组合</strong>。这是在 <strong>LazyList</strong> 测量传递期间完成的，这要归功于 <strong>SubcomposeLayout</strong>。子组合内容会生成一个<strong>可见子项</strong>的 <code>measurables</code> 列表，然后使用创建的 <code>childConstraints</code> 测量这些子项。此时，子项可以基本上自行选择其高度，因为高度约束是无限的。</p>
<p>另一方面，有时我们想要为所有子项设置确切的大小。当父元素或修饰符想要强制施加确切的大小时，它会强制执行 <code>minWidth == maxWidth</code>和<code>minHeight == maxHeight</code>。这基本上强制子元素适配该确切空间。</p>
<p><strong>LazyVerticalGrid</strong> 是一个例子，它可以高效地显示具有动态项目数的垂直网格。这个 Composable 非常类似于 <strong>LazyColumn</strong> 或 <strong>LazyRow</strong>，因为它也是<strong>延迟</strong>组合<strong>可见</strong>的子项。当网格中单元格的数量固定时，它实际上使用了 <strong>LazyColumn</strong>，对于每个列，它呈现一个 <strong>ItemRow</strong>，其中包含多个 <code>items</code>（与 <code>span</code> 数量相同）。<strong>ItemRow</strong> 布局使用固定宽度来测量其每个子项（列），该宽度由 <code>span count</code>（列数）、列大小和 <code>items</code> 之间的间距确定。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/177cdb34bb2331a3aa182d36ddcdf94f.png" alt="在这里插入图片描述"></p>
<p>这会创建如下的约束，其中宽度是固定的，而高度范围在0到无限大之间（即没有上限）</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/726445b530043beb7e35724497a4b5cf.png" alt="在这里插入图片描述"><br>如果你想探索更多关于 <strong>Constraints</strong> 的用法例子，我强烈建议你查看常见的用于控制大小的 <strong>layout modifiers</strong> 的内部实现，或者你熟悉的任何来自 Compose UI 源代码中的 <strong>Layout</strong> 组件。（我保证这是一个非常有意义的练习，可以帮助你理解测量的过程。）</p>
<p><strong>Constraints</strong> 被建模为 <strong>内联</strong> 类，用一个 <strong><code>Long</code></strong> 长整型数值以及几个位掩码来表示四个可用的约束（即 <code>minWidth</code>、<code>minHeight</code>、<code>maxWidth</code> 和 <code>maxHeight</code>）。通过从该值中读取不同的位掩码来解析不同的约束。</p>
<h3 id="LookaheadLayout"><a href="#LookaheadLayout" class="headerlink" title="LookaheadLayout"></a>LookaheadLayout</h3><p>关于 <strong>LookaheadLayout</strong> 我想先分享一个来自 Google Jetpack Compose 团队的 Doris Liu 在她的 Twitter 上分享的 <a target="_blank" rel="noopener" href="https://twitter.com/doris4lt/status/1531364543305175041">一个使用 LookaheadLayout 实现的非常 Cool 的动画示例</a> ：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/bdad5eb2a95740a16fe32657010d9dc6.gif" alt="在这里插入图片描述"></p>
<p>你可以在 <a target="_blank" rel="noopener" href="https://cs.android.com/">https://cs.android.com</a> 上面找到关于这个例子的全部源代码：<a target="_blank" rel="noopener" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation/integration-tests/animation-demos/src/main/java/androidx/compose/animation/demos/lookahead/SceneHostExperiment.kt">SceneHostExperiment.kt</a> 和 <a target="_blank" rel="noopener" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation/integration-tests/animation-demos/src/main/java/androidx/compose/animation/demos/lookahead/LookaheadWithMovableContentDemo.kt">LookaheadWithMovableContentDemo.kt</a></p>
<p>这个例子的效果虽然很酷，但是可能我们还不能够确切的知道它到底能用来干嘛，如果要考虑实际一点的场景的话，假设有如下代码，它在应用中的两个可组合屏幕之间导航。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/53e3ae9f432ce8e6abbbf2a41a7662e0.png" alt="在这里插入图片描述"></p>
<p>这两个屏幕当中可能包含一些共享元素，这也许是一个图片，一个文本或整个行。因此当我们在 <code>CharacterList</code> 中点击某个角色时，它们会发生动画。在这种情况下，如果我们想要动画过渡，我们可以选择设置一些魔法数字作为动画目标，因为我们恰好能够知道目标屏幕中所有共享元素的最终位置和大小。但这样做并不好。理想情况下，Compose UI 应该能够预先计算并提供这些信息，以便我们可以将其用于设置我们的动画目标。这就是 <strong>LookaheadLayout</strong> 发挥作用的地方。</p>
<p><strong>LookaheadLayout</strong> 可以<strong>在其直接或间接子项更改时预先计算它们的测量和摆放</strong>。这使每个子项能够观察其测量&#x2F;布局传递中预计算的值，并使用这些值随着时间逐渐改变其大小&#x2F;位置（从而创建动画效果）。在上面的共享元素转换示例中，每个共享元素将观察其在转换到的屏幕中的最终大小和位置，并使用这些值来将自己动画化。</p>
<h4 id="LookaheadLayout-是如何工作的"><a href="#LookaheadLayout-是如何工作的" class="headerlink" title="LookaheadLayout 是如何工作的"></a>LookaheadLayout 是如何工作的</h4><p>实际上，<strong>LookaheadLayout</strong> 在 “正常” 的测量&#x2F;布局之前执行测量和布局的<strong>预查看</strong>操作（<strong>lookahead</strong>），以便后者可以利用前者预先计算的值来在每一帧上更新节点。这个预查看操作仅在树结构改变或者由于状态改变导致布局改变时发生。</p>
<p>当进行 <strong>lookahead</strong> 的过程时，<strong>布局动画将被跳过</strong>，因此测量和布局的过程将被执行，就好像动画已经完成一样。未来，所有的布局动画 API 都将被设计为在 <strong>lookahead</strong> 过程中自动跳过。这将适用于 <strong>LookaheadLayout</strong> 的任何<strong>直接或间接子项</strong>。</p>
<p>为了暴露预计算的数据，<strong>LookaheadLayout</strong> 在 <strong>LookaheadLayoutScope</strong> 中执行其 <code>content</code> lambda，这使其子元素可以访问一些修饰符：</p>
<ul>
<li><p><strong><code>Modifier.intermediateLayout</code></strong>：每次测量带有该修饰符的布局时都会调用。允许访问布局<strong>lookahead</strong>（预计算）的尺寸大小，并将该尺寸作为目标尺寸，以产生中间布局（过渡动画）。</p>
</li>
<li><p><strong><code>Modifier.onPlaced</code></strong>: 当带有此修饰符的布局重新布局时调用。允许子元素根据其父元素调整自己的位置。它提供了对 <strong>LookaheadLayout</strong> 和修饰符本身（LookaheadLayout 的子元素）的<strong>lookahead</strong> 坐标的访问，这允许计算相对于父元素的 <strong>lookahead</strong> 位置和当前位置。在生成中间布局时，这些坐标可以保存并用于布局位置的动画。</p>
</li>
</ul>
<p>这两个修饰符在正常的测量&#x2F;布局过程中运行，因此它们可以使用在它们的lambda函数中提供的预先计算的信息来调整布局大小&#x2F;位置以达到目标值。期望用户在这两个修饰符的基础上构建自定义修饰符，以创建自定义动画。下面是官方文档的一个示例，用于根据预计算大小动画化用于测量其子元素的约束。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/700faaec768b455ae135cddeea54fbeb.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>创建了一个尺寸动画来动画化尺寸值（宽度&#x2F;高度）。每次布局更改时都会重新启动动画（借助<code>snapshotFlow</code>）。</p>
</li>
<li><p>这个动画是在 <code>LaunchedEffect</code> 中运行的，以避免在测量&#x2F;布局阶段（此修饰符运行时）运行不受控制的副作用。</p>
</li>
<li><p>在 <code>intermediateLayout</code> lambda 中，可以使用预计算的 <code>lookaheadSize</code> ，并被设置为 <code>targetSize</code>，以在其变化时触发动画。</p>
</li>
<li><p><code>lookaheadSize</code>被用于测量子节点的大小，从而使它们逐渐改变大小。这是通过在<strong>每一帧</strong>创建跟随<code>size</code>动画值的新的固定约束来实现的，从而在时间上产生了最终的动画效果。</p>
</li>
</ul>
<blockquote>
<p>在预计算阶段，中间布局（<code>intermediateLayout</code>）的lambda被跳过，因为这个修饰符是用于生成以lookahead 状态为目标状态的中间状态。</p>
</blockquote>
<p>我们有了用于动画约束的自定义修饰符之后，就可以在任何 <strong>LookaheadLayout</strong> 中使用它。以下是一个例子，也是从官方源代码中提取的：<br><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/612f8e0b01aecbd2cdc299e0befade2b.png" alt="在这里插入图片描述"><br>这里展示了如何使用之前创建的自定义modifier来实现一个可动画的Row布局。</p>
<ul>
<li>可变状态用于在“full width”和“short width”之间切换Row。</li>
<li>使用<code>animateConstraints</code>自定义modifier动画化Row布局更改。每次切换可变状态，Row宽度都会更改，这将触发新的 lookahead预计算（因此也会触发动画）。</li>
<li>所有子项中的最大宽度和最大高度用于测量 LookaheadLayout，以便所有子项都可以适合其中。</li>
<li>所有子项放置在 (0,0) 处。</li>
</ul>
<p>这样就可以在每次布局发生变化时产生一个不错的自动动画。这是一个基于预先计算的前瞻大小来调整目标大小动画示例。那么，如何实现根据预先计算的前瞻位置调整目标位置的动画呢？</p>
<p>前面提到了 <code>Modifier.onPlaced</code> 可以在 <code>LookaheadLayoutScope</code> 中使用，用于根据其父级调整子级的位置。它提供了足够的数据来计算布局相对于父级的当前位置和前瞻位置。我们可以将这些位置保存在变量中，并在后续对 <code>intermediateLayout</code> 的调用中使用它们，以便根据前瞻值相应地重新定位布局。</p>
<p>关于 <code>Modifier.onPlaced</code> 的使用示例，这里不再展开，其使用方式跟上面的例子实际上非常相似，如果你感兴趣的话可以在cs.android.com上面找到完整的示例代码：<a target="_blank" rel="noopener" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/LookaheadLayoutSample.kt">LookaheadLayoutSample.kt</a></p>
<h4 id="LookaheadLayout-的内部机制"><a href="#LookaheadLayout-的内部机制" class="headerlink" title="LookaheadLayout 的内部机制"></a>LookaheadLayout 的内部机制</h4><p>下图展示了 LookaheadLayout 的测量过程：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/528c31ef441ddc83fa8b5e0974cfd078.png" alt="在这里插入图片描述"><br>（上图中用橙色部分表示预先测量过程）</p>
<p>当一个 <strong>LayoutNode</strong> 需要第一次测量尺寸（例如：它刚刚被attach到父视图）时，它会检查它是否位于 <strong>LookaheadLayout</strong> 的根节点处，以便首先开始预测量过程（预测量过程仅运行于<strong>LookaheadLayout</strong>子树中）。</p>
<p><strong>LayoutNode</strong> 调用 <code>LookaheadPassDelegate#measure()</code> 以开始预测量阶段。该代理负责节点的所有预测量&#x2F;布局请求。此调用使用外部 <code>LayoutNodeWrapper</code>（通常用于测量节点）通过其 <code>LookaheadDelegate</code> 运行其 <code>lookahead</code> 测量。</p>
<p>预测量过程基本上遵循我们前文介绍过的测量步骤，唯一的区别是，使用的是 <strong>LookaheadDelegate</strong> 在所有步骤中执行。</p>
<p>一旦根节点及其所有直接或间接子节点的预先测量都完成，或者该节点不是 LookaheadLayout 的根节点，则“正常”的实际测量过程开始运行。</p>
<p>现在我们来看一下布局过程：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2e460dbaac2a0212b7927b3bcc0560bf.png" alt="在这里插入图片描述"></p>
<p>布局流程和测量流程没有什么区别。它们使用相同的委托。唯一的区别是，这里调用的是 <code>placeAt(...)</code> 函数，以便摆放节点及其子节点（用于普通布局流程），或者计算其预先位置（用于预先布局流程，用橙色表示）。</p>
<p>迄今为止，我们专注于第一次测量&#x2F;布局的节点。另一方面，当 <strong>LayoutNode</strong> 需要重新测量&#x2F;重新布局（例如其内容已更改）时，时间略有不同。为了尽可能减少无效范围，测量&#x2F;布局和前瞻性的无效化进行了优化。这样，不受树变化影响的 <strong>LayoutNodes</strong> 将不会无效化。这使得只有<strong>LookaheadLayout</strong> 子树的一小部分因为树的更改而无效化成为完全可能。</p>
<p>当一个新的 <strong>LayoutNode</strong> 被附加时，它会从树中继承最外层现有的 <strong>LookaheadScope</strong>，因此所有 <strong>LookaheadLayout</strong> 的直接或间接子项可以共享同一个作用域。这是因为支持嵌套的<strong>LookaheadLayout</strong>。Compose UI 也确保为它们执行单个的 lookahead 阶段。</p>
<p><strong>LookaheadLayout</strong> 可以与 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#movableContentOf%28kotlin.Function0%29"><strong>movableContentOf</strong></a> 和 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#movableContentWithReceiverOf%28kotlin.Function1%29"><strong>movableContentWithReceiverOf</strong></a> 结合使用， 以使 Composables 可以在动画期间&#x2F;之后被<strong>重用</strong>并保持它们的状态。</p>
<h4 id="预先计算布局的几种方式"><a href="#预先计算布局的几种方式" class="headerlink" title="预先计算布局的几种方式"></a>预先计算布局的几种方式</h4><p>我们可以将 <strong>LookaheadLayout</strong> 与 <strong>SubcomposeLayout</strong>（子组合）和 <strong>intrinsics</strong> 一起视为 Jetpack Compose 中预先计算布局的几种方式。尽管如此，三者之间存在重要的区别。</p>
<ul>
<li><p><strong>SubcomposeLayout</strong>: 将组合（composition）延迟到测量（measure）阶段执行，以便我们有足够的时间来确定要构建哪些节点&#x2F;子树。但它更多的是关注条件组合而不是预布局。它的成本也非常高，因此我不建议在任何其他情况下使用它进行布局预计算，因为它不仅仅是测量&#x2F;布局传递。</p>
</li>
<li><p><strong>Intrinsics</strong>：它是比子组合更有效率的方法，内部的工作方式与 <strong>LookaheadLayout</strong> 非常相似。这两种都是在同一帧中以不同的约束条件调用用户提供的 <code>LayoutModifiers</code> 或 <code>MeasurePolicys</code> 中的 <code>measure</code> 函数。 但是在 <strong>Intrinsics</strong> 的情况下，它们更像是试算，以便使用得到的值进行实际测量。想象一下一个具有3个子元素的行，为了使其高度与最高子元素的高度相匹配，它需要获取所有子元素的固有尺寸，最终使用其中最大的一个来进行自身的测量。</p>
</li>
<li><p><strong>LookaheadLayout</strong>：它用于精确预计算任何（直接或间接）子项的大小和位置，以便实现自动动画。除了测量之外，LookaheadLayout 还基于提前计算的尺寸大小进行摆放位置的预计算。 LookaheadDelegate 会将提前测量和摆放位置的结果缓存起来，以避免不必要的重复计算。除非树已更改（例如新的节点、修饰符更改等），否则不会提前计算。与<strong>Intrinsics</strong>的另一个区别是，LookaheadLayout 中有一个隐含的保证，即布局最终会到达提前计算的状态，因此它不允许用户操纵提前约束。</p>
</li>
</ul>
<h3 id="Modifier-链的建模"><a href="#Modifier-链的建模" class="headerlink" title="Modifier 链的建模"></a>Modifier 链的建模</h3><p>Modifier 接口模型化了一组不可变元素，用于装饰或为UI Composables添加行为。Modifier是一个抽象层，提供了以连接任何类型的修饰符（<code>then</code>）的组合能力、在遍历修饰符链时的累加值的折叠能力（<code>foldIn</code>和<code>foldOut</code>），以及一些操作来检查链中的任何或所有修饰符是否符合给定的断言。</p>
<p>每当我们在代码中找到如下所示的一串修饰符时，我们得到的是一个“链表”，由其头部引用：Modifier类型本身。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7d8a3a0fdb1ed5e2e06945bc0b2cf6bf.png" alt="在这里插入图片描述"></p>
<p>请注意，链接修饰符可以是显式的，也可以是隐式的，就像上面的代码片段中一样，我们有两者的组合。当没有指定 <code>then</code> 时，这是因为我们正在通过扩展函数链接那些修饰符，这些扩展函数实际上在内部为我们调用 <code>then</code>。这两种方法是等价的。在实际项目中，扩展函数的使用频率要高得多。下面是一个通过扩展函数声明修饰符的例子：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/9aa5ef1095f1df1bbe3d1738afa4a6fc.png" alt="在这里插入图片描述"></p>
<p>当调用 <code>then</code> 来链接两个修饰符时，它会生成一个 <code>CombinedModifier</code>，这就是链接建模的方式。<code>CombinedModifier</code> 有一个对当前修饰符的引用(<code>outer</code>)，还有一个指向链中下一个修饰符的指针(<code>inner</code>)，它也可以是一个<code>CombinedModifier</code>。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/fcb350fe9bfcd0a379ee0ed318570c66.png" alt="在这里插入图片描述"></p>
<p>节点被称为 <code>outer</code> 外部节点和 <code>inner</code> 内部节点，是因为当前节点会将下一个节点包裹在一个 <code>CombinedModifiers</code> 链当中：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a3e517ce523ff22413c5db7b18373549.png" alt="在这里插入图片描述"></p>
<p>这就是修饰符链的建模方法。</p>
<h3 id="将修饰符设置到-LayoutNode"><a href="#将修饰符设置到-LayoutNode" class="headerlink" title="将修饰符设置到 LayoutNode"></a>将修饰符设置到 LayoutNode</h3><p>任何 <strong>LayoutNode</strong> 都分配了一个 <strong>Modifier</strong> (或它们的一个链)。当我们声明一个 <strong><code>Layout</code></strong> 时，Compose UI 传递给它的一个参数是 <strong><code>update</code></strong> lambda:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/2751ba0beafce75fc5d151be40712e2d.png" alt="在这里插入图片描述"></p>
<p><code>update</code> lambda 在通过工厂创建节点时立即被调用，它初始化或更新 <strong>LayoutNode</strong> 的状态。这里设置了测量策略<code>measurePolicy</code>、<code>density</code>、布局方向或视图配置等内容。当然还有修饰符。在最后一行，我们看到一个 “<code>materialized</code>” 修饰符链被设置给 <strong>LayoutNode</strong>:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/8fff139e1d1b857f491d712be696f62e.png" alt="在这里插入图片描述"></p>
<p>那么现在的问题是：什么是“<code>materialized</code>”修饰符？在上面的几行中，我们可以找到修饰符 “<code>materialized</code>” 的地方(就在发出节点之前)：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3fff5b9da4e3a415e18aebaa625d87ed.png" alt="在这里插入图片描述"></p>
<p>这里的 <code>modifier</code> 参数可以是一个修饰符，也可以是一个修饰符链。如果传递给 <code>Layout</code> 的所有修饰符都是“标准的”，这个函数只返回未修改的修饰符，因此可以将它们设置给 <code>LayoutNode</code>，而不需要进行任何额外的处理。以上就是“标准”或“正常”修饰符的设置方法。但还存在另一种修饰符叫做 <code>Composed</code> Modifier 组合修饰符。</p>
<p>组合修饰符实际上是一种特殊类型的<strong>有状态</strong>修饰符。当需要一个 <code>Composition</code> 来实现它们时，这是有意义的。这方面的一个例子是，当我们需要从修饰语逻辑中记住一些东西时。或者当修饰符需要从<code>CompositionLocal</code> 中读取时。如果不在 <code>Composition</code> 的上下文中运行修饰符lambda，这些事情是永远不可能实现的。</p>
<p>组合修饰符是针对它们所修改的每个元素组合的。如果一个布局获得一个或多个组合修饰符作为修饰符链的一部分传递，它们将需要首先通过它们的可组合工厂函数进行组合，然后再分配给<code>LayoutNode</code>:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1ad003c638978120e7b0be1eddc8c693.png" alt="在这里插入图片描述"></p>
<p>首先需要运行 <code>factory</code> Composable lambda，因为 <code>LayoutNode</code> 不知道如何使用组合修饰符，因此需要在分配它们之前将它们转换为常规修饰符。 <code>factory</code> lambda 将在每次使用节点时在 Composition 的上下文中执行，这将解锁对块内任何 Composable 函数的访问。 <code>factory</code> lambda 就是我们用来编写 <code>composed</code> 修饰符的.</p>
<p>让我们用一个例子来学习：<code>clickable</code> 修饰符。请注意如何使用 <code>Modifier.composed()</code> 扩展函数来创建有状态(composed)修饰符:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/77c5510df1918b2b3a59e4713920f518.png" alt="在这里插入图片描述"></p>
<p>由于 <code>Composition</code> 被要求能够 <code>remember</code> 块内的状态，所以使用了一个 <code>composed</code> 修饰符。</p>
<p>除了<code>clickable</code>的修饰符，还有许多其他组合修饰符的例子。如 <code>focusable, scroll, swipeable, border, selectable, pointerInput, draggable, toggleable</code>以及更多。关于这方面的更多例子，我建议检查源代码并搜索 <code>Modifier.composed()</code> 扩展函数的用法。</p>
<p>有时候，Compose UI 需要为某些目的创建一个特别的 <strong>LayoutNode</strong>，它也会利用机会为其设置修饰符。这方面的一个例子是一个给定 <strong><code>Owner</code></strong> 的 <strong>根 LayoutNode</strong>，例如 <strong><code>AndroidComposeView</code></strong>:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0e7d88c10acdc8261d287d59a43964f3.png" alt="在这里插入图片描述"></p>
<p>当 <strong>AndroidComposeView</strong> hook 它的 <strong>root LayoutNode</strong> 时，它利用这个机会为它设置测量策略 <code>measurePolicy</code> ，<code>density</code>，以及通过 <strong>View</strong> 系统 hook accessibility 的一些修饰符。这些设置了语义树的默认配置，一个用于处理 accessibility 的焦点事件的管理器。</p>
<h3 id="LayoutNode-如何接受新的修饰符"><a href="#LayoutNode-如何接受新的修饰符" class="headerlink" title="LayoutNode 如何接受新的修饰符"></a>LayoutNode 如何接受新的修饰符</h3><p>每当将修饰符(或修饰符链)设置给 <strong>LayoutNode</strong> 时，已为当前节点设置的所有修饰符都会保存到缓存中。此缓存用于查找可复用的修饰符，用于正在设置的新修饰符链。</p>
<p>缓存中的所有修饰符都初始化为不可重用。然后，节点从其头部开始折叠到新的修饰符链上。这是通过<code>Modifier#foldIn</code>函数完成的，这是Modifier折叠功能之一。对于每个修饰符，它将检查缓存中是否包含等效的修饰符，如果是，则将其标记为可重用的。然后，如果缓存的修饰符有一个父修饰符，它将向上层访问，标记它和它的所有祖先也是可重用的。这将完成缓存修饰符的初始预处理，以便为下一步做好准备。</p>
<p>在此之后，<strong>LayoutNode</strong>继续重建其外层<strong>LayoutNodeWrapper</strong>。外部包装器包装链中的第一个修饰符，第一个修饰符包装第二个，依此类推。由于我们正在设置一个新的修饰符链，因此需要重新构建外部包装器。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/85f06d70a4ceb777f99ecaff08462d0f.png" alt="在这里插入图片描述"></p>
<p>为了重建外部包装，它再次折叠新的修饰符链，但方向相反:从尾部到头部。这是通过<code>Modifier#foldOut</code>函数完成的。现在的目标是为新的修饰符构建新的<code>LayoutNodeWrappers</code>链。</p>
<p>由于我们想从尾部开始，折叠的初始值将是<code>innerLayoutNodeWrapper</code>(图表底部的大部分)。然后我们可以爬上去遍历当前 <code>LayoutNode</code> 上设置的所有修饰符。</p>
<p>对于每个修饰符，它将首先通过检查缓存来检查是否可以重用它。如果能重用，则将其链接并从缓存中删除。如果不能重用，它将使用特定修饰符类型的适当 <code>LayoutNodeWrapper</code> 类型来包装修饰符，然后再将其链接。有多种包装器类型，每一种都有自己的功能，这取决于修饰符的性质。</p>
<p>当折叠到达头部(即<code>outerLayoutNodeWrapper</code>)时，外部包装器被分配给父节点的内部包装器，正如我们在上图的最顶部看到的那样。这就完成了构建新包装器链的过程。</p>
<p>下一步是从缓存中分离所有剩余的修饰符，因为它们不会被重用，然后在所有新的包装器上调用<code>attach()</code>。最后，可以清除缓存，并且可以重绘所有修饰符。为了这样做，他们会被设置失效。</p>
<p>最后一步是请求重新测量父节点(如果需要的话)。</p>
<h3 id="绘制节点树"><a href="#绘制节点树" class="headerlink" title="绘制节点树"></a>绘制节点树</h3><p>对于绘制，也会遵循 <strong>LayoutNodeWrapper</strong> 链，因此<strong>当前节点被首先绘制，然后是其修饰符（按顺序），最后是其子节点</strong>。这个过程对每个子节点重复，直到绘制出完整的节点层次结构。</p>
<p>在 <strong>Android</strong> 系统中，绘制过程发生在测量和布局之后。在每一个绘制周期中，系统调用我们的 <strong>View</strong> 或 <strong>ViewGroup</strong> 上的 <strong><code>draw()</code></strong> 方法，并执行绘图。在 <strong>Compose</strong> 中也是如此。当一个<strong>LayoutNode</strong> 请求重新测量时，它会被标记为 <strong><code>dirty</code></strong>（脏），在下一个绘制周期中，<strong>Owner</strong>（类似于 <strong>AndroidComposeView</strong> 的 <strong>ViewGroup</strong>）将重新测量并重新布局所有脏节点，然后开始绘制。绘制发生在 <strong><code>dispatchDraw()</code></strong> 函数中，这是 <strong>Android</strong> 系统中 <strong>ViewGroup</strong> 绘制其子元素的地方。</p>
<p>让我们继续以 <strong>AndroidComposeView</strong> 作为 <strong>Owner</strong> 的例子。在绘制之前，<strong>AndroidComposeView</strong> 会使层级中所有 <strong>LayoutNode</strong> 的绘制层<strong>失效</strong>，这意味着它们被标记为需要重新绘制。这也包括所有可用于绘制的修饰符包装器。每当需要使一个节点的绘制层失效时，它会首先检查它自己是否已经在绘制了。</p>
<p>绘制过程是从<strong>根 LayoutNode</strong> 开始启动的。这是通过 <strong><code>root.draw(canvas)</code></strong> 实现的，它将被委托给节点的 <strong>outerLayoutNodeWrapper</strong>。</p>
<blockquote>
<p><strong>Compose UI</strong> 中使用的 <strong>Canvas</strong> 是一个抽象，因为 <strong>Compose UI</strong> 是一个<strong>跨平台库</strong>。对于 <strong>Android</strong>，它将所有的绘制都委托给<strong>原生</strong>的 <strong>Canvas</strong>。除此之外，<strong>Compose Canvas</strong> 提供了比原生更人性化的API 接口。两者之间的一个关键区别是，<strong>Compose Canvas</strong> 函数不再接受 <strong>Paint</strong> 对象作为参数，因为在<strong>Android</strong> 中分配 <strong>Paint</strong> 实例是非常昂贵的，特别是不建议在绘制调用期间这样做。取而代之的是，团队决定重新设计 API 接口，使函数隐式地创建和重用相同的 <strong>Paint</strong> 对象。</p>
</blockquote>
<p>每个 <strong>LayoutNodeWrapper</strong> 都有自己的绘制层，外层包装器也不例外。当通过 <strong><code>root.draw(canvas)</code></strong> 将绘制分派给根节点时，外层包装器的绘制层会完成工作。这里有不同的情况需要考虑：</p>
<ol>
<li><p>如果存在与包装器相关联的绘制层，则会在其上调度绘制操作。这将有效地绘制节点，它可以是一个 <strong>LayoutNode</strong> 或一个修饰符。</p>
</li>
<li><p>如果该包装器没有与之关联的绘制层，则会检查是否有任何绘制修饰符与之相关联。如果有，则会绘制所有这些修饰符。（绘制修饰符作为链接列表附加到包装器上。它们不像其他修饰符那样被其自己的单独包装器包装）。</p>
</li>
<li><p>如果该包装器既没有与之关联的绘制层也没有任何绘制修饰符，则会继续调用链中的下一个包装器的 <code>draw</code> 函数，以继续绘制完整的 <code>LayoutNode</code> 层次结构。</p>
</li>
</ol>
<p>步骤1是绘制节点的地方。为此，Compose UI 为 <strong>LayoutNode</strong> 提供了两种类型的绘制层：</p>
<ul>
<li><strong>RenderNodeLayer</strong>：用于绘制 <strong>RenderNodes</strong>。这是呈现 Jetpack Compose UI 节点的默认方式。<strong>RenderNodes</strong> 是一种更高效的硬件驱动绘制工具。它们允许仅绘制一次，然后多次重新绘制非常高效。</li>
<li><strong>ViewLayer</strong>：这个是基于 <strong>View</strong> 的实现。只有在无法直接使用 <strong>RenderNodes</strong> 时才会使用。这种实现比 <strong>RenderNodeLayer</strong> 更 “<strong>笨拙</strong>”，因为它将 <strong>Views</strong> 视为 <strong>RenderNodes</strong>，并且为此需要一些管道。但是 <strong>Views</strong> 实际要比 <strong>RenderNodes</strong> 复杂的更多。</li>
</ul>
<p>两种实现都是硬件加速的，因为两种实现最终都直接或间接地依赖于 <strong>RenderNodes</strong>。例如，两种实现都可以作为 <strong><code>Modifier.graphicsLayer</code></strong> 的有效实现。</p>
<p>当一个新的节点被附加时，会创建绘图层。绘图层类型的决定取决于 <strong>Owner</strong>。在 <strong>AndroidComposeView</strong> 的情况下，如果平台版本支持，它将始终优先使用 <strong>RenderNodeLayer</strong>，否则将回退到 <strong>ViewLayer</strong>。</p>
<p>不同的 Android 版本为 <strong>RenderNodes</strong> 提供不同的 API，因此 <strong>RenderNodeLayer</strong> 依赖于 <strong>Compose UI</strong> 提供的一个抽象层，在执行时将绘图委托给相应的 <strong>RenderNode</strong> 系统实现。</p>
<p>另一方面，<strong>ViewLayer</strong> 依赖于 <strong>Views</strong> 来进行绘制。任何一个 <strong>ViewLayer</strong> 都有与之关联的容器 <strong>View</strong>，用于触发绘制。这个容器通常是 <strong>Owner</strong>，也就是一个 <strong>ViewGroup</strong>。当 <strong>ViewLayer</strong> 被创建时，它会将自己作为其容器的 <strong>child</strong>。这是因为 <strong>ViewLayer</strong> 实际上是作为一个 <strong>View</strong> 实现的，这是其中的关键技巧。当 <strong>layer</strong> 需要进行绘制时，它会调用其所属容器的 <strong><code>ViewGroup#drawChild</code></strong> 函数，从而重用 <strong>View</strong> 的绘制机制。正如我们之前所述，这比直接使用 <strong>RenderNodes</strong> 更加笨拙，因为它涉及到使用 <strong>Views</strong> 来使其工作。</p>
<p>在绘制之前，如果一个 <strong>ViewLayer</strong> 有一些高度（<strong>elevation</strong>）的属性，那么它就有机会启用 “<strong>高度模式</strong>”。 “<strong>高度模式</strong>” 由 Android <strong><code>Canvas</code></strong> 支持，它允许渲染阴影，并根据不同高度重新排列层级。一旦“高度模式”被启用，该层就可以继续绘制，完成后它将被禁用。</p>
<p>一旦链中的所有包装器都被绘制完成，<strong><code>AndroidComposeView#dispatchDraw</code></strong> 会通知所有标记为 <strong><code>dirty</code></strong> 的层更新其显示列表，从而更新当前画布上的绘制。</p>
<p>当图层被无效化时，它们会被标记为 <strong><code>dirty</code></strong> 。由于我们在 <strong><code>dispatchDraw</code></strong> 函数的开始时将所有图层都无效化了，这将强制让层级中所有节点的所有图层都更新。</p>
<p>在更新显示列表的前面几个步骤中可能会导致相同的图层失效。在这种情况下，这些图层将被标记为脏，以便在下一轮中更新它们。</p>
<p>有时候，我们在将 <strong>LayoutNode</strong> 绘制到图层中时会读取快照状态。每当此状态更改时，我们可能需要重新绘制节点以保持一致性。根节点有一个图层修饰符，用于观察所有子节点中的状态更改，以相应地使其绘制层无效。这是为根节点设置的测量策略的一部分：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b643fba022a117d86a3c828e0ac99bb9.png" alt="在这里插入图片描述"></p>
<p>这个 <strong>RootMeasurePolicy</strong> 测量和摆放附加到根节点的子节点。为此，它调用 <strong><code>placeable.placeRelativeWithLayer(0, 0)</code></strong>，将测量的子节点放置在坐标<code>(0,0)</code>处，并引入一个 <strong>图形层</strong>（<strong>graphic layer</strong>）。该图形层被配置为自动观察和响应任何快照状态的更改。</p>
<h3 id="Jetpack-Compose-中的语义"><a href="#Jetpack-Compose-中的语义" class="headerlink" title="Jetpack Compose 中的语义"></a>Jetpack Compose 中的语义</h3><p>在 Jetpack Compose 中，<strong>Composition</strong> 是一棵描述 UI 的树。同时，还有另一棵树，它以一种 <strong>accessibility</strong> 服务和测试框架能够理解的方式进行描述UI。该树上的节点提供有关其语义含义的相关元数据。</p>
<p>在前面，我们了解到 <strong>LayoutNode</strong> 层次结构的 <strong>Owner</strong> 有一个 <strong>accessibility</strong> 委托，可以通过 Android SDK 来传输语义。然后，每当节点被附加、分离或其语义更新时，语义树都会通过 <strong>Owner</strong> 得到通知。</p>
<p>当 <strong>Owner</strong> 被创建时（对于<strong>AndroidComposeView</strong>来说，就是当 <strong><code>setContent</code></strong> 被调用时），它会创建一个带有一些默认修饰符的临时 <strong>root LayoutNode</strong>：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/0fdc5a0f4ba6a73365636e147d31a5a1.png" alt="在这里插入图片描述"></p>
<p>这些修饰符与 <strong>accessibility</strong> 和语义相关。语义修饰符 <code>semanticsModifier</code> 将具有默认配置的核心语义添加到根节点，以便开始构建语义树。在它之上，焦点管理器<code>_focusManager</code> 修饰符设置根修饰符，用于跨 Composable 层次结构处理焦点。这个管理器负责根据需要在我们的组合中设置和移动焦点。最后，键输入修饰符<code>keyInputModifier</code>处理键盘输入，并将任何 <code>KeyDown</code> 事件传递给焦点管理器<code>_focusManager</code>，因此焦点也可以使用键盘处理。后两个修饰符对于 <strong>accessibility</strong> 也非常重要。</p>
<p>为了向不同于根节点的其他节点添加语义，我们通过 <strong><code>Modifier.semantics</code></strong> 来实现。 我们设置给 <strong>Layout</strong> 的每个语义修饰符都包含一个 <code>id</code> 和一些语义配置:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/bebfb85e7325e4ce142e412d16e8deb4.png" alt="在这里插入图片描述"></p>
<p>在这里，我们可以看到如何隐式地创建一些调试检查器信息，以便向 Compose tools 提供关于该节点的一些详细信息，以便它们在检查 Composable 树时显示它。</p>
<p>一个 <code>id</code> 是自动生成并被 <code>remembered</code> 的。这些 <code>ids</code> 在 <code>LayoutNode</code> 层次结构中是唯一的（静态共享），并按顺序生成。每个新生成的 <code>id</code> 都比前一个 <code>id</code> 大。这意味着一个新的 <strong>Composition</strong> 可能从最开始就开始生成 <code>id</code> ，或者在之前创建的任何其他 <strong>Composition</strong> 生成的最新<code>id</code> 之后依次生成<code>id</code> 。</p>
<p>最后，使用这些元素和提供的配置参数创建修饰符。</p>
<p>现在，<code>semantics</code> 修饰符是作为 <code>composed</code> 修饰符实现的，因为它需要访问 <strong>Composition</strong> 上下文，以便在块中使用生成的 <code>id</code>。也就是说，这个实现很快就会改变，因为有一个正在进行的重构，它将在创建相应的 <code>LayoutNode</code> 时移动生成的 <code>id</code>，因此将不再需要 <code>remember</code>，因此对 <strong>Composition</strong> 上下文的需求将被移除。</p>
<p>这个语义修饰符的实现目前正在进行重构（也就是说，你看到的最新版本源码和本文描述的可能略有不同）。</p>
<p>当<strong>AndroidComposeView</strong>将默认的语义修饰符分配给根节点时，它以同样的方式创建它：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/72b7b2723c6a9fa273e9ae7675a5a67f.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>当我们使用 <code>material</code> 或 <code>foundation</code> 库提供的 Composables 时，它们很可能已经隐式地 hook 了它们的语义。这很好，但当我们在自己的自定义布局中工作时，它不会起作用。因此，每当我们在 Jetpack Compose 中编写一个新的 <code>Layout</code> 时，我们需要自己提供它的语义。Accessibility和测试必须优先考虑。</p>
</blockquote>
<h4 id="通知语义更改"><a href="#通知语义更改" class="headerlink" title="通知语义更改"></a>通知语义更改</h4><p><strong>AndroidX</strong> 核心库添加了一个 <strong><code>AccessibilityDelegateCompat</code></strong>，用于规范跨系统版本的 <code>accessibility</code> 服务。<strong>LayoutNode</strong> 层次结构的 <strong>Owner</strong> 使用此委托的实现来处理<code>accessibility</code> 更改。这个实现利用了系统<code>accessibility</code>服务，因此它可以通过从 <strong>Owner</strong> 获得的 Android <strong><code>Context</code></strong> 来查询这些服务。</p>
<p>当通过 <strong>Owner</strong> 通知语义变化时，检查语义树上的语义变化的操作将通过本地 <strong>Handler</strong> 发送到 <strong>Main Looper</strong>。这个操作按顺序做以下事情：</p>
<ol>
<li>比较新旧语义树寻找结构变化。即:添加或删除子元素。当检测到结构更改时，委托使用合并通道通知这些更改。这是因为通知系统 accessibility 服务的代码是在<strong>协程</strong>中运行的挂起函数。对象的整个生命周期内循环此任务合成实例，使用最近的布局更改并分批(每100ms)向accessibility框架发送事件。<code>Channel</code>是为这个任务生成要事件的一个合适的选择。</li>
<li>比较新旧语义树寻找语义属性的变化。当语义属性发生变化时，它将使用本地机制通知accessibility 服务 (<code>ViewParent#requestSendAccessibilityEvent</code>)。</li>
<li>用所有当前语义节点更新以前的语义节点列表。</li>
</ol>
<h4 id="合并和未合并的语义树"><a href="#合并和未合并的语义树" class="headerlink" title="合并和未合并的语义树"></a>合并和未合并的语义树</h4><p>Jetpack Compose 提供了两个语义树：<strong>Merged</strong> 和 <strong>unMerged</strong>.。有时我们需要从语义上合并一组 Composables，因为对于最终用户来说，将它们作为一个组来体验比单独体验具有更好的语义意义。想象一下，像 <strong>TalkBack</strong> 这样的辅助工具在一个非常大的项目列表的每一行中读取每个次要的Composable。它将产生一种非常让人疲惫且无用的用户体验。我们可能更喜欢把每一行都读一遍。</p>
<p>合并是通过<code>mergeDescendants</code>属性完成的，我们可以从上面的代码片段中找到。这个属性允许我们决定一个语义节点（例如一个Composable或一个modifier）什么时候需要将它的后代合并到它。这实际上在 <code>foundation</code> 和 <code>material</code> 库提供的许多 Composable 组件和 Modifier 中都是开箱即用的。合并的树将基于我们可以设置节点的<code>mergeDescendants</code>执行合并。未合并的，不会这样做。它将使这些节点保持分离。工具决定它们想要使用什么树。</p>
<p>以下是内部合并的过程：</p>
<p>语义属性分配了一个合并策略。让我们以<code>contentDescription</code>为例:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4c18ddffac6687e2010483a8cf45e70a.png" alt="在这里插入图片描述"></p>
<p>语义属性是通过<code>SemanticsPropertyReceiver</code>上的扩展属性定义的，它是用于语义块的作用域，允许我们在块内设置任何属性。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/463887d2dd81f0a010165638d17f4083.png" alt="在这里插入图片描述"></p>
<p>要设置语义属性，需要两个东西:一个语义<code>key</code>和一个<code>vallue</code>值。语义<code>key</code>是以类型安全的方式定义的，并且需要一个属性名和一个合并策略来创建:</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/4d04c9a819585f48f5d6b173d80e9f07.png" alt="在这里插入图片描述"><br>在合并策略 lambda 中，属性决定如何合并其后代。在这种情况下，<code>ContentDescription</code>将所有后代 <code>ContentDescription</code> 值添加到列表中，但可以做任何它想做的事情。Compose 中语义属性的默认合并策略实际上就是根本不合并。如果节点可用，则保留父值，并丢弃子值。</p>
<blockquote>
<p>注意，这里我们只是讨论一些语义内部细节，而不是为了罗列所有的语义API或配置。所以如果你想了解关于Jetpack Compose语义的API 接口使用和最终用户角度的更多细节，建议阅读<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/semantics">官方文档</a>。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>从 Compose UI 的角度来看组合：</strong></p>
<ul>
<li><p><strong>Android中，Compose runtime 集成 UI 的入口点是在我们调用 <code>Activity/Fragment</code> 的 <code>setContent</code> 方法时。还可以通过单独调用 <code>ComposeView</code> 的 <code>setContent</code> 方法来设置。</strong></p>
</li>
<li><p><strong><code>setContent</code>函数创建了一个新的 <code>root Composition</code>，每个组合都有一个独立的 Composable 树。这些组合之间相互独立。</strong></p>
</li>
<li><p><strong>相应 <code>setContent</code> 调用的所有 Composable 函数都将执行并发出它们的更改。对于 Compose UI ，这些更改就是插入、移动或替换 UI 节点，而这些操作通常是由构建 UI 的 <code>block</code> 代码块发出的，即：Box，Column，LazyColumn 等。这些组件最终都被定义为 <code>Layout</code>。并发出相同的节点类型：<code>LayoutNode</code>。</strong></p>
</li>
<li><p><strong>任何 <code>Layout</code> Composable 函数都会将 <code>LayoutNode</code> 节点发射到 <code>Composition</code> 中，这是通过 <code>ReusableComposeNode</code> 发射的。</strong></p>
</li>
<li><p><strong><code>ReusableComposeNode</code> 通过 <code>factory</code> 工厂函数创建节点，通过 <code>update</code> lambda 初始化它（节点第一次被创建时或节点值更改时才会执行这些 lambda）。</strong></p>
</li>
<li><p><strong><code>LayoutNode</code> 并不是 Compose UI 中唯一的节点类型，还有其他的节点类型，比如 <code>VNode</code>、<code>ModifierNode</code> 等等。它们都是由 Composable 函数发出的。</strong></p>
</li>
</ul>
</li>
<li><p><strong>从 Compose UI 的角度来看子组合（Subcomposition）：</strong></p>
<ul>
<li><strong><code>Composition</code> 不仅仅存在于 <code>root</code> 级别，还可以存在树的更深层次，并连接到父组合，即<code>Subcomposition</code>。</strong></li>
<li><strong>每个<code>Composition</code> 都有一个指向其父 <code>CompositionContext</code> 的引用，该引用代表其父 <code>Composition</code></strong></li>
</ul>
</li>
<li><p><strong>在 Compose UI 中，创建 Subcomposition 主要有两个原因：</strong></p>
<ul>
<li><strong>推迟初始组合过程</strong>，直到某些信息已知。如 <strong>SubcomposeLayout</strong> 和 <strong>BoxWithConstraints</strong> 组件就是如此。</li>
<li><strong>修改子树生成的节点类型</strong>。例如<strong>矢量图形</strong>，即 <strong><code>rememberVectorPainter</code></strong> 函数。它创建了自己的 <strong><code>Subcomposition</code></strong> 来将矢量图形建模为一棵树。Vector Composable 会发出不同于LayoutNode的 <strong><code>VNode</code></strong> 节点类型。Vector 的 Subcomposition 会连接到包含它的 <strong><code>Layout</code></strong> Composable 对应的 Composition 中。</li>
</ul>
</li>
<li><p><strong>不同类型的 <code>Applier</code>：</strong></p>
<ul>
<li><strong><code>Applier</code> 是一个抽象层，runtime 依赖于它而不是具体使用库的平台，最终实现树中的任何更改。即反转依赖。平台客户端库可以有自己不同的 <code>Applier</code> 实现。</strong></li>
<li><strong><code>AbstractApplier</code>：Compose runtime提供的共享逻辑。它将已访问的节点存储在一个栈中，每当在节点树上访问节点上下游走时，都通过<code>applier#down()</code> 或 <code>applier#up()</code>方法来执行入栈出栈操作。</strong></li>
<li><strong><code>UiApplier</code>：用于呈现大多数 Android UI 。它将节点类型固定为 <code>LayoutNode</code>，因此它将实现我们树中的所有 <code>Layouts</code> 布局。<code>UiApplier</code> 采用自下而上的方式插入节点。这是为了避免新节点进入树时出现重复通知。</strong></li>
<li><strong><code>VectorApplier</code>：用于呈现矢量图形。它将节点类型固定为 <code>VNode</code>，以表示和实现矢量图形。<code>VectorApplier</code> 采用自上而下的方式构建树。</strong></li>
<li><strong><code>UiApplier</code> 和 <code>VectorApplier</code>是到目前为止 Android 提供的<code>Applier</code>唯一的两个实现类，但不排除未来会添加更多实现类。</strong></li>
</ul>
</li>
<li><p><strong>实体化&#x2F;插入一个新的 <code>LayoutNode</code>：</strong></p>
<ul>
<li><strong><code>UiApplier</code>将节点类型固定为 <code>LayoutNode</code>，所有插入、删除或移动节点的操作都委托给当前访问的节点。 <code>LayoutNode</code> 知道如何实现自身，runtime 可以对此保持无感知。</strong></li>
<li><strong>每个 <code>LayoutNode</code> 都有一个指向其父节点的引用，并且它们全部连接到同一个 <code>Owner</code>。每个新加入的节点也是如此。这里的 <code>Owner</code> 是一个抽象层，每个平台可以有不同的实现，在 <code>Android</code> 中，它是<code>AndroidComposeView</code>(一个 View)，因此 <code>Owner</code> 是我们的 <code>LayoutNodes</code> 树 和 <code>Android View</code> 系统之间的底层连接。</strong></li>
<li><strong>无论任何节点操作，都可以通过 Android <code>View</code> API 的 <code>Owner</code> 触发失效，进而在下一个绘制阶段显示在屏幕上。</strong></li>
</ul>
</li>
<li><p><strong><code>LayoutNode#insertAt</code>：</strong></p>
<ul>
<li><strong>首先将当前节点设置为插入的新节点的父节点，</strong></li>
<li><strong>然后，新节点被添加到它的新父节点维护的子节点列表中。在此之上，按照 <code>Z</code> 轴索引中排序的子元素列表将会被失效。</strong></li>
<li><strong>经过某种 “outer” 和 “inner” 的 LayoutNodeWrappers 的赋值后，最后通过 <code>instance.attach(owner)</code> 将节点附加到与其新的父节点相同的 <code>Owner</code> 上。</strong></li>
<li><strong><code>attach</code> 函数会在子节点上递归调用，因此挂在该节点上的完整子树最终将附加到同一个 <code>Owner</code>。也就是说，来自同一个 Composable 树的任何节点所需的所有失效强制通过同一个 <code>View</code> 进行传递。<code>owner</code>对象被保存到了当前节点中。</strong></li>
</ul>
</li>
<li><p><strong>通过 <code>Owner</code> 请求测量和绘制：</strong></p>
<ul>
<li><strong>当在 <code>Activity、Fragment</code> 或 <code>ComposeView</code> 中调用 <code>setContent</code> 函数时，<code>Owner</code> 将被附加到视图层次结构中。会创建一个 <code>AndroidComposeView</code> （Owner）并将其附加到视图层次结构中。</strong></li>
<li><strong>此时<code>Applier</code> 调用 <code>current.insertAt(index, instance)</code> 来插入一个新节点LayoutNode时，将连接新节点到父节点，并通过 <code>Owner</code> 请求自己和新父节点的重新测量。会调用 <code>AndroidComposeView#invalidate</code>。</strong></li>
<li><strong><code>View</code> 将在下一个绘制阶段调用 <code>AndroidComposeView#dispatchDraw</code> 触发 Compose UI 执行所有请求节点的实际重新测量和布局。如果在这个重新测量过程中，根节点的大小发生了变化，则会调用 <code>AndroidComposeView#requestLayout()</code> ，以便重新触发 <code>onMeasure</code> 并能够影响所有 <code>View</code> 兄弟节点的大小。</strong></li>
<li><strong>测量和布局完成后，<code>dispatchDraw</code> 调用将最终调用根 <code>LayoutNode</code> 的 <code>draw</code> 函数，它知道如何将自己绘制到 <code>Canvas</code> 画布上并触发其所有子节点的绘制。节点通常是先进行测量，然后是布局，最后是绘制。</strong></li>
</ul>
</li>
<li><p><strong>删除节点：</strong></p>
<ul>
<li><strong><code>UiApplier</code> 调用 <code>current.removeAt(index, count)</code> 方法，对于每个子项，它从当前节点的子项列表中删除该子项，触发 <code>Z</code> 轴索引子项列表的重新排序，将它们的 <code>owner</code> 引用重置为 <code>null</code>，以从树中分离，并请求对父项的重新测量，因为它将受到删除的影响。</strong></li>
<li><strong>移动节点和清除所有节点都是利用了<code>removeAt</code>方法。</strong></li>
</ul>
</li>
<li><p><strong><code>LayoutNode</code> 的测量：</strong></p>
<ul>
<li><strong>任何 <code>LayoutNode</code> 都可以通过 <code>Owner</code> 请求重新测量，例如当一个子节点被添加、删除或移动时。此时，视图（<code>Owner</code>）被标记为 “<code>dirty</code>”（无效），节点会被添加到一个需要重新测量和重新布局的节点列表中。在下一次绘制过程中，<code>AndroidComposeView#dispatchDraw</code> 将被调用，<code>AndroidComposeView</code> 将遍历列表并使用代理执行这些操作。</strong></li>
<li><strong>每个 <code>LayoutNode</code> 都有一个外部的和一个内部的 <code>LayoutNodeWrapper</code>。外部的负责测量和绘制当前节点，内部的负责对其子节点执行相同的操作。</strong></li>
<li><strong>在测量时需要考虑 <code>Modifier</code> 对测量的影响，但是 <code>Modifier</code> 是一个无状态的东西，因此需要一个包装器来保存其状态。所有包装器（外部的、修饰符的和内部的）都被链接在一起，以便按顺序解决和应用。</strong></li>
<li><strong>每当需要重新测量一个节点时，此操作被委托给该节点的外部 <code>LayoutNodeWrapper</code>，它使用父节点的测量策略进行测量。然后，它按照链条依次重新测量其每个修饰符，最后再使用当前节点的测量策略进入内部 <code>LayoutNodeWrapper</code> 以重新测量其子节点。</strong></li>
</ul>
</li>
<li><p><strong>测量策略：</strong></p>
<ul>
<li><strong>对于一个节点来说，它的 <code>measurePolicy</code> 实际上是如何从外部传递的。<code>LayoutNode</code> 始终不知道用于测量自身及其子节点的测量策略。</strong></li>
<li><strong>Compose UI 中的 <code>Layout</code> 的任何实现都提供它们自己的测量策略。例如 <code>Box</code> 根据对齐设置、子元素是一个还是多个、是否匹配父元素大小等，提供不同的测量策略。</strong></li>
</ul>
</li>
<li><p><strong>Compose 中除了 UI 树，还有一棵专门为 <code>Accessibility</code> 服务和测试框架 提供的语义树。</strong></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20UI/">https://bravestsnail.github.io/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20UI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Composable%E5%87%BD%E6%95%B0/" title="Composable函数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Composable函数</div></div><div class="info-2"><div class="info-item-1">Composable 函数的含义如果我们只专注于简单的语法，任何标准的Kotlin函数都可以成为一个可组合函数，只需将其注解为@Composable:  通过这样做，我们实际上是在告诉编译器，该函数打算将一些数据转换为一个Node节点，以便注册到可组合树中。也就是说，如果我们将可组合函数看成是 @Composable (Input) -&gt; Unit，输入是数据，但输出却不是大多数人认为的函数返回的值，而是一个将元素插入树中的注册动作。我们可以认为这是一种函数执行带来的副作用。 这里所谓的 “注册动作” 在 Compose 中通常称为 “emitting”（发射）。emit 动作是在可组合函数被执行时进行的，这发生在组合过程中。 执行Composable函数的唯一目的是构建或更新树的内存表示状态。这将使它始终与其所代表的树结构保持同步更新状态，因为可组合函数会在其读取的数据每次发生变化时重新执行。为了保持和树的同步更新状态，它们可以发出插入新节点的操作(如上所述)，但同样也可以删除、替换或移动节点。可组合函数还可以从树中读取或向树中写入状态。 Composable...</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/compose/Compose%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2/Compose%20runtime/" title="Compose runtime"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Compose runtime</div></div><div class="info-2"><div class="info-item-1">到目前为止，我们将 Compose runtime 在内存中维护的状态称为“Composition”，这是一个较为肤浅的概念。让我们从了解用于存储和更新Composition状态的数据结构开始探索。 slot table 和 change list我发现这两种数据结构之间存在一些混淆，可能是由于目前缺乏关于Compose内部结构的文档。现在，我认为有必要首先澄清这一点。 slot table（插槽表）是一个优化的内存结构，runtime 使用它来存储组合的当前状态。它在初始组合时填充数据，并在每次重新组合时更新。我们可以把它看作是所有Composable函数调用的跟踪，包括它们在源码中的位置、参数、记住的值、CompositionLocals等等。它包含了在合成过程中发生的一切内容。所有这些信息将被 Composer 稍后用于生成下一个更改列表，因为对树的任何更改总是依赖于当前状态。 slot table 记录Composable的状态，而 change list 则是对节点树进行实际更改的内容。每次 Composable...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Compose-runtime-%E9%9B%86%E6%88%90-UI"><span class="toc-number">1.</span> <span class="toc-text">通过 Compose runtime 集成 UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-Compose-UI-%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E7%BB%84%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">从 Compose UI 的角度来看组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-Compose-UI-%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E5%AD%90%E7%BB%84%E5%90%88%EF%BC%88Subcomposition%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">从 Compose UI 的角度来看子组合（Subcomposition）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E7%BB%84%E5%90%88%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">延迟初始组合过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%AD%90%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">更改子树中的节点类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E6%98%A0-UI-%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">反映 UI 中的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-Appliers"><span class="toc-number">5.</span> <span class="toc-text">不同类型的 Appliers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%8C%96-%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-LayoutNode"><span class="toc-number">6.</span> <span class="toc-text">实体化&#x2F;插入一个新的 LayoutNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E9%97%AD%E7%8E%AF"><span class="toc-number">7.</span> <span class="toc-text">完成闭环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%8A%82%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">移动节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">清除所有节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose-UI-%E4%B8%AD%E7%9A%84%E6%B5%8B%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">Compose UI 中的测量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E7%AD%96%E7%95%A5"><span class="toc-number">12.</span> <span class="toc-text">测量策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intrinsic-%E5%9B%BA%E6%9C%89%E7%89%B9%E6%80%A7%E6%B5%8B%E9%87%8F"><span class="toc-number">13.</span> <span class="toc-text">Intrinsic 固有特性测量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E7%BA%A6%E6%9D%9F"><span class="toc-number">14.</span> <span class="toc-text">布局约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LookaheadLayout"><span class="toc-number">15.</span> <span class="toc-text">LookaheadLayout</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LookaheadLayout-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">15.1.</span> <span class="toc-text">LookaheadLayout 是如何工作的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LookaheadLayout-%E7%9A%84%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">15.2.</span> <span class="toc-text">LookaheadLayout 的内部机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%85%88%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B1%80%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">15.3.</span> <span class="toc-text">预先计算布局的几种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier-%E9%93%BE%E7%9A%84%E5%BB%BA%E6%A8%A1"><span class="toc-number">16.</span> <span class="toc-text">Modifier 链的建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%AE%BE%E7%BD%AE%E5%88%B0-LayoutNode"><span class="toc-number">17.</span> <span class="toc-text">将修饰符设置到 LayoutNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LayoutNode-%E5%A6%82%E4%BD%95%E6%8E%A5%E5%8F%97%E6%96%B0%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">18.</span> <span class="toc-text">LayoutNode 如何接受新的修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%8A%82%E7%82%B9%E6%A0%91"><span class="toc-number">19.</span> <span class="toc-text">绘制节点树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jetpack-Compose-%E4%B8%AD%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">20.</span> <span class="toc-text">Jetpack Compose 中的语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E8%AF%AD%E4%B9%89%E6%9B%B4%E6%94%B9"><span class="toc-number">20.1.</span> <span class="toc-text">通知语义更改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%92%8C%E6%9C%AA%E5%90%88%E5%B9%B6%E7%9A%84%E8%AF%AD%E4%B9%89%E6%A0%91"><span class="toc-number">20.2.</span> <span class="toc-text">合并和未合并的语义树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">21.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>