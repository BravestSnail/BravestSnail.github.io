<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android BLE | BravestSnail's Blog</title><meta name="author" content="BravestSnail"><meta name="copyright" content="BravestSnail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android BLE 杂谈 主要解决方案领域 音频传输  Bluetooth®技术摒弃了耳机、耳麦、扬声器等设备上繁琐的接线，彻底改变了音频设备，永远改变了我们消费媒体和体验世界的方式。  数据传输  从家用电器和健身追踪器到健康传感器和医疗创新产品，Bluetooth®技术连接着数十亿台日常设备，并促成了无数新设备的发明。  设备网络  Bluetooth® Mesh 是创建控制、监控和自动化">
<meta property="og:type" content="article">
<meta property="og:title" content="Android BLE">
<meta property="og:url" content="https://bravestsnail.github.io/2025/06/04/note/Android/BLE/Android%20BLE/index.html">
<meta property="og:site_name" content="BravestSnail&#39;s Blog">
<meta property="og:description" content="Android BLE 杂谈 主要解决方案领域 音频传输  Bluetooth®技术摒弃了耳机、耳麦、扬声器等设备上繁琐的接线，彻底改变了音频设备，永远改变了我们消费媒体和体验世界的方式。  数据传输  从家用电器和健身追踪器到健康传感器和医疗创新产品，Bluetooth®技术连接着数十亿台日常设备，并促成了无数新设备的发明。  设备网络  Bluetooth® Mesh 是创建控制、监控和自动化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bravestsnail.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-06-04T12:46:35.119Z">
<meta property="article:modified_time" content="2025-06-04T12:46:35.119Z">
<meta property="article:author" content="BravestSnail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bravestsnail.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Android BLE",
  "url": "https://bravestsnail.github.io/2025/06/04/note/Android/BLE/Android%20BLE/",
  "image": "https://bravestsnail.github.io/images/avatar.png",
  "datePublished": "2025-06-04T12:46:35.119Z",
  "dateModified": "2025-06-04T12:46:35.119Z",
  "author": [
    {
      "@type": "Person",
      "name": "BravestSnail",
      "url": "https://bravestsnail.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://bravestsnail.github.io/2025/06/04/note/Android/BLE/Android%20BLE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android BLE',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>if(window.mermaid){mermaid.initialize({startOnLoad:true});}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/favicon.ico" alt="Logo"><span class="site-name">BravestSnail's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Android BLE</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Android BLE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T12:46:35.119Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-04T12:46:35.119Z" title="更新于 2025-06-04 20:46:35">2025-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Android-BLE-杂谈"><a href="#Android-BLE-杂谈" class="headerlink" title="Android BLE 杂谈"></a>Android BLE 杂谈</h1><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ba44a6b99d2aabf826cde95de01159ea.awebp%23" alt="image.png"></p>
<h2 id="主要解决方案领域"><a href="#主要解决方案领域" class="headerlink" title="主要解决方案领域"></a><a href="https://link.juejin.cn/?target=https://www.bluetooth.com/zh-cn/bluetooth-resources/?types=case-study" title="https:&#x2F;&#x2F;www.bluetooth.com&#x2F;zh-cn&#x2F;bluetooth-resources&#x2F;?types&#x3D;case-study">主要解决方案领域</a></h2><ul>
<li><p><strong>音频传输</strong><br>  Bluetooth®技术摒弃了耳机、耳麦、扬声器等设备上繁琐的接线，彻底改变了音频设备，永远改变了我们消费媒体和体验世界的方式。</p>
</li>
<li><p><strong>数据传输</strong><br>  从家用电器和健身追踪器到健康传感器和医疗创新产品，Bluetooth®技术连接着数十亿台日常设备，并促成了无数新设备的发明。</p>
</li>
<li><p><strong>设备网络</strong><br>  Bluetooth® Mesh 是创建控制、监控和自动化系统的理想选择，在这些系统中，数十、数百或数千台设备需要可靠、安全地相互通信。</p>
</li>
<li><p><strong>位置服务</strong><br>  Bluetooth®技术是开发人员的首选工具，可用于创建用于兴趣点信息和物品查找的近距离解决方案以及定位系统，如用于资产跟踪的实时定位系统和用于寻路的室内定位系统。</p>
</li>
</ul>
<h2 id="零、基本概念-官方文档"><a href="#零、基本概念-官方文档" class="headerlink" title="零、基本概念 - 官方文档"></a>零、基本概念 - <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/develop/connectivity/bluetooth?hl=zh-cn" title="https:&#x2F;&#x2F;developer.android.google.cn&#x2F;develop&#x2F;connectivity&#x2F;bluetooth?hl&#x3D;zh-cn">官方文档</a></h2><ul>
<li><p><strong>GATT（Generic Attribute Profile 通用属性配置文件）</strong><br>  它定义了两个BLE设备互相传输数据进行通信的方法，该方法用了两个概念，Service和Characteristic。</p>
</li>
<li><p><strong>Profile</strong><br>  profile 可以理解为一种规范，标准的通信协议，它存在与蓝牙从机中（服务端）。每个profile中会包含多个service，每个service代表从机的一种能力。</p>
</li>
<li><p><strong>Service</strong><br>  在BLE从机中有多个服务，例如：电量信息服务、系统信息服务等； 每个service中又包含多个characteristic特征值； 每个具体的characteristic特征值才是BLE通信的主题，比如当前的电量，电量的characteristic特征值存在从机的profile里，这样主机就可以通过这个characteristic来读取电量数据。</p>
</li>
<li><p><strong>Characteristic</strong><br>  characteristic特征值，BLE主、从机的通信都是通过characteristic来实现，可以理解为一个通道，通过这个通道可以获取或者写入内容。</p>
</li>
<li><p><strong>UUID</strong><br>  UUID,统一识别码，每个Service，Characteristic，Descriptor，都是由一个UUID定义。</p>
</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d252fbe548bcd1ee565f3dd8b5fca5bb.awebp%23" alt="image.png"></p>
<h2 id="一、BLE设备连接通信"><a href="#一、BLE设备连接通信" class="headerlink" title="一、BLE设备连接通信"></a>一、BLE设备连接通信</h2><h3 id="设备角色"><a href="#设备角色" class="headerlink" title="设备角色"></a>设备角色</h3><p>BLE设备角色主要分为两种角色，_<strong>主机（Master或Central）_<strong>和</strong>_从机（Peripheral）</strong>_，当主机和从机建立连接之后才能相互收发数据。</p>
<p>● <strong>主机</strong><br>主机可以发起对从机的扫描、连接。例如手机，通常作为BLE的主机设备</p>
<p>● <strong>从机</strong><br>从机只能广播并等待主机的连接。例如智能手环，蓝牙耳机，是作为BLE的从机设备</p>
<p>蓝牙协议栈没有限制设备的角色范围，同一个BLE设备，可以作为主机，也可以作为从机，我们称之为主从一体，主从一体的好处是，每个BLE设备都是对等的，可以发起连接，也可以被别人连接，更加实用。</p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><blockquote>
<p>站在APP作为中心设备的角度，常用于数据交互的通信方式主要有3种：接收通知、写、读，此外还有设置最大传输单元，获取实时信号强度等通信操作。</p>
</blockquote>
<ul>
<li><p><strong>读、写操作</strong><br>  读写是作为主机主动向从机传输和获取数据的主要通信方式</p>
</li>
<li><p><strong>通知</strong><br>  有两种方式可以接收通知，indicate和notify。indicate和notify的区别就在于，indicate是一定会收到数据，notify有可能会丢失数据。indicate底层封装了应答机制，如果没有收到中央设备的回应，会再次发送直至成功；而notify不会有central收到数据的回应，可能无法保证数据到达的准确性，优势是速度快。通常情况下，当外围设备需要不断地发送数据给APP的时候，比如血压计在测量过程中的压力变化，胎心仪在监护过程中的实时数据传输，这种频繁的情况下，优先考虑notify形式。当只需要发送很少且很重要的一条数据给APP的时候，优先考虑indicate形式。</p>
</li>
<li><p><strong>设置最大传输单元</strong><br>  进行BLE数据相互发送的时候，一次最多能发送20个字节。如果需要发送的数据超过20个字节，有两种方法，一种是主动尝试拓宽MTU，另一种是采用分包传输的方式。</p>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>1、 连接设备前，请先关闭扫描蓝牙，否则连接成功后，再次扫描会发生阻塞，扫描不到设备</p>
<p>2、Android ble最大属性值的长度为600个字节 <img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/36018d5acb7d4fa4b2ce8f6f74910671.awebp%23" alt="image.png"></p>
<p>3、IOS 最大MTU<br>iOS 在连接时自动启动 MTU 交换。 运行 iOS &lt; 10 的设备将请求 MTU 大小为 158。iOS 10以上的较新设备将请求 MTU 大小为 185。</p>
<p>源码路径：<a href="https://link.juejin.cn/?target=http://www.aospxref.com/android-10.0.0_r47/xref/system/bt/stack/include/gatt_api.h%23141" title="http:&#x2F;&#x2F;www.aospxref.com&#x2F;android-10.0.0_r47&#x2F;xref&#x2F;system&#x2F;bt&#x2F;stack&#x2F;include&#x2F;gatt_api.h#141">www.aospxref.com/android-10.…</a></p>
<p>stackoverflow：<a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/48741196/android-ble-client-only-returns-600-byte-of-data-in-oncharacteristicread" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;48741196&#x2F;android-ble-client-only-returns-600-byte-of-data-in-oncharacteristicread">stackoverflow.com&#x2F;questions&#x2F;4…</a></p>
<p>github issue: <a href="https://link.juejin.cn/?target=https://github.com/don/cordova-plugin-ble-central/issues/861" title="https:&#x2F;&#x2F;github.com&#x2F;don&#x2F;cordova-plugin-ble-central&#x2F;issues&#x2F;861">github.com&#x2F;don&#x2F;cordova…</a></p>
</blockquote>
<h3 id="BLE设备连接交互流程"><a href="#BLE设备连接交互流程" class="headerlink" title="BLE设备连接交互流程"></a>BLE设备连接交互流程</h3><p>下面有两个BLE设备，一个是主机，名称为：BleCentral，另一个是从机，名称为：BlePeripheral。</p>
<p><strong>步骤1：启动初始化</strong></p>
<p>主机、从机上电后（不分先后顺序），首先进行协议栈初始化和相关功能调用。</p>
<p>● 主机设备初始化时，需要设置设备类型，设置用于扫描的相关参数，初始化GATT等协议相关的参数。</p>
<p>● 从机设备初始化时，需要设置设备名称，广播相关参数，从机Profile等。从机一般会立即开启广播，也可以等待一个事件来触发广播。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d6639f45a2d3ff9f23894027a946a805.awebp%23"></p>
<p><strong>步骤2：主机扫描从机</strong></p>
<p>此时，主机正在扫描，从机仍然处于广播状态。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/15a04e981fefe1fa67d5f7e4c67061d3.awebp%23"></p>
<p><strong>步骤3：发现从机设备</strong></p>
<p>当主机扫描到从机时，可以返回已扫描到的从机相关信息，例如可以提取到下图中的从机设备名称，从机MAC地址，从机的RSSI信号值等数据。</p>
<p>因此，有些应用在从机的广播包或者扫描回应包中添加自定义字段，这样就可以被主机通过扫描的方式拿到数据。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d0b55fbe253e8d7d9b6e33263a553a3a.awebp%23"></p>
<p><strong>步骤4：发送连接请求</strong></p>
<p>当主机扫描到从机后，通过MAC地址向从机发送连接请求。低功耗蓝牙的连接速度非常快，100ms左右即可成功连接上。</p>
<p>从机在未收到连接请求之前仍然处于自由的广播状态。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ea06df1a95ed5081cddbe5e90678a634.awebp%23"></p>
<p><strong>步骤5：成功连接从机</strong></p>
<p>当从机收到连接请求后，双方成功建立连接，此时双方的状态均变为已连接状态。</p>
<p>然后主机可以调用协议栈提供的接口函数来获取从机的服务。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1747ac8dfbf5621f89e04863076ceecb.awebp%23"></p>
<p><strong>步骤6：获取从机服务</strong></p>
<p>获取从机服务通常是在连接成功后就立即执行的，因为只有获取从机的服务后，才能与其通信。</p>
<p>此刻，从机处于已连接状态。响应服务获取请求是在底层自动完成，上层无需理会。</p>
<p><img src="http://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/914e6cc7fd5b1633085aa9d774f3c317.awebp%23',"></p>
<p><strong>步骤7：成功获取服务</strong></p>
<p>主机成功获取到从机的服务，例如获取到UUID为0xFFF0的Services，该Service有两个特征值，分别是具有读写属性的0xFFF1，以及具有通知属性的0xFFF2。</p>
<p>读写属性是指主机可以读写该特征值的内容。而通知属性是指从机可以通过该特征值向主机发送数据。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/1d3f2d0bcb77609362493880b011b994.awebp%23"></p>
<p><strong>步骤8：主机向从机发送数据</strong></p>
<p>主机通过特征值0xFFF1，主动向从机发送自定义数据，当数据成功发送后，主机状态变为：数据已发送。从机将收到主机发来的数据，从机状态变为收到数据。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ddf930df4da41f08522112ad82bb327c.awebp%23"></p>
<p><strong>步骤9：从机向主机发送数据</strong></p>
<p>从机可以通过Norify的方式主动向主机发送数据，例如下图，从机通过特征值0xFFF2发送了一条Notify通知。</p>
<p><img src="http://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/eb1d312f9b889c230ce5b032b02eaf14.awebp%23',"></p>
<p><strong>步骤10：发送断开请求</strong></p>
<p>主机和从机任何一方均可以发起断开连接的请求，对方收到后，状态将 变为已断开。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/ad1f55fa6cdd467a629251eecb38cb46.awebp%23"></p>
<p><strong>步骤11：成功断开连接</strong></p>
<p>从机收到主机发来的断开请求，此刻状态变为已断开。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/a04774bec333e2bf15357730fdf66fd8.awebp%23"></p>
<h3 id="扫描的工作流程"><a href="#扫描的工作流程" class="headerlink" title="扫描的工作流程"></a>扫描的工作流程</h3><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/47efcdb264e77429709d4ef05aa93795.awebp%23" alt="image.png"></p>
<blockquote>
<p>建议：尽可能少地扫描，因为毕竟扫描是一个比较重的操作，耗电，也会减慢 BLE 连接速度</p>
</blockquote>
<p>目前移动设备上适用的蓝牙大多是V4.0以上。</p>
<p><strong>BLE协议栈</strong>：由控制器（Controller）、主机控制接口（HCI）和主机（Host）组成。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/c2b95d6f7c12947e7949901f07e15e91.awebp%23" alt="image.png"></p>
<ul>
<li><p>GATT<br>  GATT 连接需要特别注意的是：GATT 连接是独占的。也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。</p>
<p>  GATT 通信的双方是 C&#x2F;S 关系。外设作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义。中心设备是 GATT 客户端（Client），它向 Server 发起请求。</p>
</li>
<li><p>GAP（Generic Access Profile），它用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与设备进行交互。包括设备发现，建立连接，终止连接，初始化安全特性，设备配置。</p>
<p>  GAP层总是作为下面四种角色之一：（1）广播者：不可连接的广播设备。(2）观察者：扫描设备，但不发起建立连接。（3）外部设备：可连接的广播设备，可以在单个链路层连接中作为<strong>从机</strong>。（4）集中器：扫描广播设备并发起连接，可以在单个链路层连接中作为<strong>主机</strong>。</p>
</li>
</ul>
<h2 id="二、BLE应用"><a href="#二、BLE应用" class="headerlink" title="二、BLE应用"></a>二、BLE应用</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>BLE应用目前可以分为两大类。</p>
<ul>
<li><p><strong>基于非连接的：</strong><br>  意思就是外设和周边设备不发生连接，外设主要依赖周边设备发出的BLE广播,也叫做Beacon。这里有两个角色，发送广播的一方叫做Broadcaster。监听广播的一方叫做Observer。这个在蓝牙协议栈的<strong>GAP</strong>层都有相应的角色定义。</p>
</li>
<li><p><strong>基于连接的：</strong><br>  就是外设和周边设备要建议显式的<strong>GATT</strong>连接，需要双方有通信。这个也有两个角色，外设设备(周边)叫做Peripheral。中心设备(一般是手机)叫做Centeral。</p>
</li>
</ul>
<p>（1）基于非连接的BLE应用，下面是它的网络拓扑结构：</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/15edeba080a8a5446b859ac5a0c298b9.awebp%23" alt="image.png"> 由于广播是单向的，<strong>Broadcaster向外发送广播</strong>，<strong>Observer接受广播</strong>。总体来说是多对多的关系。BLE广播中也能够带上数据，包括某些私有协议等。所以基于这种协议也是能够开发出独特的应用。完全基于广播的应用，有大名鼎鼎的iBeacon,这是苹果公司基于BLE广播实现的功能，可以实现广告推送以及室内定位。包括某些商场内部柜台寻找的功能，也是基于这种协议开发出来的。</p>
<p>在上图的设备都是单一的角色，而实际上有些设备是可以同时实现两种角色的，它即可以发送广播，也可以接受广播。在现在比较火的智能家居系统中，有很多的传感器，如果一个设备接受到广播，做了处理以后在发送出去，就形成了一个双向的网格，是不是就有点像因特网了，这也就是有名的<strong>蓝牙Mesh</strong>。</p>
<ul>
<li>iBeacon是苹果推出的一种蓝牙定位广播协议</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/d078f9bc1379cbacb9eacfc739d72113.awebp%23" alt="image.png"></p>
<ul>
<li><strong>iBeacon室内定位原理：</strong><br>  ibeacon设备会主动发射蓝牙信号，当手机打开蓝牙靠近ibeacon设备时，就会收到设备发送的蓝牙信号，这时只需要根据ibeacon设备的uuid、major、minor、mac这四个值，就可以确认是哪一台ibeacon设备，然后调用服务端考勤接口(ibeacon设备只为了确认手机在考勤机边上，不需要发送考勤数据到ibeacon设备上)，即可实现蓝牙考勤。（参考钉钉蓝牙打卡机）</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/02fb8550c5e03d5731222f3b85e841a2.awebp%23" alt="image.png"></p>
<p>（2）基于连接的蓝牙应用(Connection App)</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/b9aa8d2932a9e1606724a74bd7084df3.awebp%23" alt="image.png"></p>
<blockquote>
<p>一个中心设备可以连接多个外设，但是一个外设只能连接一个中心(主要是因为连接成功以后，外设就会停止对外广播，别人则发现不了它了)。其实一个中心连接的外设设备数量也是有限的，具体看底层芯片的限制</p>
</blockquote>
<h2 id="三、BLE中GATT的服务和特征发现机制"><a href="#三、BLE中GATT的服务和特征发现机制" class="headerlink" title="三、BLE中GATT的服务和特征发现机制"></a>三、BLE中GATT的服务和特征发现机制</h2><ul>
<li>BLE开发过程中协助调试的app（<strong>nRF Connect</strong>、<strong>BLE调试助手…</strong>）</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/6cd2638fb023a067c8233a1a99dd7203.awebp%23" alt="image.png"></p>
<ul>
<li>在BLE中，GATT客户端发现服务端服务的过程与经典蓝牙不同，经典蓝牙会有专门的SDP协议来完成。<strong>而BLE中，这个过程会直接在GATT层完成服务和特征的发现</strong></li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/7624517f48031e78dc1839d117edb3f7.awebp%23" alt="image.png"></p>
<ul>
<li>respond 应答数据</li>
</ul>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/50bbc9c2abc1925afc6027fd53c2cbf3.awebp%23" alt="image.png"></p>
<h2 id="四、蓝牙连接数据包"><a href="#四、蓝牙连接数据包" class="headerlink" title="四、蓝牙连接数据包"></a>四、蓝牙连接数据包</h2><h5 id="1、BLE-连接过程中有三个重要的数据包：SCAN-REQ-SCAN-RSP-和-CONNECT-REQ"><a href="#1、BLE-连接过程中有三个重要的数据包：SCAN-REQ-SCAN-RSP-和-CONNECT-REQ" class="headerlink" title="1、BLE 连接过程中有三个重要的数据包：SCAN_REQ, SCAN_RSP 和 CONNECT_REQ"></a>1、BLE 连接过程中有三个重要的数据包：SCAN_REQ, SCAN_RSP 和 CONNECT_REQ</h5><ul>
<li><strong>SCAN_REQ：</strong><br>  扫描请求，由主设备（<code>MASTER DEVICE</code>）向从设备（<code>SLAVE DEVICE</code>）发出，目的是为了获得从设备的响应以得到更多的从设备广播数据信息（包括设备名字，或者服务<code>UUID</code>，及其它如厂家特定格式的信息（如硬件版本，软件版本号，设备系列号等等）。</li>
<li><strong>SCAN_RSP:</strong><br>  从设备对就主设备发起的SCAN_REQ的响应，作为广播包的补充，从设备可以给主设备更多的广播数据，比如说，有些设备在广播包里面没有设备名字，这个时候就可以把设备名字放在这个包里面发给主设备。</li>
<li><strong>CONNECT_REQ：</strong><br>  主设备向从设备发出连接请求。至此连接建立完成（从设备不会响应这个请求），如果从设备没有连接上面的问题的话，以后主从双方会开始相互交换有效数据（基于<code>GAP,GATT</code>及<code>SMP</code>协议）或者交换空包。</li>
</ul>
<h5 id="2、什么是MTU"><a href="#2、什么是MTU" class="headerlink" title="2、什么是MTU"></a>2、什么是MTU</h5><p><strong>MTU</strong>（<code>MAXIMUM TRANSMISSION UNIT</code>）最大传输单元，指在一个<strong>PDU</strong>（<code>Protocol Data Unit</code>：协议数据单元，在一个单元中的有效传输数据）<strong>能够传输的最大数据量</strong>（多少字节可以一次传输给对方）。</p>
<h5 id="3、设置reqeustMtu"><a href="#3、设置reqeustMtu" class="headerlink" title="3、设置reqeustMtu"></a>3、设置reqeustMtu</h5><p><code>MTU</code>交换是<strong>为了在主从双方设置一个PDU中最大能够交换的数据量</strong>，通过<code>MTU</code>的交换和双方确认（注意这个<code>MTU</code>是不可以协商的，只是通知对方，<strong>双方在知道对方的极限后会选择一个较小的值作为以后的MTU</strong>。</p>
<p>比如说，主设备发出一个<code>150个字节</code>的<code>MTU</code>请求，但是从设备回应<code>MTU</code>是<code>23字节</code>，那么今后双方要以较小的值<code>23字节</code>作为以后的<code>MTU</code>），主从双方约定每次在做数据传输时不超过这个最大数据单元，<code>MTU</code>交换通常发生在主从双方建立连接关系后。</p>
<h5 id="4、数据包大小（MTU）的限制"><a href="#4、数据包大小（MTU）的限制" class="headerlink" title="4、数据包大小（MTU）的限制"></a>4、数据包大小（MTU）的限制</h5><p><code>Android</code>系统从<code>4.3(API 18)</code>开始支持<code>BLE</code>，且从<code>5.1(API 21)</code>才开始支持<code>MTU</code>修改(<strong>默认<code>MTU</code>仅为<code>23字节</code>，而且传输本身用掉<code>3字节</code></strong>)。</p>
<h5 id="问题一、为什么BLE默认限制数据传输长度为20个字节？"><a href="#问题一、为什么BLE默认限制数据传输长度为20个字节？" class="headerlink" title="问题一、为什么BLE默认限制数据传输长度为20个字节？"></a>问题一、为什么BLE默认限制数据传输长度为20个字节？</h5><p><code>core spec</code>（核心规范）里面定义了ATT的<strong>默认<code>MTU</code>为<code>23个bytes</code></strong>，除去<code>ATT</code>的<code>opcode</code>一个字节以及<code>ATT</code>的<code>handle 2个字节</code>之后，<strong>剩下的<code>20个字节</code>便是留给<code>GATT</code>的了</strong>。</p>
<p>考虑到有些<code>Bluetooth smart</code>设备功能弱小，不敢太奢侈的使用内存空间，因此<code>core spec</code>规定每一个设备都必须支持<code>MTU</code>为<code>23</code>。</p>
<p>在两个设备连接初期，大家都像新交的朋友一样，不知对方底细，因此严格的按照套路来走，即最多一次发<code>20个字节</code>，是最保险的。</p>
<p>由于<code>ATT</code>的最大长度为<code>512byte</code>，因此一般认为<code>MTU</code>的最大长度为<code>512个byte</code>就够了，再大也没什么意义，你不可能发一个超过<code>512</code>的<code>ATT</code>的数据。</p>
<p>所以<code>ATT</code>的<code>MTU</code>的最大长度可视为<code>512个bytes</code>。</p>
<h5 id="问题二、为什么需要记录MTU"><a href="#问题二、为什么需要记录MTU" class="headerlink" title="问题二、为什么需要记录MTU"></a>问题二、为什么需要记录MTU</h5><p>记录<code>MTU</code>主要是用于传输过程中判断数据是否需要分包发送。按照<code>MTU</code>的大小严格约束每次发送的数据包大小，如果不这么做，很可能远端接收就会出错。除非你的数据包大小本身就很小。</p>
<h2 id="五、-BLE（Bluetooth-low-energy）协议栈简介"><a href="#五、-BLE（Bluetooth-low-energy）协议栈简介" class="headerlink" title="五、 BLE（Bluetooth low energy）协议栈简介"></a>五、 BLE（Bluetooth low energy）协议栈简介</h2><p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/3868f677d33eb7ac28a73555d1893035.awebp%23" alt="image.png"></p>
<p><strong>控制器（Controller）</strong></p>
<p>● 物理层（Physical Layer，PHY），工作在免费的2.4G频段，采用高斯频移键控。</p>
<p>● 链路层（Link Layer，LL），控制设备的射频状态，让设备处于这五种状态之一：</p>
<ol>
<li>Standby：默认状态，不进行收发。</li>
<li>Advertising：广播状态，在3个广播信道广播数据包，同时监听和回复扫描者发送的扫描数据包。</li>
<li>Scanning：扫描状态，在3个广播信息监听广播数据包，同时发送扫描数据包。</li>
<li>nitiating：初始化状态，在广播信道监听广播数据包，从而发起连接。</li>
<li>Connection：连接状态。</li>
</ol>
<p><strong>主机控制接口（HCI）</strong></p>
<p>主机控制接口（Host-Controller Interface，HCI）提供了Host与Controller之间的通道。该接口层的实现可以是软件接口，也可以是标准硬件接口，比如UART，SPI或USB。</p>
<p><strong>主机（Host）</strong></p>
<p>● 逻辑链路控制和适配器协议（Logical Link Control and Adaption Protocol，L2CAP）为上层提供了多路复用、数据分段与重组服务，并且支持逻辑端对端的数据通信。</p>
<p>● 安全管理层（Security Manager，SM）定义了配对和密钥分发的方法，并为其他层提供了与对端设备进行安全连接和数据交换的功能。</p>
<p>● 通用访问规范层（Generic Access Profile，GAP）是BLE协议栈与Application和Profiles的直接接口。它负责设备发现以及连接相关的各项服务，包括工作模式和访问模式。BLE的工作模式有4种：广播、扫描、周边外设和主设备。访问模式包括设备发现、连接模式、认证和服务发现等。</p>
<p>● 属性协议层（Attribute Protocol，ATT）使本地设备可以暴露一些数据或属性给对端设备。它区分两种角色：客户机和服务器。客户机和服务器通过逻辑信道通信。</p>
<p>● 通用属性配置文件层（Generic Attribute Profile，GATT）定义使用ATT的一系列子过程。两个BLE设备之间的数据通信是由这些子过程来处理的。GATT Services和Applications可以直接使用GATT。</p>
<h4 id="BLE协议栈各层功能机制-体系结构"><a href="#BLE协议栈各层功能机制-体系结构" class="headerlink" title="BLE协议栈各层功能机制&#x2F;体系结构"></a>BLE协议栈各层功能机制&#x2F;体系结构</h4><p>如上图所述，要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：</p>
<p><strong>PHY层</strong>（Physical layer物理层）。PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。</p>
<p><strong>LL层</strong>（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT。</p>
<p><strong>HCI</strong>（Host controller interface）。HCI是可选的，HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。</p>
<p><strong>GAP层</strong>（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。</p>
<p><strong>L2CAP层</strong>（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。</p>
<p><strong>SMP</strong>（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。</p>
<p><strong>ATT</strong>（Attribute protocol）。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。</p>
<p><strong>GATT</strong>（Generic attribute profile ）。GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。</p>
<p><img src="https://markdown-1305107759.cos.ap-guangzhou.myqcloud.com/64a7d78de58c9e7602401c4ae2879bb1.awebp%23" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io">BravestSnail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://bravestsnail.github.io/2025/06/04/note/Android/BLE/Android%20BLE/">https://bravestsnail.github.io/2025/06/04/note/Android/BLE/Android%20BLE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://bravestsnail.github.io" target="_blank">BravestSnail's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/note/Android/Launcher%E5%90%AF%E5%8A%A8Activity%E7%9A%84%E8%BF%87%E7%A8%8B/" title="Launcher启动Activity的过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Launcher启动Activity的过程</div></div><div class="info-2"><div class="info-item-1">Launcher请求AMS的过程sequenceDiagram Launcher ->> Activity: startActivity Activity ->> Activity: startActivityForResult Activity ->>Instrumentation: execStartActivity Instrumentation ->> IActivityManager: startActivity IActivityManager ->> AMS: startActivity</div></div></div></a><a class="pagination-related" href="/2025/06/04/note/Android/Framework/Android%20%E6%9C%80%E8%BF%91%E4%BB%BB%E5%8A%A1/" title="Android 最近任务"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Android 最近任务</div></div><div class="info-2"><div class="info-item-1">获取最近任务sequenceDiagram ActivityManagerService ->> ActivityTaskManagerService: getRecentTasks ActivityTaskManagerService ->> RecentTasks: getRecentTasks RecentTasks ->> RecentTasks: loadUserRecentsLocked  RecentTasks ->> RecentTasks: loadPersistedTaskIdsForUserLocked RecentTasks ->> TaskPersister: restoreTasksForUserLocked 最近任务持久化存放目录/data/system_ce/0/recent_tasks </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">BravestSnail</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-BLE-%E6%9D%82%E8%B0%88"><span class="toc-number">1.</span> <span class="toc-text">Android BLE 杂谈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%A2%86%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">主要解决方案领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-number">1.2.</span> <span class="toc-text">零、基本概念 - 官方文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81BLE%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">一、BLE设备连接通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E8%A7%92%E8%89%B2"><span class="toc-number">1.3.1.</span> <span class="toc-text">设备角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BLE%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">BLE设备连接交互流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">扫描的工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81BLE%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">二、BLE应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81BLE%E4%B8%ADGATT%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%89%B9%E5%BE%81%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">三、BLE中GATT的服务和特征发现机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.6.</span> <span class="toc-text">四、蓝牙连接数据包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81BLE-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%89%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9ASCAN-REQ-SCAN-RSP-%E5%92%8C-CONNECT-REQ"><span class="toc-number">1.6.0.0.1.</span> <span class="toc-text">1、BLE 连接过程中有三个重要的数据包：SCAN_REQ, SCAN_RSP 和 CONNECT_REQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMTU"><span class="toc-number">1.6.0.0.2.</span> <span class="toc-text">2、什么是MTU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%AE%BE%E7%BD%AEreqeustMtu"><span class="toc-number">1.6.0.0.3.</span> <span class="toc-text">3、设置reqeustMtu</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%A7%E5%B0%8F%EF%BC%88MTU%EF%BC%89%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.6.0.0.4.</span> <span class="toc-text">4、数据包大小（MTU）的限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88BLE%E9%BB%98%E8%AE%A4%E9%99%90%E5%88%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%95%BF%E5%BA%A6%E4%B8%BA20%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">1.6.0.0.5.</span> <span class="toc-text">问题一、为什么BLE默认限制数据传输长度为20个字节？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BD%95MTU"><span class="toc-number">1.6.0.0.6.</span> <span class="toc-text">问题二、为什么需要记录MTU</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81-BLE%EF%BC%88Bluetooth-low-energy%EF%BC%89%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B"><span class="toc-number">1.7.</span> <span class="toc-text">五、 BLE（Bluetooth low energy）协议栈简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BLE%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD%E6%9C%BA%E5%88%B6-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">BLE协议栈各层功能机制&#x2F;体系结构</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E4%B8%8A%E4%B8%8B%E6%96%87Context/" title="上下文Context">上下文Context</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">正则表达式</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/" title="注解和注解处理器">注解和注解处理器</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="进程、线程、协程的区别">进程、线程、协程的区别</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/note/kotlin/Kotlin%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Kotlin踩坑记录">Kotlin踩坑记录</a><time datetime="2025-06-04T12:46:35.127Z" title="发表于 2025-06-04 20:46:35">2025-06-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By BravestSnail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>